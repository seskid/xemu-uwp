/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_BLOCK_GENERATED_TRACERS_H
#define TRACE_HW_BLOCK_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_FDC_IOPORT_READ_EVENT;
extern TraceEvent _TRACE_FDC_IOPORT_WRITE_EVENT;
extern TraceEvent _TRACE_FDCTRL_TC_PULSE_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_CHIP_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_DATA_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_DEVICE_INFO_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_COMPLETE_EVENT;
extern TraceEvent _TRACE_PFLASH_ERASE_TIMEOUT_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_READ_EVENT;
extern TraceEvent _TRACE_PFLASH_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_MANUFACTURER_ID_EVENT;
extern TraceEvent _TRACE_PFLASH_MODE_READ_ARRAY_EVENT;
extern TraceEvent _TRACE_PFLASH_POSTLOAD_CB_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_DONE_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_STATUS_EVENT;
extern TraceEvent _TRACE_PFLASH_READ_UNKNOWN_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_RESET_EVENT;
extern TraceEvent _TRACE_PFLASH_SECTOR_ERASE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_TIMER_EXPIRED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK0_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNLOCK1_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_BLOCK_ERASE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_FAILED_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_COMMAND_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_INVALID_STATE_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_START_EVENT;
extern TraceEvent _TRACE_PFLASH_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_REQ_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_RW_COMPLETE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_HANDLE_READ_EVENT;
extern TraceEvent _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_LCHS_GUESS_EVENT;
extern TraceEvent _TRACE_HD_GEOMETRY_GUESS_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_CONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DISCONNECT_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_SIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_DISK_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_REALIZE_EVENT;
extern TraceEvent _TRACE_XEN_CDROM_UNREALIZE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_ADD_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_BLOCKDEV_DEL_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_CREATE_EVENT;
extern TraceEvent _TRACE_XEN_BLOCK_DEVICE_DESTROY_EVENT;
extern TraceEvent _TRACE_M25P80_FLASH_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_EVENT;
extern TraceEvent _TRACE_M25P80_RESET_DONE_EVENT;
extern TraceEvent _TRACE_M25P80_COMMAND_DECODED_EVENT;
extern TraceEvent _TRACE_M25P80_COMPLETE_COLLECTING_EVENT;
extern TraceEvent _TRACE_M25P80_POPULATED_JEDEC_EVENT;
extern TraceEvent _TRACE_M25P80_CHIP_ERASE_EVENT;
extern TraceEvent _TRACE_M25P80_SELECT_EVENT;
extern TraceEvent _TRACE_M25P80_PAGE_PROGRAM_EVENT;
extern TraceEvent _TRACE_M25P80_TRANSFER_EVENT;
extern TraceEvent _TRACE_M25P80_READ_BYTE_EVENT;
extern TraceEvent _TRACE_M25P80_READ_DATA_EVENT;
extern TraceEvent _TRACE_M25P80_READ_SFDP_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_EVENT;
extern TraceEvent _TRACE_M25P80_BINDING_NO_BDRV_EVENT;
extern uint16_t _TRACE_FDC_IOPORT_READ_DSTATE;
extern uint16_t _TRACE_FDC_IOPORT_WRITE_DSTATE;
extern uint16_t _TRACE_FDCTRL_TC_PULSE_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_CHIP_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_DATA_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_DEVICE_INFO_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_COMPLETE_DSTATE;
extern uint16_t _TRACE_PFLASH_ERASE_TIMEOUT_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_READ_DSTATE;
extern uint16_t _TRACE_PFLASH_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_MANUFACTURER_ID_DSTATE;
extern uint16_t _TRACE_PFLASH_MODE_READ_ARRAY_DSTATE;
extern uint16_t _TRACE_PFLASH_POSTLOAD_CB_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_DONE_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_STATUS_DSTATE;
extern uint16_t _TRACE_PFLASH_READ_UNKNOWN_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_RESET_DSTATE;
extern uint16_t _TRACE_PFLASH_SECTOR_ERASE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_TIMER_EXPIRED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK0_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNLOCK1_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_BLOCK_ERASE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_FAILED_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_COMMAND_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_INVALID_STATE_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_START_DSTATE;
extern uint16_t _TRACE_PFLASH_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_REQ_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_RW_COMPLETE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_HANDLE_READ_DSTATE;
extern uint16_t _TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_LCHS_GUESS_DSTATE;
extern uint16_t _TRACE_HD_GEOMETRY_GUESS_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_CONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DISCONNECT_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_SIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_DISK_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_REALIZE_DSTATE;
extern uint16_t _TRACE_XEN_CDROM_UNREALIZE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_ADD_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_BLOCKDEV_DEL_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_CREATE_DSTATE;
extern uint16_t _TRACE_XEN_BLOCK_DEVICE_DESTROY_DSTATE;
extern uint16_t _TRACE_M25P80_FLASH_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_DSTATE;
extern uint16_t _TRACE_M25P80_RESET_DONE_DSTATE;
extern uint16_t _TRACE_M25P80_COMMAND_DECODED_DSTATE;
extern uint16_t _TRACE_M25P80_COMPLETE_COLLECTING_DSTATE;
extern uint16_t _TRACE_M25P80_POPULATED_JEDEC_DSTATE;
extern uint16_t _TRACE_M25P80_CHIP_ERASE_DSTATE;
extern uint16_t _TRACE_M25P80_SELECT_DSTATE;
extern uint16_t _TRACE_M25P80_PAGE_PROGRAM_DSTATE;
extern uint16_t _TRACE_M25P80_TRANSFER_DSTATE;
extern uint16_t _TRACE_M25P80_READ_BYTE_DSTATE;
extern uint16_t _TRACE_M25P80_READ_DATA_DSTATE;
extern uint16_t _TRACE_M25P80_READ_SFDP_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_DSTATE;
extern uint16_t _TRACE_M25P80_BINDING_NO_BDRV_DSTATE;
#define TRACE_FDC_IOPORT_READ_ENABLED 1
#define TRACE_FDC_IOPORT_WRITE_ENABLED 1
#define TRACE_FDCTRL_TC_PULSE_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_INVALID_ENABLED 1
#define TRACE_PFLASH_CHIP_ERASE_START_ENABLED 1
#define TRACE_PFLASH_DATA_READ_ENABLED 1
#define TRACE_PFLASH_DATA_WRITE_ENABLED 1
#define TRACE_PFLASH_DEVICE_ID_ENABLED 1
#define TRACE_PFLASH_DEVICE_INFO_ENABLED 1
#define TRACE_PFLASH_ERASE_COMPLETE_ENABLED 1
#define TRACE_PFLASH_ERASE_TIMEOUT_ENABLED 1
#define TRACE_PFLASH_IO_READ_ENABLED 1
#define TRACE_PFLASH_IO_WRITE_ENABLED 1
#define TRACE_PFLASH_MANUFACTURER_ID_ENABLED 1
#define TRACE_PFLASH_MODE_READ_ARRAY_ENABLED 1
#define TRACE_PFLASH_POSTLOAD_CB_ENABLED 1
#define TRACE_PFLASH_READ_DONE_ENABLED 1
#define TRACE_PFLASH_READ_STATUS_ENABLED 1
#define TRACE_PFLASH_READ_UNKNOWN_STATE_ENABLED 1
#define TRACE_PFLASH_RESET_ENABLED 1
#define TRACE_PFLASH_SECTOR_ERASE_START_ENABLED 1
#define TRACE_PFLASH_TIMER_EXPIRED_ENABLED 1
#define TRACE_PFLASH_UNLOCK0_FAILED_ENABLED 1
#define TRACE_PFLASH_UNLOCK1_FAILED_ENABLED 1
#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_ENABLED 1
#define TRACE_PFLASH_WRITE_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ENABLED 1
#define TRACE_PFLASH_WRITE_BLOCK_ERASE_ENABLED 1
#define TRACE_PFLASH_WRITE_FAILED_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_COMMAND_ENABLED 1
#define TRACE_PFLASH_WRITE_INVALID_STATE_ENABLED 1
#define TRACE_PFLASH_WRITE_START_ENABLED 1
#define TRACE_PFLASH_WRITE_UNKNOWN_ENABLED 1
#define TRACE_VIRTIO_BLK_REQ_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_RW_COMPLETE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_WRITE_ENABLED 1
#define TRACE_VIRTIO_BLK_HANDLE_READ_ENABLED 1
#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_ENABLED 1
#define TRACE_HD_GEOMETRY_LCHS_GUESS_ENABLED 1
#define TRACE_HD_GEOMETRY_GUESS_ENABLED 1
#define TRACE_XEN_BLOCK_REALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_CONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_DISCONNECT_ENABLED 1
#define TRACE_XEN_BLOCK_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_SIZE_ENABLED 1
#define TRACE_XEN_DISK_REALIZE_ENABLED 1
#define TRACE_XEN_DISK_UNREALIZE_ENABLED 1
#define TRACE_XEN_CDROM_REALIZE_ENABLED 1
#define TRACE_XEN_CDROM_UNREALIZE_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_ENABLED 1
#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_CREATE_ENABLED 1
#define TRACE_XEN_BLOCK_DEVICE_DESTROY_ENABLED 1
#define TRACE_M25P80_FLASH_ERASE_ENABLED 1
#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_ENABLED 1
#define TRACE_M25P80_RESET_DONE_ENABLED 1
#define TRACE_M25P80_COMMAND_DECODED_ENABLED 1
#define TRACE_M25P80_COMPLETE_COLLECTING_ENABLED 1
#define TRACE_M25P80_POPULATED_JEDEC_ENABLED 1
#define TRACE_M25P80_CHIP_ERASE_ENABLED 1
#define TRACE_M25P80_SELECT_ENABLED 1
#define TRACE_M25P80_PAGE_PROGRAM_ENABLED 1
#define TRACE_M25P80_TRANSFER_ENABLED 1
#define TRACE_M25P80_READ_BYTE_ENABLED 1
#define TRACE_M25P80_READ_DATA_ENABLED 1
#define TRACE_M25P80_READ_SFDP_ENABLED 1
#define TRACE_M25P80_BINDING_ENABLED 1
#define TRACE_M25P80_BINDING_NO_BDRV_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_FDC_IOPORT_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_READ) || \
    false)

static inline void _nocheck__trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 235 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 4 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("fdc_ioport_read " "read reg 0x%02x val 0x%02x" "\n", reg, value);
#line 239 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_read(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_read(reg, value);
    }
}

#define TRACE_FDC_IOPORT_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDC_IOPORT_WRITE) || \
    false)

static inline void _nocheck__trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (trace_event_get_state(TRACE_FDC_IOPORT_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, value);
#line 266 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 5 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("fdc_ioport_write " "write reg 0x%02x val 0x%02x" "\n", reg, value);
#line 270 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdc_ioport_write(uint8_t reg, uint8_t value)
{
    if (true) {
        _nocheck__trace_fdc_ioport_write(reg, value);
    }
}

#define TRACE_FDCTRL_TC_PULSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_FDCTRL_TC_PULSE) || \
    false)

static inline void _nocheck__trace_fdctrl_tc_pulse(int level)
{
    if (trace_event_get_state(TRACE_FDCTRL_TC_PULSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:fdctrl_tc_pulse " "TC pulse: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level);
#line 297 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 8 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("fdctrl_tc_pulse " "TC pulse: %u" "\n", level);
#line 301 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_fdctrl_tc_pulse(int level)
{
    if (true) {
        _nocheck__trace_fdctrl_tc_pulse(level);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 328 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 12 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_chip_erase_invalid " "%s: chip erase: invalid address 0x%" PRIx64 "\n", name, offset);
#line 332 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_invalid(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_invalid(name, offset);
    }
}

#define TRACE_PFLASH_CHIP_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_CHIP_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_chip_erase_start(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_CHIP_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_chip_erase_start " "%s: start chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 359 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 13 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_chip_erase_start " "%s: start chip erase" "\n", name);
#line 363 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_chip_erase_start(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_chip_erase_start(name);
    }
}

#define TRACE_PFLASH_DATA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_READ) || \
    false)

static inline void _nocheck__trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value);
#line 390 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 14 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_data_read " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x" "\n", name, offset, size, value);
#line 394 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_read(const char * name, uint64_t offset, unsigned size, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_data_read(name, offset, size, value);
    }
}

#define TRACE_PFLASH_DATA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DATA_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (trace_event_get_state(TRACE_PFLASH_DATA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, counter);
#line 421 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 15 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_data_write " "%s: data offset:0x%04"PRIx64" size:%u value:0x%04x counter:0x%016"PRIx64 "\n", name, offset, size, value, counter);
#line 425 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_data_write(const char * name, uint64_t offset, unsigned size, uint32_t value, uint64_t counter)
{
    if (true) {
        _nocheck__trace_pflash_data_write(name, offset, size, value, counter);
    }
}

#define TRACE_PFLASH_DEVICE_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_ID) || \
    false)

static inline void _nocheck__trace_pflash_device_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_id " "%s: read device ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 452 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 16 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_device_id " "%s: read device ID: 0x%04x" "\n", name, id);
#line 456 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_device_id(name, id);
    }
}

#define TRACE_PFLASH_DEVICE_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_DEVICE_INFO) || \
    false)

static inline void _nocheck__trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (trace_event_get_state(TRACE_PFLASH_DEVICE_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset);
#line 483 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 17 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_device_info " "%s: read device information offset:0x%04" PRIx64 "\n", name, offset);
#line 487 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_device_info(const char * name, uint64_t offset)
{
    if (true) {
        _nocheck__trace_pflash_device_info(name, offset);
    }
}

#define TRACE_PFLASH_ERASE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_COMPLETE) || \
    false)

static inline void _nocheck__trace_pflash_erase_complete(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_complete " "%s: sector erase complete" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 514 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 18 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_erase_complete " "%s: sector erase complete" "\n", name);
#line 518 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_complete(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_erase_complete(name);
    }
}

#define TRACE_PFLASH_ERASE_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_ERASE_TIMEOUT) || \
    false)

static inline void _nocheck__trace_pflash_erase_timeout(const char * name, int count)
{
    if (trace_event_get_state(TRACE_PFLASH_ERASE_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, count);
#line 545 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 19 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_erase_timeout " "%s: erase timeout fired; erasing %d sectors" "\n", name, count);
#line 549 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_erase_timeout(const char * name, int count)
{
    if (true) {
        _nocheck__trace_pflash_erase_timeout(name, count);
    }
}

#define TRACE_PFLASH_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_READ) || \
    false)

static inline void _nocheck__trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, cmd, wcycle);
#line 576 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 20 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_io_read " "%s: offset:0x%04" PRIx64 " size:%u value:0x%04x cmd:0x%02x wcycle:%u" "\n", name, offset, size, value, cmd, wcycle);
#line 580 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_read(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t cmd, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_read(name, offset, size, value, cmd, wcycle);
    }
}

#define TRACE_PFLASH_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_IO_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (trace_event_get_state(TRACE_PFLASH_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, size, value, wcycle);
#line 607 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 21 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_io_write " "%s: offset:0x%04"PRIx64" size:%u value:0x%04x wcycle:%u" "\n", name, offset, size, value, wcycle);
#line 611 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_io_write(const char * name, uint64_t offset, unsigned int size, uint32_t value, uint8_t wcycle)
{
    if (true) {
        _nocheck__trace_pflash_io_write(name, offset, size, value, wcycle);
    }
}

#define TRACE_PFLASH_MANUFACTURER_ID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MANUFACTURER_ID) || \
    false)

static inline void _nocheck__trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (trace_event_get_state(TRACE_PFLASH_MANUFACTURER_ID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, id);
#line 638 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 22 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_manufacturer_id " "%s: read manufacturer ID: 0x%04x" "\n", name, id);
#line 642 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_manufacturer_id(const char * name, uint16_t id)
{
    if (true) {
        _nocheck__trace_pflash_manufacturer_id(name, id);
    }
}

#define TRACE_PFLASH_MODE_READ_ARRAY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_MODE_READ_ARRAY) || \
    false)

static inline void _nocheck__trace_pflash_mode_read_array(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_MODE_READ_ARRAY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_mode_read_array " "%s: read array mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 669 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 23 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_mode_read_array " "%s: read array mode" "\n", name);
#line 673 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_mode_read_array(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_mode_read_array(name);
    }
}

#define TRACE_PFLASH_POSTLOAD_CB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_POSTLOAD_CB) || \
    false)

static inline void _nocheck__trace_pflash_postload_cb(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_POSTLOAD_CB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_postload_cb " "%s: updating bdrv" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 700 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 24 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_postload_cb " "%s: updating bdrv" "\n", name);
#line 704 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_postload_cb(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_postload_cb(name);
    }
}

#define TRACE_PFLASH_READ_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_DONE) || \
    false)

static inline void _nocheck__trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, ret);
#line 731 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 25 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_read_done " "%s: ID:0x%" PRIx64 " ret:0x%" PRIx64 "\n", name, offset, ret);
#line 735 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_done(const char * name, uint64_t offset, uint64_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_done(name, offset, ret);
    }
}

#define TRACE_PFLASH_READ_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_STATUS) || \
    false)

static inline void _nocheck__trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_status " "%s: status:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, ret);
#line 762 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 26 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_read_status " "%s: status:0x%x" "\n", name, ret);
#line 766 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_status(const char * name, uint32_t ret)
{
    if (true) {
        _nocheck__trace_pflash_read_status(name, ret);
    }
}

#define TRACE_PFLASH_READ_UNKNOWN_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_READ_UNKNOWN_STATE) || \
    false)

static inline void _nocheck__trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_READ_UNKNOWN_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 793 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 27 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_read_unknown_state " "%s: unknown command state:0x%x" "\n", name, cmd);
#line 797 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_read_unknown_state(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_read_unknown_state(name, cmd);
    }
}

#define TRACE_PFLASH_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_RESET) || \
    false)

static inline void _nocheck__trace_pflash_reset(const char * name)
{
    if (trace_event_get_state(TRACE_PFLASH_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_reset " "%s: reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 824 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 28 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_reset " "%s: reset" "\n", name);
#line 828 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_reset(const char * name)
{
    if (true) {
        _nocheck__trace_pflash_reset(name);
    }
}

#define TRACE_PFLASH_SECTOR_ERASE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_SECTOR_ERASE_START) || \
    false)

static inline void _nocheck__trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (trace_event_get_state(TRACE_PFLASH_SECTOR_ERASE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width1, start, width2, end);
#line 855 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 29 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_sector_erase_start " "%s: start sector erase at: 0x%0*" PRIx64 "-0x%0*" PRIx64 "\n", name, width1, start, width2, end);
#line 859 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_sector_erase_start(const char * name, int width1, uint64_t start, int width2, uint64_t end)
{
    if (true) {
        _nocheck__trace_pflash_sector_erase_start(name, width1, start, width2, end);
    }
}

#define TRACE_PFLASH_TIMER_EXPIRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_TIMER_EXPIRED) || \
    false)

static inline void _nocheck__trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_TIMER_EXPIRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_timer_expired " "%s: command 0x%02x done" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 886 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 30 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_timer_expired " "%s: command 0x%02x done" "\n", name, cmd);
#line 890 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_timer_expired(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_timer_expired(name, cmd);
    }
}

#define TRACE_PFLASH_UNLOCK0_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK0_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK0_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd, addr0);
#line 917 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 31 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_unlock0_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x 0x%04x" "\n", name, offset, cmd, addr0);
#line 921 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock0_failed(const char * name, uint64_t offset, uint8_t cmd, uint16_t addr0)
{
    if (true) {
        _nocheck__trace_pflash_unlock0_failed(name, offset, cmd, addr0);
    }
}

#define TRACE_PFLASH_UNLOCK1_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNLOCK1_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_UNLOCK1_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 948 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 32 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_unlock1_failed " "%s: unlock0 failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 952 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unlock1_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_unlock1_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) || \
    false)

static inline void _nocheck__trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (trace_event_get_state(TRACE_PFLASH_UNSUPPORTED_DEVICE_CONFIGURATION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, width, max);
#line 979 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 33 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_unsupported_device_configuration " "%s: unsupported device configuration: device_width:%d max_device_width:%d" "\n", name, width, max);
#line 983 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_unsupported_device_configuration(const char * name, uint8_t width, uint8_t max)
{
    if (true) {
        _nocheck__trace_pflash_unsupported_device_configuration(name, width, max);
    }
}

#define TRACE_PFLASH_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE) || \
    false)

static inline void _nocheck__trace_pflash_write(const char * name, const char * str)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write " "%s: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, str);
#line 1010 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 34 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write " "%s: %s" "\n", name, str);
#line 1014 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write(const char * name, const char * str)
{
    if (true) {
        _nocheck__trace_pflash_write(name, str);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK) || \
    false)

static inline void _nocheck__trace_pflash_write_block(const char * name, uint32_t value)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block " "%s: block write: bytes:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, value);
#line 1041 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 35 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_block " "%s: block write: bytes:0x%x" "\n", name, value);
#line 1045 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block(const char * name, uint32_t value)
{
    if (true) {
        _nocheck__trace_pflash_write_block(name, value);
    }
}

#define TRACE_PFLASH_WRITE_BLOCK_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_BLOCK_ERASE) || \
    false)

static inline void _nocheck__trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_BLOCK_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, len);
#line 1072 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 36 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_block_erase " "%s: block erase offset:0x%" PRIx64 " bytes:0x%" PRIx64 "\n", name, offset, len);
#line 1076 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_block_erase(const char * name, uint64_t offset, uint64_t len)
{
    if (true) {
        _nocheck__trace_pflash_write_block_erase(name, offset, len);
    }
}

#define TRACE_PFLASH_WRITE_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_FAILED) || \
    false)

static inline void _nocheck__trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, cmd);
#line 1103 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 37 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_failed " "%s: command failed 0x%" PRIx64 " 0x%02x" "\n", name, offset, cmd);
#line 1107 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_failed(const char * name, uint64_t offset, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_failed(name, offset, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1134 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 38 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_invalid " "%s: invalid write for command 0x%02x" "\n", name, cmd);
#line 1138 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_COMMAND) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1165 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 39 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_invalid_command " "%s: invalid command 0x%02x (wc 5)" "\n", name, cmd);
#line 1169 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_command(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_command(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_INVALID_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_INVALID_STATE) || \
    false)

static inline void _nocheck__trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_INVALID_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd, wc);
#line 1196 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 40 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_invalid_state " "%s: invalid command state 0x%02x (wc %d)" "\n", name, cmd, wc);
#line 1200 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_invalid_state(const char * name, uint8_t cmd, int wc)
{
    if (true) {
        _nocheck__trace_pflash_write_invalid_state(name, cmd, wc);
    }
}

#define TRACE_PFLASH_WRITE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_START) || \
    false)

static inline void _nocheck__trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_start " "%s: starting command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1227 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 41 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_start " "%s: starting command 0x%02x" "\n", name, cmd);
#line 1231 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_start(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_start(name, cmd);
    }
}

#define TRACE_PFLASH_WRITE_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PFLASH_WRITE_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_PFLASH_WRITE_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:pflash_write_unknown " "%s: unknown command 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cmd);
#line 1258 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 42 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("pflash_write_unknown " "%s: unknown command 0x%02x" "\n", name, cmd);
#line 1262 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_pflash_write_unknown(const char * name, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_pflash_write_unknown(name, cmd);
    }
}

#define TRACE_VIRTIO_BLK_REQ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_REQ_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_req_complete " "vdev %p req %p status %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, status);
#line 1289 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 45 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("virtio_blk_req_complete " "vdev %p req %p status %d" "\n", vdev, req, status);
#line 1293 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_req_complete(void * vdev, void * req, int status)
{
    if (true) {
        _nocheck__trace_virtio_blk_req_complete(vdev, req, status);
    }
}

#define TRACE_VIRTIO_BLK_RW_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_RW_COMPLETE) || \
    false)

static inline void _nocheck__trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, ret);
#line 1320 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 46 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("virtio_blk_rw_complete " "vdev %p req %p ret %d" "\n", vdev, req, ret);
#line 1324 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_rw_complete(void * vdev, void * req, int ret)
{
    if (true) {
        _nocheck__trace_virtio_blk_rw_complete(vdev, req, ret);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_WRITE) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1351 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 47 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("virtio_blk_handle_write " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1355 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_write(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_write(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_HANDLE_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_HANDLE_READ) || \
    false)

static inline void _nocheck__trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, req, sector, nsectors);
#line 1382 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 48 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("virtio_blk_handle_read " "vdev %p req %p sector %"PRIu64" nsectors %zu" "\n", vdev, req, sector, nsectors);
#line 1386 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_handle_read(void * vdev, void * req, uint64_t sector, size_t nsectors)
{
    if (true) {
        _nocheck__trace_virtio_blk_handle_read(vdev, req, sector, nsectors);
    }
}

#define TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) || \
    false)

static inline void _nocheck__trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (trace_event_get_state(TRACE_VIRTIO_BLK_SUBMIT_MULTIREQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1413 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 49 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("virtio_blk_submit_multireq " "vdev %p mrb %p start %d num_reqs %d offset %"PRIu64" size %zu is_write %d" "\n", vdev, mrb, start, num_reqs, offset, size, is_write);
#line 1417 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_virtio_blk_submit_multireq(void * vdev, void * mrb, int start, int num_reqs, uint64_t offset, size_t size, bool is_write)
{
    if (true) {
        _nocheck__trace_virtio_blk_submit_multireq(vdev, mrb, start, num_reqs, offset, size, is_write);
    }
}

#define TRACE_HD_GEOMETRY_LCHS_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_LCHS_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs);
#line 1444 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 52 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("hd_geometry_lchs_guess " "blk %p LCHS %d %d %d" "\n", blk, cyls, heads, secs);
#line 1448 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_lchs_guess(void * blk, int cyls, int heads, int secs)
{
    if (true) {
        _nocheck__trace_hd_geometry_lchs_guess(blk, cyls, heads, secs);
    }
}

#define TRACE_HD_GEOMETRY_GUESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_HD_GEOMETRY_GUESS) || \
    false)

static inline void _nocheck__trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (trace_event_get_state(TRACE_HD_GEOMETRY_GUESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blk, cyls, heads, secs, trans);
#line 1475 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 53 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("hd_geometry_guess " "blk %p CHS %u %u %u trans %d" "\n", blk, cyls, heads, secs, trans);
#line 1479 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_hd_geometry_guess(void * blk, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    if (true) {
        _nocheck__trace_hd_geometry_guess(blk, cyls, heads, secs, trans);
    }
}

#define TRACE_XEN_BLOCK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_realize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1506 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 56 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_realize " "%s d%up%u" "\n", type, disk, partition);
#line 1510 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_realize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_realize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_CONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_connect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1537 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 57 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_connect " "%s d%up%u" "\n", type, disk, partition);
#line 1541 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_connect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_connect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DISCONNECT) || \
    false)

static inline void _nocheck__trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_disconnect " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1568 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 58 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_disconnect " "%s d%up%u" "\n", type, disk, partition);
#line 1572 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_disconnect(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_disconnect(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_unrealize " "%s d%up%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition);
#line 1599 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 59 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_unrealize " "%s d%up%u" "\n", type, disk, partition);
#line 1603 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_unrealize(const char * type, uint32_t disk, uint32_t partition)
{
    if (true) {
        _nocheck__trace_xen_block_unrealize(type, disk, partition);
    }
}

#define TRACE_XEN_BLOCK_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_SIZE) || \
    false)

static inline void _nocheck__trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_size " "%s d%up%u %"PRIi64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, disk, partition, sectors);
#line 1630 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 60 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_size " "%s d%up%u %"PRIi64 "\n", type, disk, partition, sectors);
#line 1634 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_size(const char * type, uint32_t disk, uint32_t partition, int64_t sectors)
{
    if (true) {
        _nocheck__trace_xen_block_size(type, disk, partition, sectors);
    }
}

#define TRACE_XEN_DISK_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1661 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 61 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_disk_realize " "" "\n");
#line 1665 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_realize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_realize();
    }
}

#define TRACE_XEN_DISK_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_DISK_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_disk_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_DISK_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_disk_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1692 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 62 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_disk_unrealize " "" "\n");
#line 1696 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_disk_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_disk_unrealize();
    }
}

#define TRACE_XEN_CDROM_REALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_REALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_realize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_REALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_realize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1723 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 63 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_cdrom_realize " "" "\n");
#line 1727 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_realize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_realize();
    }
}

#define TRACE_XEN_CDROM_UNREALIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_CDROM_UNREALIZE) || \
    false)

static inline void _nocheck__trace_xen_cdrom_unrealize(void)
{
    if (trace_event_get_state(TRACE_XEN_CDROM_UNREALIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_cdrom_unrealize " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 1754 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 64 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_cdrom_unrealize " "" "\n");
#line 1758 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_cdrom_unrealize(void)
{
    if (true) {
        _nocheck__trace_xen_cdrom_unrealize();
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_ADD) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_add(char * str)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_add " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , str);
#line 1785 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 65 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_blockdev_add " "%s" "\n", str);
#line 1789 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_add(char * str)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_add(str);
    }
}

#define TRACE_XEN_BLOCK_BLOCKDEV_DEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_BLOCKDEV_DEL) || \
    false)

static inline void _nocheck__trace_xen_block_blockdev_del(const char * node_name)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_BLOCKDEV_DEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_blockdev_del " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , node_name);
#line 1816 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 66 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_blockdev_del " "%s" "\n", node_name);
#line 1820 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_blockdev_del(const char * node_name)
{
    if (true) {
        _nocheck__trace_xen_block_blockdev_del(node_name);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_CREATE) || \
    false)

static inline void _nocheck__trace_xen_block_device_create(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_create " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 1847 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 67 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_device_create " "%u" "\n", number);
#line 1851 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_create(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_create(number);
    }
}

#define TRACE_XEN_BLOCK_DEVICE_DESTROY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XEN_BLOCK_DEVICE_DESTROY) || \
    false)

static inline void _nocheck__trace_xen_block_device_destroy(unsigned int number)
{
    if (trace_event_get_state(TRACE_XEN_BLOCK_DEVICE_DESTROY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:xen_block_device_destroy " "%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , number);
#line 1878 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 68 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("xen_block_device_destroy " "%u" "\n", number);
#line 1882 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_xen_block_device_destroy(unsigned int number)
{
    if (true) {
        _nocheck__trace_xen_block_device_destroy(number);
    }
}

#define TRACE_M25P80_FLASH_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_FLASH_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (trace_event_get_state(TRACE_M25P80_FLASH_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, offset, len);
#line 1909 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 71 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_flash_erase " "[%p] offset = 0x%"PRIx32", len = %u" "\n", s, offset, len);
#line 1913 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_flash_erase(void * s, int offset, uint32_t len)
{
    if (true) {
        _nocheck__trace_m25p80_flash_erase(s, offset, len);
    }
}

#define TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) || \
    false)

static inline void _nocheck__trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (trace_event_get_state(TRACE_M25P80_PROGRAMMING_ZERO_TO_ONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, prev, data);
#line 1940 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 72 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_programming_zero_to_one " "[%p] programming zero to one! addr=0x%"PRIx32"  0x%"PRIx8" -> 0x%"PRIx8 "\n", s, addr, prev, data);
#line 1944 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_programming_zero_to_one(void * s, uint32_t addr, uint8_t prev, uint8_t data)
{
    if (true) {
        _nocheck__trace_m25p80_programming_zero_to_one(s, addr, prev, data);
    }
}

#define TRACE_M25P80_RESET_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_RESET_DONE) || \
    false)

static inline void _nocheck__trace_m25p80_reset_done(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_RESET_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_reset_done " "[%p] Reset done." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 1971 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 73 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_reset_done " "[%p] Reset done." "\n", s);
#line 1975 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_reset_done(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_reset_done(s);
    }
}

#define TRACE_M25P80_COMMAND_DECODED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMMAND_DECODED) || \
    false)

static inline void _nocheck__trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (trace_event_get_state(TRACE_M25P80_COMMAND_DECODED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd);
#line 2002 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 74 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_command_decoded " "[%p] new command:0x%"PRIx32 "\n", s, cmd);
#line 2006 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_command_decoded(void * s, uint32_t cmd)
{
    if (true) {
        _nocheck__trace_m25p80_command_decoded(s, cmd);
    }
}

#define TRACE_M25P80_COMPLETE_COLLECTING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_COMPLETE_COLLECTING) || \
    false)

static inline void _nocheck__trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (trace_event_get_state(TRACE_M25P80_COMPLETE_COLLECTING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, cmd, n, ear, cur_addr);
#line 2033 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 75 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_complete_collecting " "[%p] decode cmd: 0x%"PRIx32" len %d ear 0x%"PRIx8" addr 0x%"PRIx32 "\n", s, cmd, n, ear, cur_addr);
#line 2037 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_complete_collecting(void * s, uint32_t cmd, int n, uint8_t ear, uint32_t cur_addr)
{
    if (true) {
        _nocheck__trace_m25p80_complete_collecting(s, cmd, n, ear, cur_addr);
    }
}

#define TRACE_M25P80_POPULATED_JEDEC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_POPULATED_JEDEC) || \
    false)

static inline void _nocheck__trace_m25p80_populated_jedec(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_POPULATED_JEDEC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_populated_jedec " "[%p] populated jedec code" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2064 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 76 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_populated_jedec " "[%p] populated jedec code" "\n", s);
#line 2068 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_populated_jedec(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_populated_jedec(s);
    }
}

#define TRACE_M25P80_CHIP_ERASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_CHIP_ERASE) || \
    false)

static inline void _nocheck__trace_m25p80_chip_erase(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_CHIP_ERASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_chip_erase " "[%p] chip erase" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2095 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 77 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_chip_erase " "[%p] chip erase" "\n", s);
#line 2099 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_chip_erase(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_chip_erase(s);
    }
}

#define TRACE_M25P80_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_SELECT) || \
    false)

static inline void _nocheck__trace_m25p80_select(void * s, const char * what)
{
    if (trace_event_get_state(TRACE_M25P80_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_select " "[%p] %sselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, what);
#line 2126 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 78 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_select " "[%p] %sselect" "\n", s, what);
#line 2130 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_select(void * s, const char * what)
{
    if (true) {
        _nocheck__trace_m25p80_select(s, what);
    }
}

#define TRACE_M25P80_PAGE_PROGRAM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_PAGE_PROGRAM) || \
    false)

static inline void _nocheck__trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (trace_event_get_state(TRACE_M25P80_PAGE_PROGRAM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, tx);
#line 2157 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 79 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_page_program " "[%p] page program cur_addr=0x%"PRIx32" data=0x%"PRIx8 "\n", s, addr, tx);
#line 2161 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_page_program(void * s, uint32_t addr, uint8_t tx)
{
    if (true) {
        _nocheck__trace_m25p80_page_program(s, addr, tx);
    }
}

#define TRACE_M25P80_TRANSFER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_TRANSFER) || \
    false)

static inline void _nocheck__trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (trace_event_get_state(TRACE_M25P80_TRANSFER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, state, len, needed, pos, cur_addr, t);
#line 2188 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 80 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_transfer " "[%p] Transfer state 0x%"PRIx8" len 0x%"PRIx32" needed 0x%"PRIx8" pos 0x%"PRIx32" addr 0x%"PRIx32" tx 0x%"PRIx8 "\n", s, state, len, needed, pos, cur_addr, t);
#line 2192 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_transfer(void * s, uint8_t state, uint32_t len, uint8_t needed, uint32_t pos, uint32_t cur_addr, uint8_t t)
{
    if (true) {
        _nocheck__trace_m25p80_transfer(s, state, len, needed, pos, cur_addr, t);
    }
}

#define TRACE_M25P80_READ_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_BYTE) || \
    false)

static inline void _nocheck__trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 2219 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 81 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_read_byte " "[%p] Read byte 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 2223 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_byte(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_byte(s, addr, v);
    }
}

#define TRACE_M25P80_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_DATA) || \
    false)

static inline void _nocheck__trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, pos, v);
#line 2250 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 82 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_read_data " "[%p] Read data 0x%"PRIx32"=0x%"PRIx8 "\n", s, pos, v);
#line 2254 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_data(void * s, uint32_t pos, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_data(s, pos, v);
    }
}

#define TRACE_M25P80_READ_SFDP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_READ_SFDP) || \
    false)

static inline void _nocheck__trace_m25p80_read_sfdp(void * s, uint32_t addr, uint8_t v)
{
    if (trace_event_get_state(TRACE_M25P80_READ_SFDP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_read_sfdp " "[%p] Read SFDP 0x%"PRIx32"=0x%"PRIx8 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s, addr, v);
#line 2281 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 83 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_read_sfdp " "[%p] Read SFDP 0x%"PRIx32"=0x%"PRIx8 "\n", s, addr, v);
#line 2285 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_read_sfdp(void * s, uint32_t addr, uint8_t v)
{
    if (true) {
        _nocheck__trace_m25p80_read_sfdp(s, addr, v);
    }
}

#define TRACE_M25P80_BINDING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING) || \
    false)

static inline void _nocheck__trace_m25p80_binding(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding " "[%p] Binding to IF_MTD drive" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2312 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 84 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_binding " "[%p] Binding to IF_MTD drive" "\n", s);
#line 2316 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding(s);
    }
}

#define TRACE_M25P80_BINDING_NO_BDRV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_M25P80_BINDING_NO_BDRV) || \
    false)

static inline void _nocheck__trace_m25p80_binding_no_bdrv(void * s)
{
    if (trace_event_get_state(TRACE_M25P80_BINDING_NO_BDRV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("%d@%zu.%06zu:m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s);
#line 2343 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        } else {
#line 85 "C:/Users/seski/source/repos/xemu-uwp/hw/block/trace-events"
            qemu_log("m25p80_binding_no_bdrv " "[%p] No BDRV - binding to RAM" "\n", s);
#line 2347 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_block.h"
        }
    }
}

static inline void trace_m25p80_binding_no_bdrv(void * s)
{
    if (true) {
        _nocheck__trace_m25p80_binding_no_bdrv(s);
    }
}
#endif /* TRACE_HW_BLOCK_GENERATED_TRACERS_H */
