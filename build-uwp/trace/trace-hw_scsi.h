/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_HW_SCSI_GENERATED_TRACERS_H
#define TRACE_HW_SCSI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_SCSI_REQ_ALLOC_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CANCEL_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DATA_CANCELED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_DEQUEUE_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CONTINUE_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_CONTINUE_CANCELED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSED_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSED_LBA_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_PARSE_BAD_EVENT;
extern TraceEvent _TRACE_SCSI_REQ_BUILD_SENSE_EVENT;
extern TraceEvent _TRACE_SCSI_DEVICE_SET_UA_EVENT;
extern TraceEvent _TRACE_SCSI_REPORT_LUNS_EVENT;
extern TraceEvent _TRACE_SCSI_INQUIRY_EVENT;
extern TraceEvent _TRACE_SCSI_TEST_UNIT_READY_EVENT;
extern TraceEvent _TRACE_SCSI_REQUEST_SENSE_EVENT;
extern TraceEvent _TRACE_MPTSAS_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_MPTSAS_DIAG_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_DIAG_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_IRQ_INTX_EVENT;
extern TraceEvent _TRACE_MPTSAS_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_UNHANDLED_READ_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_MMIO_WRITE_EVENT;
extern TraceEvent _TRACE_MPTSAS_PROCESS_MESSAGE_EVENT;
extern TraceEvent _TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_EVENT;
extern TraceEvent _TRACE_MPTSAS_RESET_EVENT;
extern TraceEvent _TRACE_MPTSAS_SCSI_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MPTSAS_SGL_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MPTSAS_UNHANDLED_CMD_EVENT;
extern TraceEvent _TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_EVENT;
extern TraceEvent _TRACE_MPTSAS_CONFIG_SAS_DEVICE_EVENT;
extern TraceEvent _TRACE_MPTSAS_CONFIG_SAS_PHY_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_FIRMWARE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_QUEUE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MAP_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MAPPED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INITQ_MISMATCH_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_MAPPED_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_NEW_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_BUSY_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_ENQUEUE_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_UPDATE_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_MAP_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_COMPLETE_NOIRQ_EVENT;
extern TraceEvent _TRACE_MEGASAS_QF_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_FRAME_BUSY_EVENT;
extern TraceEvent _TRACE_MEGASAS_UNHANDLED_FRAME_CMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_SCSI_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_READ_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_WRITE_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_READ_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_READ_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_WRITE_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_NODATA_EVENT;
extern TraceEvent _TRACE_MEGASAS_SCSI_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_IO_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_READ_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_WRITE_START_EVENT;
extern TraceEvent _TRACE_MEGASAS_IO_COMPLETE_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_SGL_INVALID_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_OVERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_IOVEC_UNDERFLOW_EVENT;
extern TraceEvent _TRACE_MEGASAS_HANDLE_DCMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_FINISH_DCMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_FINISH_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INTERNAL_INVALID_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_UNHANDLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_ZERO_SGE_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INVALID_SGE_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_ENTER_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_DUMMY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_SET_FW_TIME_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_GET_LIST_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_GET_LIST_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_GET_INFO_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_LD_LIST_QUERY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_GET_INFO_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_PD_LIST_QUERY_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_RESET_LD_EVENT;
extern TraceEvent _TRACE_MEGASAS_DCMD_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_FRAME_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_NO_CMD_EVENT;
extern TraceEvent _TRACE_MEGASAS_ABORT_INVALID_CONTEXT_EVENT;
extern TraceEvent _TRACE_MEGASAS_RESET_EVENT;
extern TraceEvent _TRACE_MEGASAS_INIT_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSIX_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSI_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_IRQ_LOWER_EVENT;
extern TraceEvent _TRACE_MEGASAS_IRQ_RAISE_EVENT;
extern TraceEvent _TRACE_MEGASAS_INTR_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_INTR_DISABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSIX_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MSI_ENABLED_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_READL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_INVALID_READL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_WRITEL_EVENT;
extern TraceEvent _TRACE_MEGASAS_MMIO_INVALID_WRITEL_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_INIT_DATA_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_INIT_MSG_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_FLUSH_CMP_EVENT;
extern TraceEvent _TRACE_PVSCSI_RING_FLUSH_MSG_EVENT;
extern TraceEvent _TRACE_PVSCSI_UPDATE_IRQ_LEVEL_EVENT;
extern TraceEvent _TRACE_PVSCSI_UPDATE_IRQ_MSI_EVENT;
extern TraceEvent _TRACE_PVSCSI_CMP_RING_PUT_EVENT;
extern TraceEvent _TRACE_PVSCSI_MSG_RING_PUT_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMPLETE_REQUEST_EVENT;
extern TraceEvent _TRACE_PVSCSI_GET_SG_LIST_EVENT;
extern TraceEvent _TRACE_PVSCSI_GET_NEXT_SG_ELEM_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_EVENT;
extern TraceEvent _TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_EVENT;
extern TraceEvent _TRACE_PVSCSI_CONVERT_SGLIST_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_EVENT;
extern TraceEvent _TRACE_PVSCSI_PROCESS_IO_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_NOIMPL_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_RESET_DEV_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_ARRIVED_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_ABORT_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_WRITE_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_WRITE_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_READ_EVENT;
extern TraceEvent _TRACE_PVSCSI_IO_READ_UNKNOWN_EVENT;
extern TraceEvent _TRACE_PVSCSI_INIT_MSI_FAIL_EVENT;
extern TraceEvent _TRACE_PVSCSI_STATE_EVENT;
extern TraceEvent _TRACE_PVSCSI_TX_RINGS_PPN_EVENT;
extern TraceEvent _TRACE_PVSCSI_TX_RINGS_NUM_PAGES_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_FIFO_OVERRUN_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_UNHANDLED_COMMAND_EVENT;
extern TraceEvent _TRACE_ESP_ERROR_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_RAISE_IRQ_EVENT;
extern TraceEvent _TRACE_ESP_LOWER_IRQ_EVENT;
extern TraceEvent _TRACE_ESP_RAISE_DRQ_EVENT;
extern TraceEvent _TRACE_ESP_LOWER_DRQ_EVENT;
extern TraceEvent _TRACE_ESP_DMA_ENABLE_EVENT;
extern TraceEvent _TRACE_ESP_DMA_DISABLE_EVENT;
extern TraceEvent _TRACE_ESP_PDMA_READ_EVENT;
extern TraceEvent _TRACE_ESP_PDMA_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_GET_CMD_EVENT;
extern TraceEvent _TRACE_ESP_DO_COMMAND_PHASE_EVENT;
extern TraceEvent _TRACE_ESP_DO_IDENTIFY_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_SATN_STOP_EVENT;
extern TraceEvent _TRACE_ESP_WRITE_RESPONSE_EVENT;
extern TraceEvent _TRACE_ESP_DO_DMA_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_DEFERRED_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_EVENT;
extern TraceEvent _TRACE_ESP_COMMAND_COMPLETE_FAIL_EVENT;
extern TraceEvent _TRACE_ESP_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_TI_EVENT;
extern TraceEvent _TRACE_ESP_HANDLE_TI_CMD_EVENT;
extern TraceEvent _TRACE_ESP_MEM_READB_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_NOP_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_FLUSH_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_RESET_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_ICCS_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_MSGACC_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_PAD_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_RSTATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SEL_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SELATN_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_SELATNS_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_ENSEL_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_DISSEL_EVENT;
extern TraceEvent _TRACE_ESP_MEM_WRITEB_CMD_TI_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_WRITE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_IDLE_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_BLAST_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_ABORT_EVENT;
extern TraceEvent _TRACE_ESP_PCI_DMA_START_EVENT;
extern TraceEvent _TRACE_ESP_PCI_SBAC_READ_EVENT;
extern TraceEvent _TRACE_ESP_PCI_SBAC_WRITE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SEND_RSP_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_SAVE_REQUEST_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_LOAD_REQUEST_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_PROCESS_LOGIN_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_QUEUE_CMD_EVENT;
extern TraceEvent _TRACE_SPAPR_VSCSI_DO_CRQ_EVENT;
extern TraceEvent _TRACE_LSI_RESET_EVENT;
extern TraceEvent _TRACE_LSI_UPDATE_IRQ_EVENT;
extern TraceEvent _TRACE_LSI_UPDATE_IRQ_DISCONNECTED_EVENT;
extern TraceEvent _TRACE_LSI_SCRIPT_SCSI_INTERRUPT_EVENT;
extern TraceEvent _TRACE_LSI_SCRIPT_DMA_INTERRUPT_EVENT;
extern TraceEvent _TRACE_LSI_BAD_PHASE_JUMP_EVENT;
extern TraceEvent _TRACE_LSI_BAD_PHASE_INTERRUPT_EVENT;
extern TraceEvent _TRACE_LSI_BAD_SELECTION_EVENT;
extern TraceEvent _TRACE_LSI_DO_DMA_UNAVAILABLE_EVENT;
extern TraceEvent _TRACE_LSI_DO_DMA_EVENT;
extern TraceEvent _TRACE_LSI_QUEUE_COMMAND_EVENT;
extern TraceEvent _TRACE_LSI_ADD_MSG_BYTE_ERROR_EVENT;
extern TraceEvent _TRACE_LSI_ADD_MSG_BYTE_EVENT;
extern TraceEvent _TRACE_LSI_RESELECT_EVENT;
extern TraceEvent _TRACE_LSI_QUEUE_REQ_ERROR_EVENT;
extern TraceEvent _TRACE_LSI_QUEUE_REQ_EVENT;
extern TraceEvent _TRACE_LSI_COMMAND_COMPLETE_EVENT;
extern TraceEvent _TRACE_LSI_TRANSFER_DATA_EVENT;
extern TraceEvent _TRACE_LSI_DO_COMMAND_EVENT;
extern TraceEvent _TRACE_LSI_DO_STATUS_EVENT;
extern TraceEvent _TRACE_LSI_DO_STATUS_ERROR_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGIN_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_DISCONNECT_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_NOOP_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_EXTENDED_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_IGNORED_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_ABORT_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_CLEARQUEUE_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_BUSDEVICERESET_EVENT;
extern TraceEvent _TRACE_LSI_DO_MSGOUT_SELECT_EVENT;
extern TraceEvent _TRACE_LSI_MEMCPY_EVENT;
extern TraceEvent _TRACE_LSI_WAIT_RESELECT_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_SET_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_NOP_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_CALL_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_MM_STORE_EVENT;
extern TraceEvent _TRACE_LSI_EXECUTE_SCRIPT_STOP_EVENT;
extern TraceEvent _TRACE_LSI_AWOKEN_EVENT;
extern TraceEvent _TRACE_LSI_REG_READ_EVENT;
extern TraceEvent _TRACE_LSI_REG_WRITE_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_CMD_REQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_CMD_RESP_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_TMF_REQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_TMF_RESP_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_AN_REQ_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_AN_RESP_EVENT;
extern TraceEvent _TRACE_VIRTIO_SCSI_EVENT_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_CHECK_CONDITION_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_READ_COMPLETE_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_READ_DATA_COUNT_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_READ_DATA_INVALID_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_WRITE_DATA_INVALID_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_MODE_SENSE_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_READ_TOC_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_READ_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_DMA_COMMAND_READ_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_DMA_COMMAND_WRITE_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_NEW_REQUEST_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_AIO_SGIO_COMMAND_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED_EVENT;
extern TraceEvent _TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_READ_COMPLETE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_READ_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_WRITE_COMPLETE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_WRITE_DATA_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_SEND_COMMAND_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_REALIZE_TYPE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND_EVENT;
extern TraceEvent _TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE_EVENT;
extern uint16_t _TRACE_SCSI_REQ_ALLOC_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CANCEL_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DATA_CANCELED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_DEQUEUE_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CONTINUE_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_CONTINUE_CANCELED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSED_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSED_LBA_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_PARSE_BAD_DSTATE;
extern uint16_t _TRACE_SCSI_REQ_BUILD_SENSE_DSTATE;
extern uint16_t _TRACE_SCSI_DEVICE_SET_UA_DSTATE;
extern uint16_t _TRACE_SCSI_REPORT_LUNS_DSTATE;
extern uint16_t _TRACE_SCSI_INQUIRY_DSTATE;
extern uint16_t _TRACE_SCSI_TEST_UNIT_READY_DSTATE;
extern uint16_t _TRACE_SCSI_REQUEST_SENSE_DSTATE;
extern uint16_t _TRACE_MPTSAS_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_MPTSAS_DIAG_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_DIAG_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_IRQ_INTX_DSTATE;
extern uint16_t _TRACE_MPTSAS_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_UNHANDLED_READ_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_MMIO_WRITE_DSTATE;
extern uint16_t _TRACE_MPTSAS_PROCESS_MESSAGE_DSTATE;
extern uint16_t _TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_DSTATE;
extern uint16_t _TRACE_MPTSAS_RESET_DSTATE;
extern uint16_t _TRACE_MPTSAS_SCSI_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MPTSAS_SGL_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MPTSAS_UNHANDLED_CMD_DSTATE;
extern uint16_t _TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_DSTATE;
extern uint16_t _TRACE_MPTSAS_CONFIG_SAS_DEVICE_DSTATE;
extern uint16_t _TRACE_MPTSAS_CONFIG_SAS_PHY_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_FIRMWARE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_QUEUE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MAP_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MAPPED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INITQ_MISMATCH_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_MAPPED_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_NEW_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_BUSY_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_ENQUEUE_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_UPDATE_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_MAP_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_COMPLETE_NOIRQ_DSTATE;
extern uint16_t _TRACE_MEGASAS_QF_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_FRAME_BUSY_DSTATE;
extern uint16_t _TRACE_MEGASAS_UNHANDLED_FRAME_CMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_SCSI_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_READ_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_WRITE_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_READ_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_READ_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_WRITE_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_NODATA_DSTATE;
extern uint16_t _TRACE_MEGASAS_SCSI_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_IO_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_READ_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_WRITE_START_DSTATE;
extern uint16_t _TRACE_MEGASAS_IO_COMPLETE_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_SGL_INVALID_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_OVERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_IOVEC_UNDERFLOW_DSTATE;
extern uint16_t _TRACE_MEGASAS_HANDLE_DCMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_FINISH_DCMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_FINISH_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INTERNAL_INVALID_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_UNHANDLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_ZERO_SGE_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INVALID_SGE_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_ENTER_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_DUMMY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_SET_FW_TIME_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_GET_LIST_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_GET_LIST_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_GET_INFO_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_LD_LIST_QUERY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_GET_INFO_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_PD_LIST_QUERY_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_RESET_LD_DSTATE;
extern uint16_t _TRACE_MEGASAS_DCMD_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_FRAME_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_NO_CMD_DSTATE;
extern uint16_t _TRACE_MEGASAS_ABORT_INVALID_CONTEXT_DSTATE;
extern uint16_t _TRACE_MEGASAS_RESET_DSTATE;
extern uint16_t _TRACE_MEGASAS_INIT_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSIX_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSI_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_IRQ_LOWER_DSTATE;
extern uint16_t _TRACE_MEGASAS_IRQ_RAISE_DSTATE;
extern uint16_t _TRACE_MEGASAS_INTR_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_INTR_DISABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSIX_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MSI_ENABLED_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_READL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_INVALID_READL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_WRITEL_DSTATE;
extern uint16_t _TRACE_MEGASAS_MMIO_INVALID_WRITEL_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_INIT_DATA_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_INIT_MSG_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_FLUSH_CMP_DSTATE;
extern uint16_t _TRACE_PVSCSI_RING_FLUSH_MSG_DSTATE;
extern uint16_t _TRACE_PVSCSI_UPDATE_IRQ_LEVEL_DSTATE;
extern uint16_t _TRACE_PVSCSI_UPDATE_IRQ_MSI_DSTATE;
extern uint16_t _TRACE_PVSCSI_CMP_RING_PUT_DSTATE;
extern uint16_t _TRACE_PVSCSI_MSG_RING_PUT_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMPLETE_REQUEST_DSTATE;
extern uint16_t _TRACE_PVSCSI_GET_SG_LIST_DSTATE;
extern uint16_t _TRACE_PVSCSI_GET_NEXT_SG_ELEM_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_DSTATE;
extern uint16_t _TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_DSTATE;
extern uint16_t _TRACE_PVSCSI_CONVERT_SGLIST_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_DSTATE;
extern uint16_t _TRACE_PVSCSI_PROCESS_IO_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_NOIMPL_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_RESET_DEV_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_ARRIVED_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_ABORT_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_WRITE_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_WRITE_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_READ_DSTATE;
extern uint16_t _TRACE_PVSCSI_IO_READ_UNKNOWN_DSTATE;
extern uint16_t _TRACE_PVSCSI_INIT_MSI_FAIL_DSTATE;
extern uint16_t _TRACE_PVSCSI_STATE_DSTATE;
extern uint16_t _TRACE_PVSCSI_TX_RINGS_PPN_DSTATE;
extern uint16_t _TRACE_PVSCSI_TX_RINGS_NUM_PAGES_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_FIFO_OVERRUN_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_UNHANDLED_COMMAND_DSTATE;
extern uint16_t _TRACE_ESP_ERROR_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_RAISE_IRQ_DSTATE;
extern uint16_t _TRACE_ESP_LOWER_IRQ_DSTATE;
extern uint16_t _TRACE_ESP_RAISE_DRQ_DSTATE;
extern uint16_t _TRACE_ESP_LOWER_DRQ_DSTATE;
extern uint16_t _TRACE_ESP_DMA_ENABLE_DSTATE;
extern uint16_t _TRACE_ESP_DMA_DISABLE_DSTATE;
extern uint16_t _TRACE_ESP_PDMA_READ_DSTATE;
extern uint16_t _TRACE_ESP_PDMA_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_GET_CMD_DSTATE;
extern uint16_t _TRACE_ESP_DO_COMMAND_PHASE_DSTATE;
extern uint16_t _TRACE_ESP_DO_IDENTIFY_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_SATN_STOP_DSTATE;
extern uint16_t _TRACE_ESP_WRITE_RESPONSE_DSTATE;
extern uint16_t _TRACE_ESP_DO_DMA_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_DEFERRED_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_DSTATE;
extern uint16_t _TRACE_ESP_COMMAND_COMPLETE_FAIL_DSTATE;
extern uint16_t _TRACE_ESP_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_TI_DSTATE;
extern uint16_t _TRACE_ESP_HANDLE_TI_CMD_DSTATE;
extern uint16_t _TRACE_ESP_MEM_READB_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_NOP_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_FLUSH_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_RESET_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_ICCS_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_MSGACC_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_PAD_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_RSTATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SEL_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SELATN_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_SELATNS_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_ENSEL_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_DISSEL_DSTATE;
extern uint16_t _TRACE_ESP_MEM_WRITEB_CMD_TI_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_WRITE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_IDLE_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_BLAST_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_ABORT_DSTATE;
extern uint16_t _TRACE_ESP_PCI_DMA_START_DSTATE;
extern uint16_t _TRACE_ESP_PCI_SBAC_READ_DSTATE;
extern uint16_t _TRACE_ESP_PCI_SBAC_WRITE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SEND_RSP_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_SAVE_REQUEST_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_LOAD_REQUEST_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_PROCESS_LOGIN_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_QUEUE_CMD_DSTATE;
extern uint16_t _TRACE_SPAPR_VSCSI_DO_CRQ_DSTATE;
extern uint16_t _TRACE_LSI_RESET_DSTATE;
extern uint16_t _TRACE_LSI_UPDATE_IRQ_DSTATE;
extern uint16_t _TRACE_LSI_UPDATE_IRQ_DISCONNECTED_DSTATE;
extern uint16_t _TRACE_LSI_SCRIPT_SCSI_INTERRUPT_DSTATE;
extern uint16_t _TRACE_LSI_SCRIPT_DMA_INTERRUPT_DSTATE;
extern uint16_t _TRACE_LSI_BAD_PHASE_JUMP_DSTATE;
extern uint16_t _TRACE_LSI_BAD_PHASE_INTERRUPT_DSTATE;
extern uint16_t _TRACE_LSI_BAD_SELECTION_DSTATE;
extern uint16_t _TRACE_LSI_DO_DMA_UNAVAILABLE_DSTATE;
extern uint16_t _TRACE_LSI_DO_DMA_DSTATE;
extern uint16_t _TRACE_LSI_QUEUE_COMMAND_DSTATE;
extern uint16_t _TRACE_LSI_ADD_MSG_BYTE_ERROR_DSTATE;
extern uint16_t _TRACE_LSI_ADD_MSG_BYTE_DSTATE;
extern uint16_t _TRACE_LSI_RESELECT_DSTATE;
extern uint16_t _TRACE_LSI_QUEUE_REQ_ERROR_DSTATE;
extern uint16_t _TRACE_LSI_QUEUE_REQ_DSTATE;
extern uint16_t _TRACE_LSI_COMMAND_COMPLETE_DSTATE;
extern uint16_t _TRACE_LSI_TRANSFER_DATA_DSTATE;
extern uint16_t _TRACE_LSI_DO_COMMAND_DSTATE;
extern uint16_t _TRACE_LSI_DO_STATUS_DSTATE;
extern uint16_t _TRACE_LSI_DO_STATUS_ERROR_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGIN_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_DISCONNECT_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_NOOP_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_EXTENDED_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_IGNORED_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_ABORT_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_CLEARQUEUE_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_BUSDEVICERESET_DSTATE;
extern uint16_t _TRACE_LSI_DO_MSGOUT_SELECT_DSTATE;
extern uint16_t _TRACE_LSI_MEMCPY_DSTATE;
extern uint16_t _TRACE_LSI_WAIT_RESELECT_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_SET_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_NOP_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_CALL_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_MM_STORE_DSTATE;
extern uint16_t _TRACE_LSI_EXECUTE_SCRIPT_STOP_DSTATE;
extern uint16_t _TRACE_LSI_AWOKEN_DSTATE;
extern uint16_t _TRACE_LSI_REG_READ_DSTATE;
extern uint16_t _TRACE_LSI_REG_WRITE_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_CMD_REQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_CMD_RESP_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_TMF_REQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_TMF_RESP_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_AN_REQ_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_AN_RESP_DSTATE;
extern uint16_t _TRACE_VIRTIO_SCSI_EVENT_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_CHECK_CONDITION_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_READ_COMPLETE_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_READ_DATA_COUNT_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_READ_DATA_INVALID_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_WRITE_DATA_INVALID_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_MODE_SENSE_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_READ_TOC_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_READ_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_DMA_COMMAND_READ_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_DMA_COMMAND_WRITE_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_NEW_REQUEST_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_AIO_SGIO_COMMAND_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED_DSTATE;
extern uint16_t _TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_READ_COMPLETE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_READ_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_WRITE_COMPLETE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_WRITE_DATA_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_SEND_COMMAND_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_REALIZE_TYPE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND_DSTATE;
extern uint16_t _TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE_DSTATE;
#define TRACE_SCSI_REQ_ALLOC_ENABLED 1
#define TRACE_SCSI_REQ_CANCEL_ENABLED 1
#define TRACE_SCSI_REQ_DATA_ENABLED 1
#define TRACE_SCSI_REQ_DATA_CANCELED_ENABLED 1
#define TRACE_SCSI_REQ_DEQUEUE_ENABLED 1
#define TRACE_SCSI_REQ_CONTINUE_ENABLED 1
#define TRACE_SCSI_REQ_CONTINUE_CANCELED_ENABLED 1
#define TRACE_SCSI_REQ_PARSED_ENABLED 1
#define TRACE_SCSI_REQ_PARSED_LBA_ENABLED 1
#define TRACE_SCSI_REQ_PARSE_BAD_ENABLED 1
#define TRACE_SCSI_REQ_BUILD_SENSE_ENABLED 1
#define TRACE_SCSI_DEVICE_SET_UA_ENABLED 1
#define TRACE_SCSI_REPORT_LUNS_ENABLED 1
#define TRACE_SCSI_INQUIRY_ENABLED 1
#define TRACE_SCSI_TEST_UNIT_READY_ENABLED 1
#define TRACE_SCSI_REQUEST_SENSE_ENABLED 1
#define TRACE_MPTSAS_COMMAND_COMPLETE_ENABLED 1
#define TRACE_MPTSAS_DIAG_READ_ENABLED 1
#define TRACE_MPTSAS_DIAG_WRITE_ENABLED 1
#define TRACE_MPTSAS_IRQ_INTX_ENABLED 1
#define TRACE_MPTSAS_IRQ_MSI_ENABLED 1
#define TRACE_MPTSAS_MMIO_READ_ENABLED 1
#define TRACE_MPTSAS_MMIO_UNHANDLED_READ_ENABLED 1
#define TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_ENABLED 1
#define TRACE_MPTSAS_MMIO_WRITE_ENABLED 1
#define TRACE_MPTSAS_PROCESS_MESSAGE_ENABLED 1
#define TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_ENABLED 1
#define TRACE_MPTSAS_RESET_ENABLED 1
#define TRACE_MPTSAS_SCSI_OVERFLOW_ENABLED 1
#define TRACE_MPTSAS_SGL_OVERFLOW_ENABLED 1
#define TRACE_MPTSAS_UNHANDLED_CMD_ENABLED 1
#define TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_ENABLED 1
#define TRACE_MPTSAS_CONFIG_SAS_DEVICE_ENABLED 1
#define TRACE_MPTSAS_CONFIG_SAS_PHY_ENABLED 1
#define TRACE_MEGASAS_INIT_FIRMWARE_ENABLED 1
#define TRACE_MEGASAS_INIT_QUEUE_ENABLED 1
#define TRACE_MEGASAS_INITQ_MAP_FAILED_ENABLED 1
#define TRACE_MEGASAS_INITQ_MAPPED_ENABLED 1
#define TRACE_MEGASAS_INITQ_MISMATCH_ENABLED 1
#define TRACE_MEGASAS_QF_MAPPED_ENABLED 1
#define TRACE_MEGASAS_QF_NEW_ENABLED 1
#define TRACE_MEGASAS_QF_BUSY_ENABLED 1
#define TRACE_MEGASAS_QF_ENQUEUE_ENABLED 1
#define TRACE_MEGASAS_QF_UPDATE_ENABLED 1
#define TRACE_MEGASAS_QF_MAP_FAILED_ENABLED 1
#define TRACE_MEGASAS_QF_COMPLETE_NOIRQ_ENABLED 1
#define TRACE_MEGASAS_QF_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_FRAME_BUSY_ENABLED 1
#define TRACE_MEGASAS_UNHANDLED_FRAME_CMD_ENABLED 1
#define TRACE_MEGASAS_HANDLE_SCSI_ENABLED 1
#define TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_ENABLED 1
#define TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_ENABLED 1
#define TRACE_MEGASAS_IOV_READ_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_WRITE_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_READ_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_ENABLED 1
#define TRACE_MEGASAS_SCSI_READ_START_ENABLED 1
#define TRACE_MEGASAS_SCSI_WRITE_START_ENABLED 1
#define TRACE_MEGASAS_SCSI_NODATA_ENABLED 1
#define TRACE_MEGASAS_SCSI_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_COMMAND_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_HANDLE_IO_ENABLED 1
#define TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_ENABLED 1
#define TRACE_MEGASAS_IO_READ_START_ENABLED 1
#define TRACE_MEGASAS_IO_WRITE_START_ENABLED 1
#define TRACE_MEGASAS_IO_COMPLETE_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_SGL_INVALID_ENABLED 1
#define TRACE_MEGASAS_IOVEC_OVERFLOW_ENABLED 1
#define TRACE_MEGASAS_IOVEC_UNDERFLOW_ENABLED 1
#define TRACE_MEGASAS_HANDLE_DCMD_ENABLED 1
#define TRACE_MEGASAS_FINISH_DCMD_ENABLED 1
#define TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_FINISH_ENABLED 1
#define TRACE_MEGASAS_DCMD_INTERNAL_INVALID_ENABLED 1
#define TRACE_MEGASAS_DCMD_UNHANDLED_ENABLED 1
#define TRACE_MEGASAS_DCMD_ZERO_SGE_ENABLED 1
#define TRACE_MEGASAS_DCMD_INVALID_SGE_ENABLED 1
#define TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_ENABLED 1
#define TRACE_MEGASAS_DCMD_ENTER_ENABLED 1
#define TRACE_MEGASAS_DCMD_DUMMY_ENABLED 1
#define TRACE_MEGASAS_DCMD_SET_FW_TIME_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_GET_LIST_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_GET_LIST_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_GET_INFO_ENABLED 1
#define TRACE_MEGASAS_DCMD_LD_LIST_QUERY_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_GET_INFO_ENABLED 1
#define TRACE_MEGASAS_DCMD_PD_LIST_QUERY_ENABLED 1
#define TRACE_MEGASAS_DCMD_RESET_LD_ENABLED 1
#define TRACE_MEGASAS_DCMD_UNSUPPORTED_ENABLED 1
#define TRACE_MEGASAS_ABORT_FRAME_ENABLED 1
#define TRACE_MEGASAS_ABORT_NO_CMD_ENABLED 1
#define TRACE_MEGASAS_ABORT_INVALID_CONTEXT_ENABLED 1
#define TRACE_MEGASAS_RESET_ENABLED 1
#define TRACE_MEGASAS_INIT_ENABLED 1
#define TRACE_MEGASAS_MSIX_RAISE_ENABLED 1
#define TRACE_MEGASAS_MSI_RAISE_ENABLED 1
#define TRACE_MEGASAS_IRQ_LOWER_ENABLED 1
#define TRACE_MEGASAS_IRQ_RAISE_ENABLED 1
#define TRACE_MEGASAS_INTR_ENABLED_ENABLED 1
#define TRACE_MEGASAS_INTR_DISABLED_ENABLED 1
#define TRACE_MEGASAS_MSIX_ENABLED_ENABLED 1
#define TRACE_MEGASAS_MSI_ENABLED_ENABLED 1
#define TRACE_MEGASAS_MMIO_READL_ENABLED 1
#define TRACE_MEGASAS_MMIO_INVALID_READL_ENABLED 1
#define TRACE_MEGASAS_MMIO_WRITEL_ENABLED 1
#define TRACE_MEGASAS_MMIO_INVALID_WRITEL_ENABLED 1
#define TRACE_PVSCSI_RING_INIT_DATA_ENABLED 1
#define TRACE_PVSCSI_RING_INIT_MSG_ENABLED 1
#define TRACE_PVSCSI_RING_FLUSH_CMP_ENABLED 1
#define TRACE_PVSCSI_RING_FLUSH_MSG_ENABLED 1
#define TRACE_PVSCSI_UPDATE_IRQ_LEVEL_ENABLED 1
#define TRACE_PVSCSI_UPDATE_IRQ_MSI_ENABLED 1
#define TRACE_PVSCSI_CMP_RING_PUT_ENABLED 1
#define TRACE_PVSCSI_MSG_RING_PUT_ENABLED 1
#define TRACE_PVSCSI_COMPLETE_REQUEST_ENABLED 1
#define TRACE_PVSCSI_GET_SG_LIST_ENABLED 1
#define TRACE_PVSCSI_GET_NEXT_SG_ELEM_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_ENABLED 1
#define TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_ENABLED 1
#define TRACE_PVSCSI_CONVERT_SGLIST_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_ENABLED 1
#define TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_ENABLED 1
#define TRACE_PVSCSI_PROCESS_IO_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_NOIMPL_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_RESET_DEV_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_ARRIVED_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_ABORT_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_ENABLED 1
#define TRACE_PVSCSI_IO_WRITE_ENABLED 1
#define TRACE_PVSCSI_IO_WRITE_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_IO_READ_ENABLED 1
#define TRACE_PVSCSI_IO_READ_UNKNOWN_ENABLED 1
#define TRACE_PVSCSI_INIT_MSI_FAIL_ENABLED 1
#define TRACE_PVSCSI_STATE_ENABLED 1
#define TRACE_PVSCSI_TX_RINGS_PPN_ENABLED 1
#define TRACE_PVSCSI_TX_RINGS_NUM_PAGES_ENABLED 1
#define TRACE_ESP_ERROR_FIFO_OVERRUN_ENABLED 1
#define TRACE_ESP_ERROR_UNHANDLED_COMMAND_ENABLED 1
#define TRACE_ESP_ERROR_INVALID_WRITE_ENABLED 1
#define TRACE_ESP_RAISE_IRQ_ENABLED 1
#define TRACE_ESP_LOWER_IRQ_ENABLED 1
#define TRACE_ESP_RAISE_DRQ_ENABLED 1
#define TRACE_ESP_LOWER_DRQ_ENABLED 1
#define TRACE_ESP_DMA_ENABLE_ENABLED 1
#define TRACE_ESP_DMA_DISABLE_ENABLED 1
#define TRACE_ESP_PDMA_READ_ENABLED 1
#define TRACE_ESP_PDMA_WRITE_ENABLED 1
#define TRACE_ESP_GET_CMD_ENABLED 1
#define TRACE_ESP_DO_COMMAND_PHASE_ENABLED 1
#define TRACE_ESP_DO_IDENTIFY_ENABLED 1
#define TRACE_ESP_HANDLE_SATN_STOP_ENABLED 1
#define TRACE_ESP_WRITE_RESPONSE_ENABLED 1
#define TRACE_ESP_DO_DMA_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_DEFERRED_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_ENABLED 1
#define TRACE_ESP_COMMAND_COMPLETE_FAIL_ENABLED 1
#define TRACE_ESP_TRANSFER_DATA_ENABLED 1
#define TRACE_ESP_HANDLE_TI_ENABLED 1
#define TRACE_ESP_HANDLE_TI_CMD_ENABLED 1
#define TRACE_ESP_MEM_READB_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_NOP_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_FLUSH_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_RESET_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_ICCS_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_MSGACC_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_PAD_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_RSTATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SEL_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SELATN_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_SELATNS_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_ENSEL_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_DISSEL_ENABLED 1
#define TRACE_ESP_MEM_WRITEB_CMD_TI_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_READ_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_ENABLED 1
#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_ENABLED 1
#define TRACE_ESP_PCI_DMA_READ_ENABLED 1
#define TRACE_ESP_PCI_DMA_WRITE_ENABLED 1
#define TRACE_ESP_PCI_DMA_IDLE_ENABLED 1
#define TRACE_ESP_PCI_DMA_BLAST_ENABLED 1
#define TRACE_ESP_PCI_DMA_ABORT_ENABLED 1
#define TRACE_ESP_PCI_DMA_START_ENABLED 1
#define TRACE_ESP_PCI_SBAC_READ_ENABLED 1
#define TRACE_ESP_PCI_SBAC_WRITE_ENABLED 1
#define TRACE_SPAPR_VSCSI_SEND_RSP_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_ENABLED 1
#define TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_ENABLED 1
#define TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_TRANSFER_DATA_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_ENABLED 1
#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_ENABLED 1
#define TRACE_SPAPR_VSCSI_SAVE_REQUEST_ENABLED 1
#define TRACE_SPAPR_VSCSI_LOAD_REQUEST_ENABLED 1
#define TRACE_SPAPR_VSCSI_PROCESS_LOGIN_ENABLED 1
#define TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT_ENABLED 1
#define TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_ENABLED 1
#define TRACE_SPAPR_VSCSI_QUEUE_CMD_ENABLED 1
#define TRACE_SPAPR_VSCSI_DO_CRQ_ENABLED 1
#define TRACE_LSI_RESET_ENABLED 1
#define TRACE_LSI_UPDATE_IRQ_ENABLED 1
#define TRACE_LSI_UPDATE_IRQ_DISCONNECTED_ENABLED 1
#define TRACE_LSI_SCRIPT_SCSI_INTERRUPT_ENABLED 1
#define TRACE_LSI_SCRIPT_DMA_INTERRUPT_ENABLED 1
#define TRACE_LSI_BAD_PHASE_JUMP_ENABLED 1
#define TRACE_LSI_BAD_PHASE_INTERRUPT_ENABLED 1
#define TRACE_LSI_BAD_SELECTION_ENABLED 1
#define TRACE_LSI_DO_DMA_UNAVAILABLE_ENABLED 1
#define TRACE_LSI_DO_DMA_ENABLED 1
#define TRACE_LSI_QUEUE_COMMAND_ENABLED 1
#define TRACE_LSI_ADD_MSG_BYTE_ERROR_ENABLED 1
#define TRACE_LSI_ADD_MSG_BYTE_ENABLED 1
#define TRACE_LSI_RESELECT_ENABLED 1
#define TRACE_LSI_QUEUE_REQ_ERROR_ENABLED 1
#define TRACE_LSI_QUEUE_REQ_ENABLED 1
#define TRACE_LSI_COMMAND_COMPLETE_ENABLED 1
#define TRACE_LSI_TRANSFER_DATA_ENABLED 1
#define TRACE_LSI_DO_COMMAND_ENABLED 1
#define TRACE_LSI_DO_STATUS_ENABLED 1
#define TRACE_LSI_DO_STATUS_ERROR_ENABLED 1
#define TRACE_LSI_DO_MSGIN_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_DISCONNECT_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_NOOP_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_EXTENDED_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_IGNORED_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_ABORT_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_CLEARQUEUE_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_BUSDEVICERESET_ENABLED 1
#define TRACE_LSI_DO_MSGOUT_SELECT_ENABLED 1
#define TRACE_LSI_MEMCPY_ENABLED 1
#define TRACE_LSI_WAIT_RESELECT_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_SET_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_NOP_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_CALL_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_MM_STORE_ENABLED 1
#define TRACE_LSI_EXECUTE_SCRIPT_STOP_ENABLED 1
#define TRACE_LSI_AWOKEN_ENABLED 1
#define TRACE_LSI_REG_READ_ENABLED 1
#define TRACE_LSI_REG_WRITE_ENABLED 1
#define TRACE_VIRTIO_SCSI_CMD_REQ_ENABLED 1
#define TRACE_VIRTIO_SCSI_CMD_RESP_ENABLED 1
#define TRACE_VIRTIO_SCSI_TMF_REQ_ENABLED 1
#define TRACE_VIRTIO_SCSI_TMF_RESP_ENABLED 1
#define TRACE_VIRTIO_SCSI_AN_REQ_ENABLED 1
#define TRACE_VIRTIO_SCSI_AN_RESP_ENABLED 1
#define TRACE_VIRTIO_SCSI_EVENT_ENABLED 1
#define TRACE_SCSI_DISK_CHECK_CONDITION_ENABLED 1
#define TRACE_SCSI_DISK_READ_COMPLETE_ENABLED 1
#define TRACE_SCSI_DISK_READ_DATA_COUNT_ENABLED 1
#define TRACE_SCSI_DISK_READ_DATA_INVALID_ENABLED 1
#define TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO_ENABLED 1
#define TRACE_SCSI_DISK_WRITE_DATA_INVALID_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_MODE_SENSE_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_READ_TOC_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_READ_DATA_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_WRITE_DATA_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN_ENABLED 1
#define TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT_ENABLED 1
#define TRACE_SCSI_DISK_DMA_COMMAND_READ_ENABLED 1
#define TRACE_SCSI_DISK_DMA_COMMAND_WRITE_ENABLED 1
#define TRACE_SCSI_DISK_NEW_REQUEST_ENABLED 1
#define TRACE_SCSI_DISK_AIO_SGIO_COMMAND_ENABLED 1
#define TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED_ENABLED 1
#define TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE_ENABLED 1
#define TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO_ENABLED 1
#define TRACE_SCSI_GENERIC_READ_COMPLETE_ENABLED 1
#define TRACE_SCSI_GENERIC_READ_DATA_ENABLED 1
#define TRACE_SCSI_GENERIC_WRITE_COMPLETE_ENABLED 1
#define TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE_ENABLED 1
#define TRACE_SCSI_GENERIC_WRITE_DATA_ENABLED 1
#define TRACE_SCSI_GENERIC_SEND_COMMAND_ENABLED 1
#define TRACE_SCSI_GENERIC_REALIZE_TYPE_ENABLED 1
#define TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE_ENABLED 1
#define TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND_ENABLED 1
#define TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND_ENABLED 1
#define TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_SCSI_REQ_ALLOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_ALLOC) || \
    false)

static inline void _nocheck__trace_scsi_req_alloc(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_ALLOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_alloc " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1024 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 4 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_alloc " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1028 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_alloc(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_req_alloc(target, lun, tag);
    }
}

#define TRACE_SCSI_REQ_CANCEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_CANCEL) || \
    false)

static inline void _nocheck__trace_scsi_req_cancel(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_CANCEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_cancel " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1055 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 5 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_cancel " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1059 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_cancel(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_req_cancel(target, lun, tag);
    }
}

#define TRACE_SCSI_REQ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_DATA) || \
    false)

static inline void _nocheck__trace_scsi_req_data(int target, int lun, int tag, int len)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_data " "target %d lun %d tag %d len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, len);
#line 1086 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 6 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_data " "target %d lun %d tag %d len %d" "\n", target, lun, tag, len);
#line 1090 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_data(int target, int lun, int tag, int len)
{
    if (true) {
        _nocheck__trace_scsi_req_data(target, lun, tag, len);
    }
}

#define TRACE_SCSI_REQ_DATA_CANCELED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_DATA_CANCELED) || \
    false)

static inline void _nocheck__trace_scsi_req_data_canceled(int target, int lun, int tag, int len)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_DATA_CANCELED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_data_canceled " "target %d lun %d tag %d len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, len);
#line 1117 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 7 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_data_canceled " "target %d lun %d tag %d len %d" "\n", target, lun, tag, len);
#line 1121 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_data_canceled(int target, int lun, int tag, int len)
{
    if (true) {
        _nocheck__trace_scsi_req_data_canceled(target, lun, tag, len);
    }
}

#define TRACE_SCSI_REQ_DEQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_DEQUEUE) || \
    false)

static inline void _nocheck__trace_scsi_req_dequeue(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_DEQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_dequeue " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1148 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 8 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_dequeue " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1152 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_dequeue(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_req_dequeue(target, lun, tag);
    }
}

#define TRACE_SCSI_REQ_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_CONTINUE) || \
    false)

static inline void _nocheck__trace_scsi_req_continue(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_continue " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1179 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 9 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_continue " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1183 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_continue(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_req_continue(target, lun, tag);
    }
}

#define TRACE_SCSI_REQ_CONTINUE_CANCELED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_CONTINUE_CANCELED) || \
    false)

static inline void _nocheck__trace_scsi_req_continue_canceled(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_CONTINUE_CANCELED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_continue_canceled " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1210 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 10 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_continue_canceled " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1214 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_continue_canceled(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_req_continue_canceled(target, lun, tag);
    }
}

#define TRACE_SCSI_REQ_PARSED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_PARSED) || \
    false)

static inline void _nocheck__trace_scsi_req_parsed(int target, int lun, int tag, int cmd, int mode, int xfer)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_PARSED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_parsed " "target %d lun %d tag %d command %d dir %d length %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, cmd, mode, xfer);
#line 1241 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 11 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_parsed " "target %d lun %d tag %d command %d dir %d length %d" "\n", target, lun, tag, cmd, mode, xfer);
#line 1245 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_parsed(int target, int lun, int tag, int cmd, int mode, int xfer)
{
    if (true) {
        _nocheck__trace_scsi_req_parsed(target, lun, tag, cmd, mode, xfer);
    }
}

#define TRACE_SCSI_REQ_PARSED_LBA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_PARSED_LBA) || \
    false)

static inline void _nocheck__trace_scsi_req_parsed_lba(int target, int lun, int tag, int cmd, uint64_t lba)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_PARSED_LBA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_parsed_lba " "target %d lun %d tag %d command %d lba %"PRIu64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, cmd, lba);
#line 1272 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 12 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_parsed_lba " "target %d lun %d tag %d command %d lba %"PRIu64 "\n", target, lun, tag, cmd, lba);
#line 1276 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_parsed_lba(int target, int lun, int tag, int cmd, uint64_t lba)
{
    if (true) {
        _nocheck__trace_scsi_req_parsed_lba(target, lun, tag, cmd, lba);
    }
}

#define TRACE_SCSI_REQ_PARSE_BAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_PARSE_BAD) || \
    false)

static inline void _nocheck__trace_scsi_req_parse_bad(int target, int lun, int tag, int cmd)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_PARSE_BAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_parse_bad " "target %d lun %d tag %d command %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, cmd);
#line 1303 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 13 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_parse_bad " "target %d lun %d tag %d command %d" "\n", target, lun, tag, cmd);
#line 1307 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_parse_bad(int target, int lun, int tag, int cmd)
{
    if (true) {
        _nocheck__trace_scsi_req_parse_bad(target, lun, tag, cmd);
    }
}

#define TRACE_SCSI_REQ_BUILD_SENSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQ_BUILD_SENSE) || \
    false)

static inline void _nocheck__trace_scsi_req_build_sense(int target, int lun, int tag, int key, int asc, int ascq)
{
    if (trace_event_get_state(TRACE_SCSI_REQ_BUILD_SENSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_req_build_sense " "target %d lun %d tag %d key 0x%02x asc 0x%02x ascq 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, key, asc, ascq);
#line 1334 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 14 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_req_build_sense " "target %d lun %d tag %d key 0x%02x asc 0x%02x ascq 0x%02x" "\n", target, lun, tag, key, asc, ascq);
#line 1338 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_req_build_sense(int target, int lun, int tag, int key, int asc, int ascq)
{
    if (true) {
        _nocheck__trace_scsi_req_build_sense(target, lun, tag, key, asc, ascq);
    }
}

#define TRACE_SCSI_DEVICE_SET_UA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DEVICE_SET_UA) || \
    false)

static inline void _nocheck__trace_scsi_device_set_ua(int target, int lun, int key, int asc, int ascq)
{
    if (trace_event_get_state(TRACE_SCSI_DEVICE_SET_UA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_device_set_ua " "target %d lun %d key 0x%02x asc 0x%02x ascq 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, key, asc, ascq);
#line 1365 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 15 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_device_set_ua " "target %d lun %d key 0x%02x asc 0x%02x ascq 0x%02x" "\n", target, lun, key, asc, ascq);
#line 1369 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_device_set_ua(int target, int lun, int key, int asc, int ascq)
{
    if (true) {
        _nocheck__trace_scsi_device_set_ua(target, lun, key, asc, ascq);
    }
}

#define TRACE_SCSI_REPORT_LUNS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REPORT_LUNS) || \
    false)

static inline void _nocheck__trace_scsi_report_luns(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REPORT_LUNS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_report_luns " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1396 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 16 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_report_luns " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1400 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_report_luns(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_report_luns(target, lun, tag);
    }
}

#define TRACE_SCSI_INQUIRY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_INQUIRY) || \
    false)

static inline void _nocheck__trace_scsi_inquiry(int target, int lun, int tag, int cdb1, int cdb2)
{
    if (trace_event_get_state(TRACE_SCSI_INQUIRY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_inquiry " "target %d lun %d tag %d page 0x%02x/0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag, cdb1, cdb2);
#line 1427 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 17 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_inquiry " "target %d lun %d tag %d page 0x%02x/0x%02x" "\n", target, lun, tag, cdb1, cdb2);
#line 1431 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_inquiry(int target, int lun, int tag, int cdb1, int cdb2)
{
    if (true) {
        _nocheck__trace_scsi_inquiry(target, lun, tag, cdb1, cdb2);
    }
}

#define TRACE_SCSI_TEST_UNIT_READY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_TEST_UNIT_READY) || \
    false)

static inline void _nocheck__trace_scsi_test_unit_ready(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_TEST_UNIT_READY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_test_unit_ready " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1458 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 18 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_test_unit_ready " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1462 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_test_unit_ready(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_test_unit_ready(target, lun, tag);
    }
}

#define TRACE_SCSI_REQUEST_SENSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_REQUEST_SENSE) || \
    false)

static inline void _nocheck__trace_scsi_request_sense(int target, int lun, int tag)
{
    if (trace_event_get_state(TRACE_SCSI_REQUEST_SENSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_request_sense " "target %d lun %d tag %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , target, lun, tag);
#line 1489 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 19 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_request_sense " "target %d lun %d tag %d" "\n", target, lun, tag);
#line 1493 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_request_sense(int target, int lun, int tag)
{
    if (true) {
        _nocheck__trace_scsi_request_sense(target, lun, tag);
    }
}

#define TRACE_MPTSAS_COMMAND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_COMMAND_COMPLETE) || \
    false)

static inline void _nocheck__trace_mptsas_command_complete(void * dev, uint32_t ctx, uint32_t status, uint32_t resid)
{
    if (trace_event_get_state(TRACE_MPTSAS_COMMAND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_command_complete " "dev %p context 0x%08x status 0x%x resid %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ctx, status, resid);
#line 1520 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 22 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_command_complete " "dev %p context 0x%08x status 0x%x resid %d" "\n", dev, ctx, status, resid);
#line 1524 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_command_complete(void * dev, uint32_t ctx, uint32_t status, uint32_t resid)
{
    if (true) {
        _nocheck__trace_mptsas_command_complete(dev, ctx, status, resid);
    }
}

#define TRACE_MPTSAS_DIAG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_DIAG_READ) || \
    false)

static inline void _nocheck__trace_mptsas_diag_read(void * dev, uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MPTSAS_DIAG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_diag_read " "dev %p addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, val);
#line 1551 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 23 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_diag_read " "dev %p addr 0x%08x value 0x%08x" "\n", dev, addr, val);
#line 1555 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_diag_read(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_mptsas_diag_read(dev, addr, val);
    }
}

#define TRACE_MPTSAS_DIAG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_DIAG_WRITE) || \
    false)

static inline void _nocheck__trace_mptsas_diag_write(void * dev, uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MPTSAS_DIAG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_diag_write " "dev %p addr 0x%08x value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, val);
#line 1582 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 24 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_diag_write " "dev %p addr 0x%08x value 0x%08x" "\n", dev, addr, val);
#line 1586 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_diag_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_mptsas_diag_write(dev, addr, val);
    }
}

#define TRACE_MPTSAS_IRQ_INTX_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_IRQ_INTX) || \
    false)

static inline void _nocheck__trace_mptsas_irq_intx(void * dev, int level)
{
    if (trace_event_get_state(TRACE_MPTSAS_IRQ_INTX) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_irq_intx " "dev %p level %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, level);
#line 1613 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 25 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_irq_intx " "dev %p level %d" "\n", dev, level);
#line 1617 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_irq_intx(void * dev, int level)
{
    if (true) {
        _nocheck__trace_mptsas_irq_intx(dev, level);
    }
}

#define TRACE_MPTSAS_IRQ_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_IRQ_MSI) || \
    false)

static inline void _nocheck__trace_mptsas_irq_msi(void * dev)
{
    if (trace_event_get_state(TRACE_MPTSAS_IRQ_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_irq_msi " "dev %p " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 1644 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 26 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_irq_msi " "dev %p " "\n", dev);
#line 1648 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_irq_msi(void * dev)
{
    if (true) {
        _nocheck__trace_mptsas_irq_msi(dev);
    }
}

#define TRACE_MPTSAS_MMIO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_MMIO_READ) || \
    false)

static inline void _nocheck__trace_mptsas_mmio_read(void * dev, uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MPTSAS_MMIO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_mmio_read " "dev %p addr 0x%08x value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, val);
#line 1675 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 27 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_mmio_read " "dev %p addr 0x%08x value 0x%x" "\n", dev, addr, val);
#line 1679 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_mmio_read(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_mptsas_mmio_read(dev, addr, val);
    }
}

#define TRACE_MPTSAS_MMIO_UNHANDLED_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_MMIO_UNHANDLED_READ) || \
    false)

static inline void _nocheck__trace_mptsas_mmio_unhandled_read(void * dev, uint32_t addr)
{
    if (trace_event_get_state(TRACE_MPTSAS_MMIO_UNHANDLED_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_mmio_unhandled_read " "dev %p addr 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr);
#line 1706 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 28 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_mmio_unhandled_read " "dev %p addr 0x%08x" "\n", dev, addr);
#line 1710 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_mmio_unhandled_read(void * dev, uint32_t addr)
{
    if (true) {
        _nocheck__trace_mptsas_mmio_unhandled_read(dev, addr);
    }
}

#define TRACE_MPTSAS_MMIO_UNHANDLED_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_MMIO_UNHANDLED_WRITE) || \
    false)

static inline void _nocheck__trace_mptsas_mmio_unhandled_write(void * dev, uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MPTSAS_MMIO_UNHANDLED_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_mmio_unhandled_write " "dev %p addr 0x%08x value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, val);
#line 1737 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 29 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_mmio_unhandled_write " "dev %p addr 0x%08x value 0x%x" "\n", dev, addr, val);
#line 1741 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_mmio_unhandled_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_mptsas_mmio_unhandled_write(dev, addr, val);
    }
}

#define TRACE_MPTSAS_MMIO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_MMIO_WRITE) || \
    false)

static inline void _nocheck__trace_mptsas_mmio_write(void * dev, uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MPTSAS_MMIO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_mmio_write " "dev %p addr 0x%08x value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, addr, val);
#line 1768 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 30 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_mmio_write " "dev %p addr 0x%08x value 0x%x" "\n", dev, addr, val);
#line 1772 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_mmio_write(void * dev, uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_mptsas_mmio_write(dev, addr, val);
    }
}

#define TRACE_MPTSAS_PROCESS_MESSAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_PROCESS_MESSAGE) || \
    false)

static inline void _nocheck__trace_mptsas_process_message(void * dev, int msg, uint32_t ctx)
{
    if (trace_event_get_state(TRACE_MPTSAS_PROCESS_MESSAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 31 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_process_message " "dev %p cmd %d context 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, msg, ctx);
#line 1799 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 31 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_process_message " "dev %p cmd %d context 0x%08x" "\n", dev, msg, ctx);
#line 1803 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_process_message(void * dev, int msg, uint32_t ctx)
{
    if (true) {
        _nocheck__trace_mptsas_process_message(dev, msg, ctx);
    }
}

#define TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST) || \
    false)

static inline void _nocheck__trace_mptsas_process_scsi_io_request(void * dev, int bus, int target, int lun, uint64_t len)
{
    if (trace_event_get_state(TRACE_MPTSAS_PROCESS_SCSI_IO_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 32 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_process_scsi_io_request " "dev %p dev %d:%d:%d length %"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, bus, target, lun, len);
#line 1830 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 32 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_process_scsi_io_request " "dev %p dev %d:%d:%d length %"PRIu64"" "\n", dev, bus, target, lun, len);
#line 1834 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_process_scsi_io_request(void * dev, int bus, int target, int lun, uint64_t len)
{
    if (true) {
        _nocheck__trace_mptsas_process_scsi_io_request(dev, bus, target, lun, len);
    }
}

#define TRACE_MPTSAS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_RESET) || \
    false)

static inline void _nocheck__trace_mptsas_reset(void * dev)
{
    if (trace_event_get_state(TRACE_MPTSAS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 33 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_reset " "dev %p " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev);
#line 1861 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 33 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_reset " "dev %p " "\n", dev);
#line 1865 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_reset(void * dev)
{
    if (true) {
        _nocheck__trace_mptsas_reset(dev);
    }
}

#define TRACE_MPTSAS_SCSI_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_SCSI_OVERFLOW) || \
    false)

static inline void _nocheck__trace_mptsas_scsi_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (trace_event_get_state(TRACE_MPTSAS_SCSI_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 34 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_scsi_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ctx, req, found);
#line 1892 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 34 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_scsi_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n", dev, ctx, req, found);
#line 1896 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_scsi_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (true) {
        _nocheck__trace_mptsas_scsi_overflow(dev, ctx, req, found);
    }
}

#define TRACE_MPTSAS_SGL_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_SGL_OVERFLOW) || \
    false)

static inline void _nocheck__trace_mptsas_sgl_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (trace_event_get_state(TRACE_MPTSAS_SGL_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 35 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_sgl_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ctx, req, found);
#line 1923 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 35 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_sgl_overflow " "dev %p context 0x%08x: %"PRIu64"/%"PRIu64"" "\n", dev, ctx, req, found);
#line 1927 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_sgl_overflow(void * dev, uint32_t ctx, uint64_t req, uint64_t found)
{
    if (true) {
        _nocheck__trace_mptsas_sgl_overflow(dev, ctx, req, found);
    }
}

#define TRACE_MPTSAS_UNHANDLED_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_UNHANDLED_CMD) || \
    false)

static inline void _nocheck__trace_mptsas_unhandled_cmd(void * dev, uint32_t ctx, uint8_t msg_cmd)
{
    if (trace_event_get_state(TRACE_MPTSAS_UNHANDLED_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_unhandled_cmd " "dev %p context 0x%08x: Unhandled cmd 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, ctx, msg_cmd);
#line 1954 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 36 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_unhandled_cmd " "dev %p context 0x%08x: Unhandled cmd 0x%x" "\n", dev, ctx, msg_cmd);
#line 1958 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_unhandled_cmd(void * dev, uint32_t ctx, uint8_t msg_cmd)
{
    if (true) {
        _nocheck__trace_mptsas_unhandled_cmd(dev, ctx, msg_cmd);
    }
}

#define TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD) || \
    false)

static inline void _nocheck__trace_mptsas_unhandled_doorbell_cmd(void * dev, int cmd)
{
    if (trace_event_get_state(TRACE_MPTSAS_UNHANDLED_DOORBELL_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_unhandled_doorbell_cmd " "dev %p value 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, cmd);
#line 1985 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 37 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_unhandled_doorbell_cmd " "dev %p value 0x%08x" "\n", dev, cmd);
#line 1989 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_unhandled_doorbell_cmd(void * dev, int cmd)
{
    if (true) {
        _nocheck__trace_mptsas_unhandled_doorbell_cmd(dev, cmd);
    }
}

#define TRACE_MPTSAS_CONFIG_SAS_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_CONFIG_SAS_DEVICE) || \
    false)

static inline void _nocheck__trace_mptsas_config_sas_device(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (trace_event_get_state(TRACE_MPTSAS_CONFIG_SAS_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_config_sas_device " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, address, port, phy_handle, dev_handle, page);
#line 2016 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 40 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_config_sas_device " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n", dev, address, port, phy_handle, dev_handle, page);
#line 2020 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_config_sas_device(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (true) {
        _nocheck__trace_mptsas_config_sas_device(dev, address, port, phy_handle, dev_handle, page);
    }
}

#define TRACE_MPTSAS_CONFIG_SAS_PHY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MPTSAS_CONFIG_SAS_PHY) || \
    false)

static inline void _nocheck__trace_mptsas_config_sas_phy(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (trace_event_get_state(TRACE_MPTSAS_CONFIG_SAS_PHY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:mptsas_config_sas_phy " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dev, address, port, phy_handle, dev_handle, page);
#line 2047 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 41 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("mptsas_config_sas_phy " "dev %p address %d (port %d, handles: phy %d dev %d) page %d" "\n", dev, address, port, phy_handle, dev_handle, page);
#line 2051 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_mptsas_config_sas_phy(void * dev, int address, int port, int phy_handle, int dev_handle, int page)
{
    if (true) {
        _nocheck__trace_mptsas_config_sas_phy(dev, address, port, phy_handle, dev_handle, page);
    }
}

#define TRACE_MEGASAS_INIT_FIRMWARE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INIT_FIRMWARE) || \
    false)

static inline void _nocheck__trace_megasas_init_firmware(uint64_t pa)
{
    if (trace_event_get_state(TRACE_MEGASAS_INIT_FIRMWARE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_init_firmware " "pa 0x%" PRIx64 " " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pa);
#line 2078 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 44 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_init_firmware " "pa 0x%" PRIx64 " " "\n", pa);
#line 2082 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_init_firmware(uint64_t pa)
{
    if (true) {
        _nocheck__trace_megasas_init_firmware(pa);
    }
}

#define TRACE_MEGASAS_INIT_QUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INIT_QUEUE) || \
    false)

static inline void _nocheck__trace_megasas_init_queue(uint64_t queue_pa, int queue_len, uint32_t head, uint32_t tail, uint32_t flags)
{
    if (trace_event_get_state(TRACE_MEGASAS_INIT_QUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_init_queue " "queue at 0x%" PRIx64 " len %d head 0x%" PRIx32 " tail 0x%" PRIx32 " flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queue_pa, queue_len, head, tail, flags);
#line 2109 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 45 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_init_queue " "queue at 0x%" PRIx64 " len %d head 0x%" PRIx32 " tail 0x%" PRIx32 " flags 0x%x" "\n", queue_pa, queue_len, head, tail, flags);
#line 2113 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_init_queue(uint64_t queue_pa, int queue_len, uint32_t head, uint32_t tail, uint32_t flags)
{
    if (true) {
        _nocheck__trace_megasas_init_queue(queue_pa, queue_len, head, tail, flags);
    }
}

#define TRACE_MEGASAS_INITQ_MAP_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INITQ_MAP_FAILED) || \
    false)

static inline void _nocheck__trace_megasas_initq_map_failed(int frame)
{
    if (trace_event_get_state(TRACE_MEGASAS_INITQ_MAP_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_initq_map_failed " "scmd %d: failed to map queue" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame);
#line 2140 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 46 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_initq_map_failed " "scmd %d: failed to map queue" "\n", frame);
#line 2144 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_initq_map_failed(int frame)
{
    if (true) {
        _nocheck__trace_megasas_initq_map_failed(frame);
    }
}

#define TRACE_MEGASAS_INITQ_MAPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INITQ_MAPPED) || \
    false)

static inline void _nocheck__trace_megasas_initq_mapped(uint64_t pa)
{
    if (trace_event_get_state(TRACE_MEGASAS_INITQ_MAPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_initq_mapped " "queue already mapped at 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pa);
#line 2171 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 47 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_initq_mapped " "queue already mapped at 0x%" PRIx64 "\n", pa);
#line 2175 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_initq_mapped(uint64_t pa)
{
    if (true) {
        _nocheck__trace_megasas_initq_mapped(pa);
    }
}

#define TRACE_MEGASAS_INITQ_MISMATCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INITQ_MISMATCH) || \
    false)

static inline void _nocheck__trace_megasas_initq_mismatch(int queue_len, int fw_cmds)
{
    if (trace_event_get_state(TRACE_MEGASAS_INITQ_MISMATCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_initq_mismatch " "queue size %d max fw cmds %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , queue_len, fw_cmds);
#line 2202 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 48 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_initq_mismatch " "queue size %d max fw cmds %d" "\n", queue_len, fw_cmds);
#line 2206 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_initq_mismatch(int queue_len, int fw_cmds)
{
    if (true) {
        _nocheck__trace_megasas_initq_mismatch(queue_len, fw_cmds);
    }
}

#define TRACE_MEGASAS_QF_MAPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_MAPPED) || \
    false)

static inline void _nocheck__trace_megasas_qf_mapped(unsigned int index)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_MAPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_mapped " "skip mapped frame 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 2233 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 49 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_mapped " "skip mapped frame 0x%x" "\n", index);
#line 2237 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_mapped(unsigned int index)
{
    if (true) {
        _nocheck__trace_megasas_qf_mapped(index);
    }
}

#define TRACE_MEGASAS_QF_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_NEW) || \
    false)

static inline void _nocheck__trace_megasas_qf_new(unsigned int index, uint64_t frame)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_new " "frame 0x%x addr 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, frame);
#line 2264 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 50 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_new " "frame 0x%x addr 0x%" PRIx64 "\n", index, frame);
#line 2268 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_new(unsigned int index, uint64_t frame)
{
    if (true) {
        _nocheck__trace_megasas_qf_new(index, frame);
    }
}

#define TRACE_MEGASAS_QF_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_BUSY) || \
    false)

static inline void _nocheck__trace_megasas_qf_busy(unsigned long pa)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_BUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_busy " "all frames busy for frame 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , pa);
#line 2295 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 51 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_busy " "all frames busy for frame 0x%lx" "\n", pa);
#line 2299 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_busy(unsigned long pa)
{
    if (true) {
        _nocheck__trace_megasas_qf_busy(pa);
    }
}

#define TRACE_MEGASAS_QF_ENQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_ENQUEUE) || \
    false)

static inline void _nocheck__trace_megasas_qf_enqueue(unsigned int index, unsigned int count, uint64_t context, uint32_t head, uint32_t tail, unsigned int busy)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_ENQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_enqueue " "frame 0x%x count %d context 0x%" PRIx64 " head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index, count, context, head, tail, busy);
#line 2326 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 52 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_enqueue " "frame 0x%x count %d context 0x%" PRIx64 " head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n", index, count, context, head, tail, busy);
#line 2330 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_enqueue(unsigned int index, unsigned int count, uint64_t context, uint32_t head, uint32_t tail, unsigned int busy)
{
    if (true) {
        _nocheck__trace_megasas_qf_enqueue(index, count, context, head, tail, busy);
    }
}

#define TRACE_MEGASAS_QF_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_UPDATE) || \
    false)

static inline void _nocheck__trace_megasas_qf_update(uint32_t head, uint32_t tail, unsigned int busy)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_update " "head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , head, tail, busy);
#line 2357 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 53 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_update " "head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n", head, tail, busy);
#line 2361 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_update(uint32_t head, uint32_t tail, unsigned int busy)
{
    if (true) {
        _nocheck__trace_megasas_qf_update(head, tail, busy);
    }
}

#define TRACE_MEGASAS_QF_MAP_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_MAP_FAILED) || \
    false)

static inline void _nocheck__trace_megasas_qf_map_failed(int cmd, unsigned long frame)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_MAP_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_map_failed " "scmd %d: frame %lu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, frame);
#line 2388 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 54 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_map_failed " "scmd %d: frame %lu" "\n", cmd, frame);
#line 2392 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_map_failed(int cmd, unsigned long frame)
{
    if (true) {
        _nocheck__trace_megasas_qf_map_failed(cmd, frame);
    }
}

#define TRACE_MEGASAS_QF_COMPLETE_NOIRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_COMPLETE_NOIRQ) || \
    false)

static inline void _nocheck__trace_megasas_qf_complete_noirq(uint64_t context)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE_NOIRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_complete_noirq " "context 0x%" PRIx64 " " "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , context);
#line 2419 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 55 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_complete_noirq " "context 0x%" PRIx64 " " "\n", context);
#line 2423 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_complete_noirq(uint64_t context)
{
    if (true) {
        _nocheck__trace_megasas_qf_complete_noirq(context);
    }
}

#define TRACE_MEGASAS_QF_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_QF_COMPLETE) || \
    false)

static inline void _nocheck__trace_megasas_qf_complete(uint64_t context, uint32_t head, uint32_t tail, int busy)
{
    if (trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_qf_complete " "context 0x%" PRIx64 " head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , context, head, tail, busy);
#line 2450 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 56 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_qf_complete " "context 0x%" PRIx64 " head 0x%" PRIx32 " tail 0x%" PRIx32 " busy %u" "\n", context, head, tail, busy);
#line 2454 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_qf_complete(uint64_t context, uint32_t head, uint32_t tail, int busy)
{
    if (true) {
        _nocheck__trace_megasas_qf_complete(context, head, tail, busy);
    }
}

#define TRACE_MEGASAS_FRAME_BUSY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_FRAME_BUSY) || \
    false)

static inline void _nocheck__trace_megasas_frame_busy(uint64_t addr)
{
    if (trace_event_get_state(TRACE_MEGASAS_FRAME_BUSY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_frame_busy " "frame 0x%" PRIx64 " busy" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 2481 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 57 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_frame_busy " "frame 0x%" PRIx64 " busy" "\n", addr);
#line 2485 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_frame_busy(uint64_t addr)
{
    if (true) {
        _nocheck__trace_megasas_frame_busy(addr);
    }
}

#define TRACE_MEGASAS_UNHANDLED_FRAME_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_UNHANDLED_FRAME_CMD) || \
    false)

static inline void _nocheck__trace_megasas_unhandled_frame_cmd(int cmd, uint8_t frame_cmd)
{
    if (trace_event_get_state(TRACE_MEGASAS_UNHANDLED_FRAME_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_unhandled_frame_cmd " "scmd %d: MFI cmd 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, frame_cmd);
#line 2512 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 58 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_unhandled_frame_cmd " "scmd %d: MFI cmd 0x%x" "\n", cmd, frame_cmd);
#line 2516 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_unhandled_frame_cmd(int cmd, uint8_t frame_cmd)
{
    if (true) {
        _nocheck__trace_megasas_unhandled_frame_cmd(cmd, frame_cmd);
    }
}

#define TRACE_MEGASAS_HANDLE_SCSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_HANDLE_SCSI) || \
    false)

static inline void _nocheck__trace_megasas_handle_scsi(const char * frame, int bus, int dev, int lun, void * sdev, unsigned long size)
{
    if (trace_event_get_state(TRACE_MEGASAS_HANDLE_SCSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_handle_scsi " "%s dev %x/%x/%x sdev %p xfer %lu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, bus, dev, lun, sdev, size);
#line 2543 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 59 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_handle_scsi " "%s dev %x/%x/%x sdev %p xfer %lu" "\n", frame, bus, dev, lun, sdev, size);
#line 2547 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_handle_scsi(const char * frame, int bus, int dev, int lun, void * sdev, unsigned long size)
{
    if (true) {
        _nocheck__trace_megasas_handle_scsi(frame, bus, dev, lun, sdev, size);
    }
}

#define TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_megasas_scsi_target_not_present(const char * frame, int bus, int dev, int lun)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_target_not_present " "%s dev %x/%x/%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, bus, dev, lun);
#line 2574 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 60 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_target_not_present " "%s dev %x/%x/%x" "\n", frame, bus, dev, lun);
#line 2578 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_target_not_present(const char * frame, int bus, int dev, int lun)
{
    if (true) {
        _nocheck__trace_megasas_scsi_target_not_present(frame, bus, dev, lun);
    }
}

#define TRACE_MEGASAS_SCSI_INVALID_CDB_LEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_INVALID_CDB_LEN) || \
    false)

static inline void _nocheck__trace_megasas_scsi_invalid_cdb_len(const char * frame, int bus, int dev, int lun, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_INVALID_CDB_LEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_invalid_cdb_len " "%s dev %x/%x/%x invalid cdb len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, bus, dev, lun, len);
#line 2605 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 61 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_invalid_cdb_len " "%s dev %x/%x/%x invalid cdb len %d" "\n", frame, bus, dev, lun, len);
#line 2609 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_invalid_cdb_len(const char * frame, int bus, int dev, int lun, int len)
{
    if (true) {
        _nocheck__trace_megasas_scsi_invalid_cdb_len(frame, bus, dev, lun, len);
    }
}

#define TRACE_MEGASAS_IOV_READ_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOV_READ_OVERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iov_read_overflow(int cmd, int bytes, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOV_READ_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iov_read_overflow " "scmd %d: %d/%d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, bytes, len);
#line 2636 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 62 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iov_read_overflow " "scmd %d: %d/%d bytes" "\n", cmd, bytes, len);
#line 2640 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iov_read_overflow(int cmd, int bytes, int len)
{
    if (true) {
        _nocheck__trace_megasas_iov_read_overflow(cmd, bytes, len);
    }
}

#define TRACE_MEGASAS_IOV_WRITE_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOV_WRITE_OVERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iov_write_overflow(int cmd, int bytes, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iov_write_overflow " "scmd %d: %d/%d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, bytes, len);
#line 2667 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 63 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iov_write_overflow " "scmd %d: %d/%d bytes" "\n", cmd, bytes, len);
#line 2671 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iov_write_overflow(int cmd, int bytes, int len)
{
    if (true) {
        _nocheck__trace_megasas_iov_write_overflow(cmd, bytes, len);
    }
}

#define TRACE_MEGASAS_IOV_READ_UNDERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOV_READ_UNDERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iov_read_underflow(int cmd, int bytes, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOV_READ_UNDERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iov_read_underflow " "scmd %d: %d/%d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, bytes, len);
#line 2698 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 64 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iov_read_underflow " "scmd %d: %d/%d bytes" "\n", cmd, bytes, len);
#line 2702 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iov_read_underflow(int cmd, int bytes, int len)
{
    if (true) {
        _nocheck__trace_megasas_iov_read_underflow(cmd, bytes, len);
    }
}

#define TRACE_MEGASAS_IOV_WRITE_UNDERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOV_WRITE_UNDERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iov_write_underflow(int cmd, int bytes, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_UNDERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iov_write_underflow " "scmd %d: %d/%d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, bytes, len);
#line 2729 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 65 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iov_write_underflow " "scmd %d: %d/%d bytes" "\n", cmd, bytes, len);
#line 2733 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iov_write_underflow(int cmd, int bytes, int len)
{
    if (true) {
        _nocheck__trace_megasas_iov_write_underflow(cmd, bytes, len);
    }
}

#define TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED) || \
    false)

static inline void _nocheck__trace_megasas_scsi_req_alloc_failed(const char * frame, int dev, int lun)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_req_alloc_failed " "%s dev %x/%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , frame, dev, lun);
#line 2760 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 66 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_req_alloc_failed " "%s dev %x/%x" "\n", frame, dev, lun);
#line 2764 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_req_alloc_failed(const char * frame, int dev, int lun)
{
    if (true) {
        _nocheck__trace_megasas_scsi_req_alloc_failed(frame, dev, lun);
    }
}

#define TRACE_MEGASAS_SCSI_READ_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_READ_START) || \
    false)

static inline void _nocheck__trace_megasas_scsi_read_start(int cmd, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_READ_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_read_start " "scmd %d: transfer %d bytes of data" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, len);
#line 2791 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 67 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_read_start " "scmd %d: transfer %d bytes of data" "\n", cmd, len);
#line 2795 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_read_start(int cmd, int len)
{
    if (true) {
        _nocheck__trace_megasas_scsi_read_start(cmd, len);
    }
}

#define TRACE_MEGASAS_SCSI_WRITE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_WRITE_START) || \
    false)

static inline void _nocheck__trace_megasas_scsi_write_start(int cmd, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_WRITE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_write_start " "scmd %d: transfer %d bytes of data" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, len);
#line 2822 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 68 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_write_start " "scmd %d: transfer %d bytes of data" "\n", cmd, len);
#line 2826 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_write_start(int cmd, int len)
{
    if (true) {
        _nocheck__trace_megasas_scsi_write_start(cmd, len);
    }
}

#define TRACE_MEGASAS_SCSI_NODATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_NODATA) || \
    false)

static inline void _nocheck__trace_megasas_scsi_nodata(int cmd)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_NODATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_nodata " "scmd %d: no data to be transferred" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd);
#line 2853 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 69 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_nodata " "scmd %d: no data to be transferred" "\n", cmd);
#line 2857 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_nodata(int cmd)
{
    if (true) {
        _nocheck__trace_megasas_scsi_nodata(cmd);
    }
}

#define TRACE_MEGASAS_SCSI_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_SCSI_COMPLETE) || \
    false)

static inline void _nocheck__trace_megasas_scsi_complete(int cmd, uint32_t status, int len, int xfer)
{
    if (trace_event_get_state(TRACE_MEGASAS_SCSI_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_scsi_complete " "scmd %d: status 0x%x, len %u/%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, status, len, xfer);
#line 2884 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 70 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_scsi_complete " "scmd %d: status 0x%x, len %u/%u" "\n", cmd, status, len, xfer);
#line 2888 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_scsi_complete(int cmd, uint32_t status, int len, int xfer)
{
    if (true) {
        _nocheck__trace_megasas_scsi_complete(cmd, status, len, xfer);
    }
}

#define TRACE_MEGASAS_COMMAND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_COMMAND_COMPLETE) || \
    false)

static inline void _nocheck__trace_megasas_command_complete(int cmd, uint32_t status, uint32_t resid)
{
    if (trace_event_get_state(TRACE_MEGASAS_COMMAND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_command_complete " "scmd %d: status 0x%x, residual %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, status, resid);
#line 2915 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 71 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_command_complete " "scmd %d: status 0x%x, residual %d" "\n", cmd, status, resid);
#line 2919 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_command_complete(int cmd, uint32_t status, uint32_t resid)
{
    if (true) {
        _nocheck__trace_megasas_command_complete(cmd, status, resid);
    }
}

#define TRACE_MEGASAS_HANDLE_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_HANDLE_IO) || \
    false)

static inline void _nocheck__trace_megasas_handle_io(int cmd, const char * frame, int dev, int lun, unsigned long lba, unsigned long count)
{
    if (trace_event_get_state(TRACE_MEGASAS_HANDLE_IO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_handle_io " "scmd %d: %s dev %x/%x lba 0x%lx count %lu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, frame, dev, lun, lba, count);
#line 2946 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 72 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_handle_io " "scmd %d: %s dev %x/%x lba 0x%lx count %lu" "\n", cmd, frame, dev, lun, lba, count);
#line 2950 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_handle_io(int cmd, const char * frame, int dev, int lun, unsigned long lba, unsigned long count)
{
    if (true) {
        _nocheck__trace_megasas_handle_io(cmd, frame, dev, lun, lba, count);
    }
}

#define TRACE_MEGASAS_IO_TARGET_NOT_PRESENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IO_TARGET_NOT_PRESENT) || \
    false)

static inline void _nocheck__trace_megasas_io_target_not_present(int cmd, const char * frame, int dev, int lun)
{
    if (trace_event_get_state(TRACE_MEGASAS_IO_TARGET_NOT_PRESENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_io_target_not_present " "scmd %d: %s dev 1/%x/%x LUN not present" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, frame, dev, lun);
#line 2977 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 73 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_io_target_not_present " "scmd %d: %s dev 1/%x/%x LUN not present" "\n", cmd, frame, dev, lun);
#line 2981 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_io_target_not_present(int cmd, const char * frame, int dev, int lun)
{
    if (true) {
        _nocheck__trace_megasas_io_target_not_present(cmd, frame, dev, lun);
    }
}

#define TRACE_MEGASAS_IO_READ_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IO_READ_START) || \
    false)

static inline void _nocheck__trace_megasas_io_read_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IO_READ_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_io_read_start " "scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, lba, count, len);
#line 3008 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 74 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_io_read_start " "scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)" "\n", cmd, lba, count, len);
#line 3012 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_io_read_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (true) {
        _nocheck__trace_megasas_io_read_start(cmd, lba, count, len);
    }
}

#define TRACE_MEGASAS_IO_WRITE_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IO_WRITE_START) || \
    false)

static inline void _nocheck__trace_megasas_io_write_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IO_WRITE_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_io_write_start " "scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, lba, count, len);
#line 3039 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 75 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_io_write_start " "scmd %d: start LBA 0x%lx %lu blocks (%lu bytes)" "\n", cmd, lba, count, len);
#line 3043 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_io_write_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    if (true) {
        _nocheck__trace_megasas_io_write_start(cmd, lba, count, len);
    }
}

#define TRACE_MEGASAS_IO_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IO_COMPLETE) || \
    false)

static inline void _nocheck__trace_megasas_io_complete(int cmd, uint32_t len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IO_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_io_complete " "scmd %d: %d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, len);
#line 3070 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 76 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_io_complete " "scmd %d: %d bytes" "\n", cmd, len);
#line 3074 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_io_complete(int cmd, uint32_t len)
{
    if (true) {
        _nocheck__trace_megasas_io_complete(cmd, len);
    }
}

#define TRACE_MEGASAS_IOVEC_SGL_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOVEC_SGL_OVERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iovec_sgl_overflow(int cmd, int index, int limit)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iovec_sgl_overflow " "scmd %d: iovec count %d limit %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, index, limit);
#line 3101 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 77 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iovec_sgl_overflow " "scmd %d: iovec count %d limit %d" "\n", cmd, index, limit);
#line 3105 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iovec_sgl_overflow(int cmd, int index, int limit)
{
    if (true) {
        _nocheck__trace_megasas_iovec_sgl_overflow(cmd, index, limit);
    }
}

#define TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iovec_sgl_underflow(int cmd, int index)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iovec_sgl_underflow " "scmd %d: iovec count %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, index);
#line 3132 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 78 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iovec_sgl_underflow " "scmd %d: iovec count %d" "\n", cmd, index);
#line 3136 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iovec_sgl_underflow(int cmd, int index)
{
    if (true) {
        _nocheck__trace_megasas_iovec_sgl_underflow(cmd, index);
    }
}

#define TRACE_MEGASAS_IOVEC_SGL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOVEC_SGL_INVALID) || \
    false)

static inline void _nocheck__trace_megasas_iovec_sgl_invalid(int cmd, int index, uint64_t pa, uint32_t len)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iovec_sgl_invalid " "scmd %d: element %d pa 0x%" PRIx64 " len %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, index, pa, len);
#line 3163 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 79 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iovec_sgl_invalid " "scmd %d: element %d pa 0x%" PRIx64 " len %u" "\n", cmd, index, pa, len);
#line 3167 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iovec_sgl_invalid(int cmd, int index, uint64_t pa, uint32_t len)
{
    if (true) {
        _nocheck__trace_megasas_iovec_sgl_invalid(cmd, index, pa, len);
    }
}

#define TRACE_MEGASAS_IOVEC_OVERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOVEC_OVERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iovec_overflow(int cmd, int len, int limit)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOVEC_OVERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iovec_overflow " "scmd %d: len %d limit %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, len, limit);
#line 3194 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 80 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iovec_overflow " "scmd %d: len %d limit %d" "\n", cmd, len, limit);
#line 3198 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iovec_overflow(int cmd, int len, int limit)
{
    if (true) {
        _nocheck__trace_megasas_iovec_overflow(cmd, len, limit);
    }
}

#define TRACE_MEGASAS_IOVEC_UNDERFLOW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IOVEC_UNDERFLOW) || \
    false)

static inline void _nocheck__trace_megasas_iovec_underflow(int cmd, int len, int limit)
{
    if (trace_event_get_state(TRACE_MEGASAS_IOVEC_UNDERFLOW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_iovec_underflow " "scmd %d: len %d limit %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, len, limit);
#line 3225 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 81 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_iovec_underflow " "scmd %d: len %d limit %d" "\n", cmd, len, limit);
#line 3229 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_iovec_underflow(int cmd, int len, int limit)
{
    if (true) {
        _nocheck__trace_megasas_iovec_underflow(cmd, len, limit);
    }
}

#define TRACE_MEGASAS_HANDLE_DCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_HANDLE_DCMD) || \
    false)

static inline void _nocheck__trace_megasas_handle_dcmd(int cmd, int opcode)
{
    if (trace_event_get_state(TRACE_MEGASAS_HANDLE_DCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_handle_dcmd " "scmd %d: MFI DCMD opcode 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, opcode);
#line 3256 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 82 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_handle_dcmd " "scmd %d: MFI DCMD opcode 0x%x" "\n", cmd, opcode);
#line 3260 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_handle_dcmd(int cmd, int opcode)
{
    if (true) {
        _nocheck__trace_megasas_handle_dcmd(cmd, opcode);
    }
}

#define TRACE_MEGASAS_FINISH_DCMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_FINISH_DCMD) || \
    false)

static inline void _nocheck__trace_megasas_finish_dcmd(int cmd, int size)
{
    if (trace_event_get_state(TRACE_MEGASAS_FINISH_DCMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_finish_dcmd " "scmd %d: MFI DCMD wrote %d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, size);
#line 3287 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 83 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_finish_dcmd " "scmd %d: MFI DCMD wrote %d bytes" "\n", cmd, size);
#line 3291 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_finish_dcmd(int cmd, int size)
{
    if (true) {
        _nocheck__trace_megasas_finish_dcmd(cmd, size);
    }
}

#define TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_req_alloc_failed(int cmd, const char * desc)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_req_alloc_failed " "scmd %d: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, desc);
#line 3318 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 84 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_req_alloc_failed " "scmd %d: %s" "\n", cmd, desc);
#line 3322 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_req_alloc_failed(int cmd, const char * desc)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_req_alloc_failed(cmd, desc);
    }
}

#define TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_internal_submit(int cmd, const char * desc, int dev)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 85 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_internal_submit " "scmd %d: %s to dev %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, desc, dev);
#line 3349 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 85 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_internal_submit " "scmd %d: %s to dev %d" "\n", cmd, desc, dev);
#line 3353 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_internal_submit(int cmd, const char * desc, int dev)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_internal_submit(cmd, desc, dev);
    }
}

#define TRACE_MEGASAS_DCMD_INTERNAL_FINISH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_INTERNAL_FINISH) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_internal_finish(int cmd, int opcode, int lun)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_FINISH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 86 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_internal_finish " "scmd %d: cmd 0x%x lun %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, opcode, lun);
#line 3380 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 86 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_internal_finish " "scmd %d: cmd 0x%x lun %d" "\n", cmd, opcode, lun);
#line 3384 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_internal_finish(int cmd, int opcode, int lun)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_internal_finish(cmd, opcode, lun);
    }
}

#define TRACE_MEGASAS_DCMD_INTERNAL_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_INTERNAL_INVALID) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_internal_invalid(int cmd, int opcode)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 87 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_internal_invalid " "scmd %d: DCMD 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, opcode);
#line 3411 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 87 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_internal_invalid " "scmd %d: DCMD 0x%x" "\n", cmd, opcode);
#line 3415 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_internal_invalid(int cmd, int opcode)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_internal_invalid(cmd, opcode);
    }
}

#define TRACE_MEGASAS_DCMD_UNHANDLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_UNHANDLED) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_unhandled(int cmd, int opcode, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_UNHANDLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_unhandled " "scmd %d: opcode 0x%x, len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, opcode, len);
#line 3442 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 88 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_unhandled " "scmd %d: opcode 0x%x, len %d" "\n", cmd, opcode, len);
#line 3446 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_unhandled(int cmd, int opcode, int len)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_unhandled(cmd, opcode, len);
    }
}

#define TRACE_MEGASAS_DCMD_ZERO_SGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_ZERO_SGE) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_zero_sge(int cmd)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_ZERO_SGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_zero_sge " "scmd %d: zero DCMD sge count" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd);
#line 3473 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 89 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_zero_sge " "scmd %d: zero DCMD sge count" "\n", cmd);
#line 3477 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_zero_sge(int cmd)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_zero_sge(cmd);
    }
}

#define TRACE_MEGASAS_DCMD_INVALID_SGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_INVALID_SGE) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_invalid_sge(int cmd, int count)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_SGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_invalid_sge " "scmd %d: DCMD sge count %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, count);
#line 3504 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 90 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_invalid_sge " "scmd %d: DCMD sge count %d" "\n", cmd, count);
#line 3508 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_invalid_sge(int cmd, int count)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_invalid_sge(cmd, count);
    }
}

#define TRACE_MEGASAS_DCMD_INVALID_XFER_LEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_INVALID_XFER_LEN) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_invalid_xfer_len(int cmd, unsigned long size, unsigned long max)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_XFER_LEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_invalid_xfer_len " "scmd %d: xfer len %ld, max %ld" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, size, max);
#line 3535 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 91 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_invalid_xfer_len " "scmd %d: xfer len %ld, max %ld" "\n", cmd, size, max);
#line 3539 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_invalid_xfer_len(int cmd, unsigned long size, unsigned long max)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_invalid_xfer_len(cmd, size, max);
    }
}

#define TRACE_MEGASAS_DCMD_ENTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_ENTER) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_enter(int cmd, const char * dcmd, int len)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_ENTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_enter " "scmd %d: DCMD %s len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, dcmd, len);
#line 3566 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 92 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_enter " "scmd %d: DCMD %s len %d" "\n", cmd, dcmd, len);
#line 3570 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_enter(int cmd, const char * dcmd, int len)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_enter(cmd, dcmd, len);
    }
}

#define TRACE_MEGASAS_DCMD_DUMMY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_DUMMY) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_dummy(int cmd, unsigned long size)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_DUMMY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_dummy " "scmd %d: xfer len %ld" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, size);
#line 3597 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 93 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_dummy " "scmd %d: xfer len %ld" "\n", cmd, size);
#line 3601 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_dummy(int cmd, unsigned long size)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_dummy(cmd, size);
    }
}

#define TRACE_MEGASAS_DCMD_SET_FW_TIME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_SET_FW_TIME) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_set_fw_time(int cmd, unsigned long time)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_SET_FW_TIME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_set_fw_time " "scmd %d: Set FW time 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, time);
#line 3628 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 94 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_set_fw_time " "scmd %d: Set FW time 0x%lx" "\n", cmd, time);
#line 3632 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_set_fw_time(int cmd, unsigned long time)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_set_fw_time(cmd, time);
    }
}

#define TRACE_MEGASAS_DCMD_PD_GET_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_PD_GET_LIST) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_pd_get_list(int cmd, int num, int max, int offset)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 95 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_pd_get_list " "scmd %d: DCMD PD get list: %d / %d PDs, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, num, max, offset);
#line 3659 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 95 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_pd_get_list " "scmd %d: DCMD PD get list: %d / %d PDs, size %d" "\n", cmd, num, max, offset);
#line 3663 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_pd_get_list(int cmd, int num, int max, int offset)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_pd_get_list(cmd, num, max, offset);
    }
}

#define TRACE_MEGASAS_DCMD_LD_GET_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_LD_GET_LIST) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_ld_get_list(int cmd, int num, int max)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 96 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_ld_get_list " "scmd %d: DCMD LD get list: found %d / %d LDs" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, num, max);
#line 3690 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 96 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_ld_get_list " "scmd %d: DCMD LD get list: found %d / %d LDs" "\n", cmd, num, max);
#line 3694 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_ld_get_list(int cmd, int num, int max)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_ld_get_list(cmd, num, max);
    }
}

#define TRACE_MEGASAS_DCMD_LD_GET_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_LD_GET_INFO) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_ld_get_info(int cmd, int ld_id)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_ld_get_info " "scmd %d: dev %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, ld_id);
#line 3721 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 97 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_ld_get_info " "scmd %d: dev %d" "\n", cmd, ld_id);
#line 3725 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_ld_get_info(int cmd, int ld_id)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_ld_get_info(cmd, ld_id);
    }
}

#define TRACE_MEGASAS_DCMD_LD_LIST_QUERY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_LD_LIST_QUERY) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_ld_list_query(int cmd, int flags)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_LD_LIST_QUERY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 98 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_ld_list_query " "scmd %d: query flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, flags);
#line 3752 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 98 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_ld_list_query " "scmd %d: query flags 0x%x" "\n", cmd, flags);
#line 3756 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_ld_list_query(int cmd, int flags)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_ld_list_query(cmd, flags);
    }
}

#define TRACE_MEGASAS_DCMD_PD_GET_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_PD_GET_INFO) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_pd_get_info(int cmd, int pd_id)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 99 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_pd_get_info " "scmd %d: dev %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, pd_id);
#line 3783 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 99 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_pd_get_info " "scmd %d: dev %d" "\n", cmd, pd_id);
#line 3787 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_pd_get_info(int cmd, int pd_id)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_pd_get_info(cmd, pd_id);
    }
}

#define TRACE_MEGASAS_DCMD_PD_LIST_QUERY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_PD_LIST_QUERY) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_pd_list_query(int cmd, int flags)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_PD_LIST_QUERY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_pd_list_query " "scmd %d: query flags 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, flags);
#line 3814 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 100 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_pd_list_query " "scmd %d: query flags 0x%x" "\n", cmd, flags);
#line 3818 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_pd_list_query(int cmd, int flags)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_pd_list_query(cmd, flags);
    }
}

#define TRACE_MEGASAS_DCMD_RESET_LD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_RESET_LD) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_reset_ld(int cmd, int target_id)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_RESET_LD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_reset_ld " "scmd %d: dev %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, target_id);
#line 3845 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 101 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_reset_ld " "scmd %d: dev %d" "\n", cmd, target_id);
#line 3849 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_reset_ld(int cmd, int target_id)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_reset_ld(cmd, target_id);
    }
}

#define TRACE_MEGASAS_DCMD_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_DCMD_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_megasas_dcmd_unsupported(int cmd, unsigned long size)
{
    if (trace_event_get_state(TRACE_MEGASAS_DCMD_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_dcmd_unsupported " "scmd %d: set properties len %ld" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, size);
#line 3876 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 102 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_dcmd_unsupported " "scmd %d: set properties len %ld" "\n", cmd, size);
#line 3880 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_dcmd_unsupported(int cmd, unsigned long size)
{
    if (true) {
        _nocheck__trace_megasas_dcmd_unsupported(cmd, size);
    }
}

#define TRACE_MEGASAS_ABORT_FRAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_ABORT_FRAME) || \
    false)

static inline void _nocheck__trace_megasas_abort_frame(int cmd, int abort_cmd)
{
    if (trace_event_get_state(TRACE_MEGASAS_ABORT_FRAME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_abort_frame " "scmd %d: frame 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, abort_cmd);
#line 3907 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 103 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_abort_frame " "scmd %d: frame 0x%x" "\n", cmd, abort_cmd);
#line 3911 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_abort_frame(int cmd, int abort_cmd)
{
    if (true) {
        _nocheck__trace_megasas_abort_frame(cmd, abort_cmd);
    }
}

#define TRACE_MEGASAS_ABORT_NO_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_ABORT_NO_CMD) || \
    false)

static inline void _nocheck__trace_megasas_abort_no_cmd(int cmd, uint64_t context)
{
    if (trace_event_get_state(TRACE_MEGASAS_ABORT_NO_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_abort_no_cmd " "scmd %d: no active command for frame context 0x%" PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, context);
#line 3938 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 104 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_abort_no_cmd " "scmd %d: no active command for frame context 0x%" PRIx64 "\n", cmd, context);
#line 3942 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_abort_no_cmd(int cmd, uint64_t context)
{
    if (true) {
        _nocheck__trace_megasas_abort_no_cmd(cmd, context);
    }
}

#define TRACE_MEGASAS_ABORT_INVALID_CONTEXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_ABORT_INVALID_CONTEXT) || \
    false)

static inline void _nocheck__trace_megasas_abort_invalid_context(int cmd, uint64_t context, int abort_cmd)
{
    if (trace_event_get_state(TRACE_MEGASAS_ABORT_INVALID_CONTEXT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_abort_invalid_context " "scmd %d: invalid frame context 0x%" PRIx64 " for abort frame 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, context, abort_cmd);
#line 3969 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 105 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_abort_invalid_context " "scmd %d: invalid frame context 0x%" PRIx64 " for abort frame 0x%x" "\n", cmd, context, abort_cmd);
#line 3973 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_abort_invalid_context(int cmd, uint64_t context, int abort_cmd)
{
    if (true) {
        _nocheck__trace_megasas_abort_invalid_context(cmd, context, abort_cmd);
    }
}

#define TRACE_MEGASAS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_RESET) || \
    false)

static inline void _nocheck__trace_megasas_reset(int fw_state)
{
    if (trace_event_get_state(TRACE_MEGASAS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_reset " "firmware state 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fw_state);
#line 4000 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 106 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_reset " "firmware state 0x%x" "\n", fw_state);
#line 4004 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_reset(int fw_state)
{
    if (true) {
        _nocheck__trace_megasas_reset(fw_state);
    }
}

#define TRACE_MEGASAS_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INIT) || \
    false)

static inline void _nocheck__trace_megasas_init(int sges, int cmds, const char * mode)
{
    if (trace_event_get_state(TRACE_MEGASAS_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_init " "Using %d sges, %d cmds, %s mode" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sges, cmds, mode);
#line 4031 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 107 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_init " "Using %d sges, %d cmds, %s mode" "\n", sges, cmds, mode);
#line 4035 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_init(int sges, int cmds, const char * mode)
{
    if (true) {
        _nocheck__trace_megasas_init(sges, cmds, mode);
    }
}

#define TRACE_MEGASAS_MSIX_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MSIX_RAISE) || \
    false)

static inline void _nocheck__trace_megasas_msix_raise(int vector)
{
    if (trace_event_get_state(TRACE_MEGASAS_MSIX_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_msix_raise " "vector %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 4062 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 108 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_msix_raise " "vector %d" "\n", vector);
#line 4066 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_msix_raise(int vector)
{
    if (true) {
        _nocheck__trace_megasas_msix_raise(vector);
    }
}

#define TRACE_MEGASAS_MSI_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MSI_RAISE) || \
    false)

static inline void _nocheck__trace_megasas_msi_raise(int vector)
{
    if (trace_event_get_state(TRACE_MEGASAS_MSI_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_msi_raise " "vector %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 4093 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 109 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_msi_raise " "vector %d" "\n", vector);
#line 4097 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_msi_raise(int vector)
{
    if (true) {
        _nocheck__trace_megasas_msi_raise(vector);
    }
}

#define TRACE_MEGASAS_IRQ_LOWER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IRQ_LOWER) || \
    false)

static inline void _nocheck__trace_megasas_irq_lower(void)
{
    if (trace_event_get_state(TRACE_MEGASAS_IRQ_LOWER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 110 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_irq_lower " "INTx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4124 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 110 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_irq_lower " "INTx" "\n");
#line 4128 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_irq_lower(void)
{
    if (true) {
        _nocheck__trace_megasas_irq_lower();
    }
}

#define TRACE_MEGASAS_IRQ_RAISE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_IRQ_RAISE) || \
    false)

static inline void _nocheck__trace_megasas_irq_raise(void)
{
    if (trace_event_get_state(TRACE_MEGASAS_IRQ_RAISE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_irq_raise " "INTx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4155 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 111 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_irq_raise " "INTx" "\n");
#line 4159 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_irq_raise(void)
{
    if (true) {
        _nocheck__trace_megasas_irq_raise();
    }
}

#define TRACE_MEGASAS_INTR_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INTR_ENABLED) || \
    false)

static inline void _nocheck__trace_megasas_intr_enabled(void)
{
    if (trace_event_get_state(TRACE_MEGASAS_INTR_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_intr_enabled " "Interrupts enabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4186 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 112 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_intr_enabled " "Interrupts enabled" "\n");
#line 4190 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_intr_enabled(void)
{
    if (true) {
        _nocheck__trace_megasas_intr_enabled();
    }
}

#define TRACE_MEGASAS_INTR_DISABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_INTR_DISABLED) || \
    false)

static inline void _nocheck__trace_megasas_intr_disabled(void)
{
    if (trace_event_get_state(TRACE_MEGASAS_INTR_DISABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_intr_disabled " "Interrupts disabled" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4217 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 113 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_intr_disabled " "Interrupts disabled" "\n");
#line 4221 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_intr_disabled(void)
{
    if (true) {
        _nocheck__trace_megasas_intr_disabled();
    }
}

#define TRACE_MEGASAS_MSIX_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MSIX_ENABLED) || \
    false)

static inline void _nocheck__trace_megasas_msix_enabled(int vector)
{
    if (trace_event_get_state(TRACE_MEGASAS_MSIX_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_msix_enabled " "vector %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 4248 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 114 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_msix_enabled " "vector %d" "\n", vector);
#line 4252 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_msix_enabled(int vector)
{
    if (true) {
        _nocheck__trace_megasas_msix_enabled(vector);
    }
}

#define TRACE_MEGASAS_MSI_ENABLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MSI_ENABLED) || \
    false)

static inline void _nocheck__trace_megasas_msi_enabled(int vector)
{
    if (trace_event_get_state(TRACE_MEGASAS_MSI_ENABLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_msi_enabled " "vector %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , vector);
#line 4279 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 115 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_msi_enabled " "vector %d" "\n", vector);
#line 4283 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_msi_enabled(int vector)
{
    if (true) {
        _nocheck__trace_megasas_msi_enabled(vector);
    }
}

#define TRACE_MEGASAS_MMIO_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MMIO_READL) || \
    false)

static inline void _nocheck__trace_megasas_mmio_readl(const char * reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_MEGASAS_MMIO_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_mmio_readl " "reg %s: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, val);
#line 4310 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 116 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_mmio_readl " "reg %s: 0x%x" "\n", reg, val);
#line 4314 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_mmio_readl(const char * reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_megasas_mmio_readl(reg, val);
    }
}

#define TRACE_MEGASAS_MMIO_INVALID_READL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MMIO_INVALID_READL) || \
    false)

static inline void _nocheck__trace_megasas_mmio_invalid_readl(unsigned long addr)
{
    if (trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_READL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_mmio_invalid_readl " "addr 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4341 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 117 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_mmio_invalid_readl " "addr 0x%lx" "\n", addr);
#line 4345 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_mmio_invalid_readl(unsigned long addr)
{
    if (true) {
        _nocheck__trace_megasas_mmio_invalid_readl(addr);
    }
}

#define TRACE_MEGASAS_MMIO_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MMIO_WRITEL) || \
    false)

static inline void _nocheck__trace_megasas_mmio_writel(const char * reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_MEGASAS_MMIO_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 118 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_mmio_writel " "reg %s: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, val);
#line 4372 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 118 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_mmio_writel " "reg %s: 0x%x" "\n", reg, val);
#line 4376 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_mmio_writel(const char * reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_megasas_mmio_writel(reg, val);
    }
}

#define TRACE_MEGASAS_MMIO_INVALID_WRITEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_MEGASAS_MMIO_INVALID_WRITEL) || \
    false)

static inline void _nocheck__trace_megasas_mmio_invalid_writel(uint32_t addr, uint32_t val)
{
    if (trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_WRITEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 119 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:megasas_mmio_invalid_writel " "addr 0x%x: 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, val);
#line 4403 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 119 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("megasas_mmio_invalid_writel " "addr 0x%x: 0x%x" "\n", addr, val);
#line 4407 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_megasas_mmio_invalid_writel(uint32_t addr, uint32_t val)
{
    if (true) {
        _nocheck__trace_megasas_mmio_invalid_writel(addr, val);
    }
}

#define TRACE_PVSCSI_RING_INIT_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_RING_INIT_DATA) || \
    false)

static inline void _nocheck__trace_pvscsi_ring_init_data(uint32_t txr_len_log2, uint32_t rxr_len_log2)
{
    if (trace_event_get_state(TRACE_PVSCSI_RING_INIT_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_ring_init_data " "TX/RX rings logarithms set to %d/%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , txr_len_log2, rxr_len_log2);
#line 4434 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 122 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_ring_init_data " "TX/RX rings logarithms set to %d/%d" "\n", txr_len_log2, rxr_len_log2);
#line 4438 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_ring_init_data(uint32_t txr_len_log2, uint32_t rxr_len_log2)
{
    if (true) {
        _nocheck__trace_pvscsi_ring_init_data(txr_len_log2, rxr_len_log2);
    }
}

#define TRACE_PVSCSI_RING_INIT_MSG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_RING_INIT_MSG) || \
    false)

static inline void _nocheck__trace_pvscsi_ring_init_msg(uint32_t len_log2)
{
    if (trace_event_get_state(TRACE_PVSCSI_RING_INIT_MSG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 123 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_ring_init_msg " "MSG ring logarithm set to %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len_log2);
#line 4465 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 123 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_ring_init_msg " "MSG ring logarithm set to %d" "\n", len_log2);
#line 4469 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_ring_init_msg(uint32_t len_log2)
{
    if (true) {
        _nocheck__trace_pvscsi_ring_init_msg(len_log2);
    }
}

#define TRACE_PVSCSI_RING_FLUSH_CMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_RING_FLUSH_CMP) || \
    false)

static inline void _nocheck__trace_pvscsi_ring_flush_cmp(uint64_t filled_cmp_ptr)
{
    if (trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_CMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 124 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_ring_flush_cmp " "new production counter of completion ring is 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , filled_cmp_ptr);
#line 4496 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 124 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_ring_flush_cmp " "new production counter of completion ring is 0x%"PRIx64 "\n", filled_cmp_ptr);
#line 4500 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_ring_flush_cmp(uint64_t filled_cmp_ptr)
{
    if (true) {
        _nocheck__trace_pvscsi_ring_flush_cmp(filled_cmp_ptr);
    }
}

#define TRACE_PVSCSI_RING_FLUSH_MSG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_RING_FLUSH_MSG) || \
    false)

static inline void _nocheck__trace_pvscsi_ring_flush_msg(uint64_t filled_cmp_ptr)
{
    if (trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_MSG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_ring_flush_msg " "new production counter of message ring is 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , filled_cmp_ptr);
#line 4527 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 125 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_ring_flush_msg " "new production counter of message ring is 0x%"PRIx64 "\n", filled_cmp_ptr);
#line 4531 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_ring_flush_msg(uint64_t filled_cmp_ptr)
{
    if (true) {
        _nocheck__trace_pvscsi_ring_flush_msg(filled_cmp_ptr);
    }
}

#define TRACE_PVSCSI_UPDATE_IRQ_LEVEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_UPDATE_IRQ_LEVEL) || \
    false)

static inline void _nocheck__trace_pvscsi_update_irq_level(bool raise, uint64_t mask, uint64_t status)
{
    if (trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_LEVEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_update_irq_level " "interrupt level set to %d (MASK: 0x%"PRIx64", STATUS: 0x%"PRIx64")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , raise, mask, status);
#line 4558 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 126 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_update_irq_level " "interrupt level set to %d (MASK: 0x%"PRIx64", STATUS: 0x%"PRIx64")" "\n", raise, mask, status);
#line 4562 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_update_irq_level(bool raise, uint64_t mask, uint64_t status)
{
    if (true) {
        _nocheck__trace_pvscsi_update_irq_level(raise, mask, status);
    }
}

#define TRACE_PVSCSI_UPDATE_IRQ_MSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_UPDATE_IRQ_MSI) || \
    false)

static inline void _nocheck__trace_pvscsi_update_irq_msi(void)
{
    if (trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_MSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_update_irq_msi " "sending MSI notification" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4589 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 127 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_update_irq_msi " "sending MSI notification" "\n");
#line 4593 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_update_irq_msi(void)
{
    if (true) {
        _nocheck__trace_pvscsi_update_irq_msi();
    }
}

#define TRACE_PVSCSI_CMP_RING_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_CMP_RING_PUT) || \
    false)

static inline void _nocheck__trace_pvscsi_cmp_ring_put(unsigned long addr)
{
    if (trace_event_get_state(TRACE_PVSCSI_CMP_RING_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_cmp_ring_put " "got completion descriptor 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4620 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 128 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_cmp_ring_put " "got completion descriptor 0x%lx" "\n", addr);
#line 4624 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_cmp_ring_put(unsigned long addr)
{
    if (true) {
        _nocheck__trace_pvscsi_cmp_ring_put(addr);
    }
}

#define TRACE_PVSCSI_MSG_RING_PUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_MSG_RING_PUT) || \
    false)

static inline void _nocheck__trace_pvscsi_msg_ring_put(unsigned long addr)
{
    if (trace_event_get_state(TRACE_PVSCSI_MSG_RING_PUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 129 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_msg_ring_put " "got message descriptor 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4651 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 129 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_msg_ring_put " "got message descriptor 0x%lx" "\n", addr);
#line 4655 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_msg_ring_put(unsigned long addr)
{
    if (true) {
        _nocheck__trace_pvscsi_msg_ring_put(addr);
    }
}

#define TRACE_PVSCSI_COMPLETE_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_COMPLETE_REQUEST) || \
    false)

static inline void _nocheck__trace_pvscsi_complete_request(uint64_t context, uint64_t len, uint8_t sense_key)
{
    if (trace_event_get_state(TRACE_PVSCSI_COMPLETE_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 130 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_complete_request " "completion: ctx: 0x%"PRIx64", len: 0x%"PRIx64", sense key: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , context, len, sense_key);
#line 4682 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 130 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_complete_request " "completion: ctx: 0x%"PRIx64", len: 0x%"PRIx64", sense key: %u" "\n", context, len, sense_key);
#line 4686 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_complete_request(uint64_t context, uint64_t len, uint8_t sense_key)
{
    if (true) {
        _nocheck__trace_pvscsi_complete_request(context, len, sense_key);
    }
}

#define TRACE_PVSCSI_GET_SG_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_GET_SG_LIST) || \
    false)

static inline void _nocheck__trace_pvscsi_get_sg_list(int nsg, size_t size)
{
    if (trace_event_get_state(TRACE_PVSCSI_GET_SG_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_get_sg_list " "get SG list: depth: %u, size: %zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nsg, size);
#line 4713 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 131 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_get_sg_list " "get SG list: depth: %u, size: %zu" "\n", nsg, size);
#line 4717 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_get_sg_list(int nsg, size_t size)
{
    if (true) {
        _nocheck__trace_pvscsi_get_sg_list(nsg, size);
    }
}

#define TRACE_PVSCSI_GET_NEXT_SG_ELEM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_GET_NEXT_SG_ELEM) || \
    false)

static inline void _nocheck__trace_pvscsi_get_next_sg_elem(uint32_t flags)
{
    if (trace_event_get_state(TRACE_PVSCSI_GET_NEXT_SG_ELEM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 132 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_get_next_sg_elem " "unknown flags in SG element (val: 0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , flags);
#line 4744 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 132 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_get_next_sg_elem " "unknown flags in SG element (val: 0x%x)" "\n", flags);
#line 4748 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_get_next_sg_elem(uint32_t flags)
{
    if (true) {
        _nocheck__trace_pvscsi_get_next_sg_elem(flags);
    }
}

#define TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND) || \
    false)

static inline void _nocheck__trace_pvscsi_command_complete_not_found(uint32_t tag)
{
    if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 133 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_command_complete_not_found " "can't find request for tag 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 4775 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 133 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_command_complete_not_found " "can't find request for tag 0x%x" "\n", tag);
#line 4779 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_command_complete_not_found(uint32_t tag)
{
    if (true) {
        _nocheck__trace_pvscsi_command_complete_not_found(tag);
    }
}

#define TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN) || \
    false)

static inline void _nocheck__trace_pvscsi_command_complete_data_run(void)
{
    if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_command_complete_data_run " "not all data required for command transferred" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4806 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 134 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_command_complete_data_run " "not all data required for command transferred" "\n");
#line 4810 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_command_complete_data_run(void)
{
    if (true) {
        _nocheck__trace_pvscsi_command_complete_data_run();
    }
}

#define TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN) || \
    false)

static inline void _nocheck__trace_pvscsi_command_complete_sense_len(int len)
{
    if (trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_command_complete_sense_len " "sense information length is %d bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len);
#line 4837 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 135 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_command_complete_sense_len " "sense information length is %d bytes" "\n", len);
#line 4841 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_command_complete_sense_len(int len)
{
    if (true) {
        _nocheck__trace_pvscsi_command_complete_sense_len(len);
    }
}

#define TRACE_PVSCSI_CONVERT_SGLIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_CONVERT_SGLIST) || \
    false)

static inline void _nocheck__trace_pvscsi_convert_sglist(uint64_t context, unsigned long addr, uint32_t resid)
{
    if (trace_event_get_state(TRACE_PVSCSI_CONVERT_SGLIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_convert_sglist " "element: ctx: 0x%"PRIx64" addr: 0x%lx, len: %ul" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , context, addr, resid);
#line 4868 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 136 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_convert_sglist " "element: ctx: 0x%"PRIx64" addr: 0x%lx, len: %ul" "\n", context, addr, resid);
#line 4872 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_convert_sglist(uint64_t context, unsigned long addr, uint32_t resid)
{
    if (true) {
        _nocheck__trace_pvscsi_convert_sglist(context, addr, resid);
    }
}

#define TRACE_PVSCSI_PROCESS_REQ_DESCR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_PROCESS_REQ_DESCR) || \
    false)

static inline void _nocheck__trace_pvscsi_process_req_descr(uint8_t cmd, uint64_t ctx)
{
    if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_process_req_descr " "SCSI cmd 0x%x, ctx: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, ctx);
#line 4899 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 137 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_process_req_descr " "SCSI cmd 0x%x, ctx: 0x%"PRIx64 "\n", cmd, ctx);
#line 4903 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_process_req_descr(uint8_t cmd, uint64_t ctx)
{
    if (true) {
        _nocheck__trace_pvscsi_process_req_descr(cmd, ctx);
    }
}

#define TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE) || \
    false)

static inline void _nocheck__trace_pvscsi_process_req_descr_unknown_device(void)
{
    if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_process_req_descr_unknown_device " "command directed to unknown device rejected" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4930 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 138 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_process_req_descr_unknown_device " "command directed to unknown device rejected" "\n");
#line 4934 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_process_req_descr_unknown_device(void)
{
    if (true) {
        _nocheck__trace_pvscsi_process_req_descr_unknown_device();
    }
}

#define TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR) || \
    false)

static inline void _nocheck__trace_pvscsi_process_req_descr_invalid_dir(void)
{
    if (trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_process_req_descr_invalid_dir " "command with invalid transfer direction rejected" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4961 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 139 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_process_req_descr_invalid_dir " "command with invalid transfer direction rejected" "\n");
#line 4965 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_process_req_descr_invalid_dir(void)
{
    if (true) {
        _nocheck__trace_pvscsi_process_req_descr_invalid_dir();
    }
}

#define TRACE_PVSCSI_PROCESS_IO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_PROCESS_IO) || \
    false)

static inline void _nocheck__trace_pvscsi_process_io(unsigned long addr)
{
    if (trace_event_get_state(TRACE_PVSCSI_PROCESS_IO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_process_io " "got descriptor 0x%lx" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 4992 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 140 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_process_io " "got descriptor 0x%lx" "\n", addr);
#line 4996 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_process_io(unsigned long addr)
{
    if (true) {
        _nocheck__trace_pvscsi_process_io(addr);
    }
}

#define TRACE_PVSCSI_ON_CMD_NOIMPL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_NOIMPL) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_noimpl(const char* cmd)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_NOIMPL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_noimpl " "unimplemented command %s ignored" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd);
#line 5023 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 141 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_noimpl " "unimplemented command %s ignored" "\n", cmd);
#line 5027 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_noimpl(const char* cmd)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_noimpl(cmd);
    }
}

#define TRACE_PVSCSI_ON_CMD_RESET_DEV_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_RESET_DEV) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_reset_dev(uint32_t tgt, int lun, void* dev)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_RESET_DEV) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_reset_dev " "PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tgt, lun, dev);
#line 5054 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 142 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_reset_dev " "PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]" "\n", tgt, lun, dev);
#line 5058 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_reset_dev(uint32_t tgt, int lun, void* dev)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_reset_dev(tgt, lun, dev);
    }
}

#define TRACE_PVSCSI_ON_CMD_ARRIVED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_ARRIVED) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_arrived(const char* cmd)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_ARRIVED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_arrived " "command %s arrived" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd);
#line 5085 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 143 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_arrived " "command %s arrived" "\n", cmd);
#line 5089 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_arrived(const char* cmd)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_arrived(cmd);
    }
}

#define TRACE_PVSCSI_ON_CMD_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_ABORT) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_abort(uint64_t ctx, uint32_t tgt)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_abort " "command PVSCSI_CMD_ABORT_CMD for ctx 0x%"PRIx64", target %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, tgt);
#line 5116 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 144 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_abort " "command PVSCSI_CMD_ABORT_CMD for ctx 0x%"PRIx64", target %u" "\n", ctx, tgt);
#line 5120 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_abort(uint64_t ctx, uint32_t tgt)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_abort(ctx, tgt);
    }
}

#define TRACE_PVSCSI_ON_CMD_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_unknown(uint64_t cmd_id)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_unknown " "unknown command 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd_id);
#line 5147 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 145 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_unknown " "unknown command 0x%"PRIx64 "\n", cmd_id);
#line 5151 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_unknown(uint64_t cmd_id)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_unknown(cmd_id);
    }
}

#define TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA) || \
    false)

static inline void _nocheck__trace_pvscsi_on_cmd_unknown_data(uint32_t data)
{
    if (trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 146 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_on_cmd_unknown_data " "data for unknown command 0x:0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 5178 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 146 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_on_cmd_unknown_data " "data for unknown command 0x:0x%x" "\n", data);
#line 5182 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_on_cmd_unknown_data(uint32_t data)
{
    if (true) {
        _nocheck__trace_pvscsi_on_cmd_unknown_data(data);
    }
}

#define TRACE_PVSCSI_IO_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_IO_WRITE) || \
    false)

static inline void _nocheck__trace_pvscsi_io_write(const char* cmd, uint64_t val)
{
    if (trace_event_get_state(TRACE_PVSCSI_IO_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 147 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_io_write " "%s write: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, val);
#line 5209 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 147 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_io_write " "%s write: 0x%"PRIx64 "\n", cmd, val);
#line 5213 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_io_write(const char* cmd, uint64_t val)
{
    if (true) {
        _nocheck__trace_pvscsi_io_write(cmd, val);
    }
}

#define TRACE_PVSCSI_IO_WRITE_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_IO_WRITE_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pvscsi_io_write_unknown(unsigned long addr, unsigned sz, uint64_t val)
{
    if (trace_event_get_state(TRACE_PVSCSI_IO_WRITE_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_io_write_unknown " "unknown write address: 0x%lx size: %u bytes value: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, sz, val);
#line 5240 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 148 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_io_write_unknown " "unknown write address: 0x%lx size: %u bytes value: 0x%"PRIx64 "\n", addr, sz, val);
#line 5244 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_io_write_unknown(unsigned long addr, unsigned sz, uint64_t val)
{
    if (true) {
        _nocheck__trace_pvscsi_io_write_unknown(addr, sz, val);
    }
}

#define TRACE_PVSCSI_IO_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_IO_READ) || \
    false)

static inline void _nocheck__trace_pvscsi_io_read(const char* cmd, uint64_t status)
{
    if (trace_event_get_state(TRACE_PVSCSI_IO_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_io_read " "%s read: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, status);
#line 5271 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 149 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_io_read " "%s read: 0x%"PRIx64 "\n", cmd, status);
#line 5275 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_io_read(const char* cmd, uint64_t status)
{
    if (true) {
        _nocheck__trace_pvscsi_io_read(cmd, status);
    }
}

#define TRACE_PVSCSI_IO_READ_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_IO_READ_UNKNOWN) || \
    false)

static inline void _nocheck__trace_pvscsi_io_read_unknown(unsigned long addr, unsigned sz)
{
    if (trace_event_get_state(TRACE_PVSCSI_IO_READ_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_io_read_unknown " "unknown read address: 0x%lx size: %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, sz);
#line 5302 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 150 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_io_read_unknown " "unknown read address: 0x%lx size: %u bytes" "\n", addr, sz);
#line 5306 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_io_read_unknown(unsigned long addr, unsigned sz)
{
    if (true) {
        _nocheck__trace_pvscsi_io_read_unknown(addr, sz);
    }
}

#define TRACE_PVSCSI_INIT_MSI_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_INIT_MSI_FAIL) || \
    false)

static inline void _nocheck__trace_pvscsi_init_msi_fail(int res)
{
    if (trace_event_get_state(TRACE_PVSCSI_INIT_MSI_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_init_msi_fail " "failed to initialize MSI, error %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , res);
#line 5333 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 151 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_init_msi_fail " "failed to initialize MSI, error %d" "\n", res);
#line 5337 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_init_msi_fail(int res)
{
    if (true) {
        _nocheck__trace_pvscsi_init_msi_fail(res);
    }
}

#define TRACE_PVSCSI_STATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_STATE) || \
    false)

static inline void _nocheck__trace_pvscsi_state(const char* state)
{
    if (trace_event_get_state(TRACE_PVSCSI_STATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_state " "starting %s ..." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state);
#line 5364 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 152 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_state " "starting %s ..." "\n", state);
#line 5368 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_state(const char* state)
{
    if (true) {
        _nocheck__trace_pvscsi_state(state);
    }
}

#define TRACE_PVSCSI_TX_RINGS_PPN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_TX_RINGS_PPN) || \
    false)

static inline void _nocheck__trace_pvscsi_tx_rings_ppn(const char* label, uint64_t ppn)
{
    if (trace_event_get_state(TRACE_PVSCSI_TX_RINGS_PPN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_tx_rings_ppn " "%s page: 0x%"PRIx64 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , label, ppn);
#line 5395 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 153 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_tx_rings_ppn " "%s page: 0x%"PRIx64 "\n", label, ppn);
#line 5399 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_tx_rings_ppn(const char* label, uint64_t ppn)
{
    if (true) {
        _nocheck__trace_pvscsi_tx_rings_ppn(label, ppn);
    }
}

#define TRACE_PVSCSI_TX_RINGS_NUM_PAGES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PVSCSI_TX_RINGS_NUM_PAGES) || \
    false)

static inline void _nocheck__trace_pvscsi_tx_rings_num_pages(const char* label, uint32_t num)
{
    if (trace_event_get_state(TRACE_PVSCSI_TX_RINGS_NUM_PAGES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:pvscsi_tx_rings_num_pages " "Number of %s pages: %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , label, num);
#line 5426 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 154 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("pvscsi_tx_rings_num_pages " "Number of %s pages: %u" "\n", label, num);
#line 5430 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_pvscsi_tx_rings_num_pages(const char* label, uint32_t num)
{
    if (true) {
        _nocheck__trace_pvscsi_tx_rings_num_pages(label, num);
    }
}

#define TRACE_ESP_ERROR_FIFO_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_ERROR_FIFO_OVERRUN) || \
    false)

static inline void _nocheck__trace_esp_error_fifo_overrun(void)
{
    if (trace_event_get_state(TRACE_ESP_ERROR_FIFO_OVERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_error_fifo_overrun " "FIFO overrun" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5457 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 157 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_error_fifo_overrun " "FIFO overrun" "\n");
#line 5461 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_error_fifo_overrun(void)
{
    if (true) {
        _nocheck__trace_esp_error_fifo_overrun();
    }
}

#define TRACE_ESP_ERROR_UNHANDLED_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_ERROR_UNHANDLED_COMMAND) || \
    false)

static inline void _nocheck__trace_esp_error_unhandled_command(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_ERROR_UNHANDLED_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_error_unhandled_command " "unhandled command (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 5488 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 158 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_error_unhandled_command " "unhandled command (0x%2.2x)" "\n", val);
#line 5492 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_error_unhandled_command(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_error_unhandled_command(val);
    }
}

#define TRACE_ESP_ERROR_INVALID_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_ERROR_INVALID_WRITE) || \
    false)

static inline void _nocheck__trace_esp_error_invalid_write(uint32_t val, uint32_t addr)
{
    if (trace_event_get_state(TRACE_ESP_ERROR_INVALID_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_error_invalid_write " "invalid write of 0x%02x at [0x%x]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val, addr);
#line 5519 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 159 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_error_invalid_write " "invalid write of 0x%02x at [0x%x]" "\n", val, addr);
#line 5523 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_error_invalid_write(uint32_t val, uint32_t addr)
{
    if (true) {
        _nocheck__trace_esp_error_invalid_write(val, addr);
    }
}

#define TRACE_ESP_RAISE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_RAISE_IRQ) || \
    false)

static inline void _nocheck__trace_esp_raise_irq(void)
{
    if (trace_event_get_state(TRACE_ESP_RAISE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 160 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_raise_irq " "Raise IRQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5550 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 160 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_raise_irq " "Raise IRQ" "\n");
#line 5554 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_raise_irq(void)
{
    if (true) {
        _nocheck__trace_esp_raise_irq();
    }
}

#define TRACE_ESP_LOWER_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_LOWER_IRQ) || \
    false)

static inline void _nocheck__trace_esp_lower_irq(void)
{
    if (trace_event_get_state(TRACE_ESP_LOWER_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 161 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_lower_irq " "Lower IRQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5581 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 161 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_lower_irq " "Lower IRQ" "\n");
#line 5585 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_lower_irq(void)
{
    if (true) {
        _nocheck__trace_esp_lower_irq();
    }
}

#define TRACE_ESP_RAISE_DRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_RAISE_DRQ) || \
    false)

static inline void _nocheck__trace_esp_raise_drq(void)
{
    if (trace_event_get_state(TRACE_ESP_RAISE_DRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 162 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_raise_drq " "Raise DREQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5612 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 162 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_raise_drq " "Raise DREQ" "\n");
#line 5616 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_raise_drq(void)
{
    if (true) {
        _nocheck__trace_esp_raise_drq();
    }
}

#define TRACE_ESP_LOWER_DRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_LOWER_DRQ) || \
    false)

static inline void _nocheck__trace_esp_lower_drq(void)
{
    if (trace_event_get_state(TRACE_ESP_LOWER_DRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 163 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_lower_drq " "Lower DREQ" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5643 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 163 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_lower_drq " "Lower DREQ" "\n");
#line 5647 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_lower_drq(void)
{
    if (true) {
        _nocheck__trace_esp_lower_drq();
    }
}

#define TRACE_ESP_DMA_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_DMA_ENABLE) || \
    false)

static inline void _nocheck__trace_esp_dma_enable(void)
{
    if (trace_event_get_state(TRACE_ESP_DMA_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 164 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_dma_enable " "Raise enable" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5674 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 164 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_dma_enable " "Raise enable" "\n");
#line 5678 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_dma_enable(void)
{
    if (true) {
        _nocheck__trace_esp_dma_enable();
    }
}

#define TRACE_ESP_DMA_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_DMA_DISABLE) || \
    false)

static inline void _nocheck__trace_esp_dma_disable(void)
{
    if (trace_event_get_state(TRACE_ESP_DMA_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 165 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_dma_disable " "Lower enable" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5705 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 165 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_dma_disable " "Lower enable" "\n");
#line 5709 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_dma_disable(void)
{
    if (true) {
        _nocheck__trace_esp_dma_disable();
    }
}

#define TRACE_ESP_PDMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PDMA_READ) || \
    false)

static inline void _nocheck__trace_esp_pdma_read(int size)
{
    if (trace_event_get_state(TRACE_ESP_PDMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 166 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pdma_read " "pDMA read %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 5736 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 166 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pdma_read " "pDMA read %u bytes" "\n", size);
#line 5740 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pdma_read(int size)
{
    if (true) {
        _nocheck__trace_esp_pdma_read(size);
    }
}

#define TRACE_ESP_PDMA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PDMA_WRITE) || \
    false)

static inline void _nocheck__trace_esp_pdma_write(int size)
{
    if (trace_event_get_state(TRACE_ESP_PDMA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 167 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pdma_write " "pDMA write %u bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 5767 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 167 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pdma_write " "pDMA write %u bytes" "\n", size);
#line 5771 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pdma_write(int size)
{
    if (true) {
        _nocheck__trace_esp_pdma_write(size);
    }
}

#define TRACE_ESP_GET_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_GET_CMD) || \
    false)

static inline void _nocheck__trace_esp_get_cmd(uint32_t dmalen, int target)
{
    if (trace_event_get_state(TRACE_ESP_GET_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 168 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_get_cmd " "len %d target %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dmalen, target);
#line 5798 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 168 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_get_cmd " "len %d target %d" "\n", dmalen, target);
#line 5802 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_get_cmd(uint32_t dmalen, int target)
{
    if (true) {
        _nocheck__trace_esp_get_cmd(dmalen, target);
    }
}

#define TRACE_ESP_DO_COMMAND_PHASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_DO_COMMAND_PHASE) || \
    false)

static inline void _nocheck__trace_esp_do_command_phase(uint8_t busid)
{
    if (trace_event_get_state(TRACE_ESP_DO_COMMAND_PHASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 169 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_do_command_phase " "busid 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , busid);
#line 5829 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 169 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_do_command_phase " "busid 0x%x" "\n", busid);
#line 5833 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_do_command_phase(uint8_t busid)
{
    if (true) {
        _nocheck__trace_esp_do_command_phase(busid);
    }
}

#define TRACE_ESP_DO_IDENTIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_DO_IDENTIFY) || \
    false)

static inline void _nocheck__trace_esp_do_identify(uint8_t byte)
{
    if (trace_event_get_state(TRACE_ESP_DO_IDENTIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 170 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_do_identify " "0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , byte);
#line 5860 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 170 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_do_identify " "0x%x" "\n", byte);
#line 5864 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_do_identify(uint8_t byte)
{
    if (true) {
        _nocheck__trace_esp_do_identify(byte);
    }
}

#define TRACE_ESP_HANDLE_SATN_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_HANDLE_SATN_STOP) || \
    false)

static inline void _nocheck__trace_esp_handle_satn_stop(uint32_t cmdlen)
{
    if (trace_event_get_state(TRACE_ESP_HANDLE_SATN_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 171 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_handle_satn_stop " "cmdlen %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmdlen);
#line 5891 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 171 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_handle_satn_stop " "cmdlen %d" "\n", cmdlen);
#line 5895 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_handle_satn_stop(uint32_t cmdlen)
{
    if (true) {
        _nocheck__trace_esp_handle_satn_stop(cmdlen);
    }
}

#define TRACE_ESP_WRITE_RESPONSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_WRITE_RESPONSE) || \
    false)

static inline void _nocheck__trace_esp_write_response(uint32_t status)
{
    if (trace_event_get_state(TRACE_ESP_WRITE_RESPONSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 172 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_write_response " "Transfer status (status=%d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 5922 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 172 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_write_response " "Transfer status (status=%d)" "\n", status);
#line 5926 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_write_response(uint32_t status)
{
    if (true) {
        _nocheck__trace_esp_write_response(status);
    }
}

#define TRACE_ESP_DO_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_DO_DMA) || \
    false)

static inline void _nocheck__trace_esp_do_dma(uint32_t cmdlen, uint32_t len)
{
    if (trace_event_get_state(TRACE_ESP_DO_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 173 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_do_dma " "command len %d + %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmdlen, len);
#line 5953 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 173 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_do_dma " "command len %d + %d" "\n", cmdlen, len);
#line 5957 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_do_dma(uint32_t cmdlen, uint32_t len)
{
    if (true) {
        _nocheck__trace_esp_do_dma(cmdlen, len);
    }
}

#define TRACE_ESP_COMMAND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_COMMAND_COMPLETE) || \
    false)

static inline void _nocheck__trace_esp_command_complete(void)
{
    if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 174 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_command_complete " "SCSI Command complete" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 5984 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 174 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_command_complete " "SCSI Command complete" "\n");
#line 5988 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_command_complete(void)
{
    if (true) {
        _nocheck__trace_esp_command_complete();
    }
}

#define TRACE_ESP_COMMAND_COMPLETE_DEFERRED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_COMMAND_COMPLETE_DEFERRED) || \
    false)

static inline void _nocheck__trace_esp_command_complete_deferred(void)
{
    if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_DEFERRED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 175 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_command_complete_deferred " "SCSI Command complete deferred" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6015 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 175 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_command_complete_deferred " "SCSI Command complete deferred" "\n");
#line 6019 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_command_complete_deferred(void)
{
    if (true) {
        _nocheck__trace_esp_command_complete_deferred();
    }
}

#define TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED) || \
    false)

static inline void _nocheck__trace_esp_command_complete_unexpected(void)
{
    if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 176 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_command_complete_unexpected " "SCSI command completed unexpectedly" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6046 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 176 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_command_complete_unexpected " "SCSI command completed unexpectedly" "\n");
#line 6050 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_command_complete_unexpected(void)
{
    if (true) {
        _nocheck__trace_esp_command_complete_unexpected();
    }
}

#define TRACE_ESP_COMMAND_COMPLETE_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_COMMAND_COMPLETE_FAIL) || \
    false)

static inline void _nocheck__trace_esp_command_complete_fail(void)
{
    if (trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 177 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_command_complete_fail " "Command failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6077 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 177 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_command_complete_fail " "Command failed" "\n");
#line 6081 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_command_complete_fail(void)
{
    if (true) {
        _nocheck__trace_esp_command_complete_fail();
    }
}

#define TRACE_ESP_TRANSFER_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_TRANSFER_DATA) || \
    false)

static inline void _nocheck__trace_esp_transfer_data(uint32_t dma_left, int32_t ti_size)
{
    if (trace_event_get_state(TRACE_ESP_TRANSFER_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 178 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_transfer_data " "transfer %d/%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dma_left, ti_size);
#line 6108 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 178 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_transfer_data " "transfer %d/%d" "\n", dma_left, ti_size);
#line 6112 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_transfer_data(uint32_t dma_left, int32_t ti_size)
{
    if (true) {
        _nocheck__trace_esp_transfer_data(dma_left, ti_size);
    }
}

#define TRACE_ESP_HANDLE_TI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_HANDLE_TI) || \
    false)

static inline void _nocheck__trace_esp_handle_ti(uint32_t minlen)
{
    if (trace_event_get_state(TRACE_ESP_HANDLE_TI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 179 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_handle_ti " "Transfer Information len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , minlen);
#line 6139 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 179 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_handle_ti " "Transfer Information len %d" "\n", minlen);
#line 6143 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_handle_ti(uint32_t minlen)
{
    if (true) {
        _nocheck__trace_esp_handle_ti(minlen);
    }
}

#define TRACE_ESP_HANDLE_TI_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_HANDLE_TI_CMD) || \
    false)

static inline void _nocheck__trace_esp_handle_ti_cmd(uint32_t cmdlen)
{
    if (trace_event_get_state(TRACE_ESP_HANDLE_TI_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 180 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_handle_ti_cmd " "command len %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmdlen);
#line 6170 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 180 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_handle_ti_cmd " "command len %d" "\n", cmdlen);
#line 6174 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_handle_ti_cmd(uint32_t cmdlen)
{
    if (true) {
        _nocheck__trace_esp_handle_ti_cmd(cmdlen);
    }
}

#define TRACE_ESP_MEM_READB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_READB) || \
    false)

static inline void _nocheck__trace_esp_mem_readb(uint32_t saddr, uint8_t reg)
{
    if (trace_event_get_state(TRACE_ESP_MEM_READB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 181 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_readb " "reg[%d]: 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , saddr, reg);
#line 6201 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 181 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_readb " "reg[%d]: 0x%2.2x" "\n", saddr, reg);
#line 6205 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_readb(uint32_t saddr, uint8_t reg)
{
    if (true) {
        _nocheck__trace_esp_mem_readb(saddr, reg);
    }
}

#define TRACE_ESP_MEM_WRITEB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb(uint32_t saddr, uint8_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 182 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb " "reg[%d]: 0x%2.2x -> 0x%2.2x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , saddr, reg, val);
#line 6232 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 182 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb " "reg[%d]: 0x%2.2x -> 0x%2.2x" "\n", saddr, reg, val);
#line 6236 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb(uint32_t saddr, uint8_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb(saddr, reg, val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_NOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_NOP) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_nop(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_NOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 183 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_nop " "NOP (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6263 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 183 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_nop " "NOP (0x%2.2x)" "\n", val);
#line 6267 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_nop(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_nop(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_FLUSH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_FLUSH) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_flush(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_FLUSH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 184 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_flush " "Flush FIFO (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6294 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 184 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_flush " "Flush FIFO (0x%2.2x)" "\n", val);
#line 6298 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_flush(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_flush(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_RESET) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_reset(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 185 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_reset " "Chip reset (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6325 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 185 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_reset " "Chip reset (0x%2.2x)" "\n", val);
#line 6329 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_reset(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_reset(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_bus_reset(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 186 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_bus_reset " "Bus reset (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6356 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 186 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_bus_reset " "Bus reset (0x%2.2x)" "\n", val);
#line 6360 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_bus_reset(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_bus_reset(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_ICCS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_ICCS) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_iccs(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ICCS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 187 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_iccs " "Initiator Command Complete Sequence (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6387 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 187 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_iccs " "Initiator Command Complete Sequence (0x%2.2x)" "\n", val);
#line 6391 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_iccs(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_iccs(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_MSGACC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_MSGACC) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_msgacc(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_MSGACC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 188 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_msgacc " "Message Accepted (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6418 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 188 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_msgacc " "Message Accepted (0x%2.2x)" "\n", val);
#line 6422 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_msgacc(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_msgacc(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_PAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_PAD) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_pad(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_PAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 189 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_pad " "Transfer padding (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6449 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 189 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_pad " "Transfer padding (0x%2.2x)" "\n", val);
#line 6453 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_pad(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_pad(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_SATN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_SATN) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_satn(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SATN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 190 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_satn " "Set ATN (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6480 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 190 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_satn " "Set ATN (0x%2.2x)" "\n", val);
#line 6484 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_satn(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_satn(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_RSTATN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_RSTATN) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_rstatn(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RSTATN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 191 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_rstatn " "Reset ATN (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6511 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 191 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_rstatn " "Reset ATN (0x%2.2x)" "\n", val);
#line 6515 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_rstatn(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_rstatn(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_SEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_SEL) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_sel(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 192 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_sel " "Select without ATN (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6542 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 192 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_sel " "Select without ATN (0x%2.2x)" "\n", val);
#line 6546 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_sel(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_sel(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_SELATN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_SELATN) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_selatn(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 193 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_selatn " "Select with ATN (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6573 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 193 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_selatn " "Select with ATN (0x%2.2x)" "\n", val);
#line 6577 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_selatn(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_selatn(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_SELATNS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_SELATNS) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_selatns(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATNS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 194 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_selatns " "Select with ATN & stop (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6604 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 194 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_selatns " "Select with ATN & stop (0x%2.2x)" "\n", val);
#line 6608 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_selatns(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_selatns(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_ENSEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_ENSEL) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_ensel(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ENSEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 195 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_ensel " "Enable selection (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6635 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 195 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_ensel " "Enable selection (0x%2.2x)" "\n", val);
#line 6639 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_ensel(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_ensel(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_DISSEL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_DISSEL) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_dissel(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_DISSEL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 196 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_dissel " "Disable selection (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6666 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 196 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_dissel " "Disable selection (0x%2.2x)" "\n", val);
#line 6670 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_dissel(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_dissel(val);
    }
}

#define TRACE_ESP_MEM_WRITEB_CMD_TI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_MEM_WRITEB_CMD_TI) || \
    false)

static inline void _nocheck__trace_esp_mem_writeb_cmd_ti(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_TI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 197 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_mem_writeb_cmd_ti " "Transfer Information (0x%2.2x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6697 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 197 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_mem_writeb_cmd_ti " "Transfer Information (0x%2.2x)" "\n", val);
#line 6701 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_mem_writeb_cmd_ti(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_mem_writeb_cmd_ti(val);
    }
}

#define TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION) || \
    false)

static inline void _nocheck__trace_esp_pci_error_invalid_dma_direction(void)
{
    if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 200 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_error_invalid_dma_direction " "invalid DMA transfer direction" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 6728 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 200 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_error_invalid_dma_direction " "invalid DMA transfer direction" "\n");
#line 6732 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_error_invalid_dma_direction(void)
{
    if (true) {
        _nocheck__trace_esp_pci_error_invalid_dma_direction();
    }
}

#define TRACE_ESP_PCI_ERROR_INVALID_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_ERROR_INVALID_READ) || \
    false)

static inline void _nocheck__trace_esp_pci_error_invalid_read(uint32_t reg)
{
    if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 201 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_error_invalid_read " "read access outside bounds (reg 0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 6759 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 201 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_error_invalid_read " "read access outside bounds (reg 0x%x)" "\n", reg);
#line 6763 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_error_invalid_read(uint32_t reg)
{
    if (true) {
        _nocheck__trace_esp_pci_error_invalid_read(reg);
    }
}

#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_ERROR_INVALID_WRITE) || \
    false)

static inline void _nocheck__trace_esp_pci_error_invalid_write(uint32_t reg)
{
    if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 202 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_error_invalid_write " "write access outside bounds (reg 0x%x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 6790 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 202 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_error_invalid_write " "write access outside bounds (reg 0x%x)" "\n", reg);
#line 6794 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_error_invalid_write(uint32_t reg)
{
    if (true) {
        _nocheck__trace_esp_pci_error_invalid_write(reg);
    }
}

#define TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA) || \
    false)

static inline void _nocheck__trace_esp_pci_error_invalid_write_dma(uint32_t val, uint32_t addr)
{
    if (trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 203 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_error_invalid_write_dma " "invalid write of 0x%02x at [0x%x]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val, addr);
#line 6821 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 203 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_error_invalid_write_dma " "invalid write of 0x%02x at [0x%x]" "\n", val, addr);
#line 6825 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_error_invalid_write_dma(uint32_t val, uint32_t addr)
{
    if (true) {
        _nocheck__trace_esp_pci_error_invalid_write_dma(val, addr);
    }
}

#define TRACE_ESP_PCI_DMA_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_READ) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_read(uint32_t saddr, uint32_t reg)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 204 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_read " "reg[%d]: 0x%8.8x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , saddr, reg);
#line 6852 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 204 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_read " "reg[%d]: 0x%8.8x" "\n", saddr, reg);
#line 6856 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_read(uint32_t saddr, uint32_t reg)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_read(saddr, reg);
    }
}

#define TRACE_ESP_PCI_DMA_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_WRITE) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_write(uint32_t saddr, uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 205 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_write " "reg[%d]: 0x%8.8x -> 0x%8.8x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , saddr, reg, val);
#line 6883 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 205 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_write " "reg[%d]: 0x%8.8x -> 0x%8.8x" "\n", saddr, reg, val);
#line 6887 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_write(uint32_t saddr, uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_write(saddr, reg, val);
    }
}

#define TRACE_ESP_PCI_DMA_IDLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_IDLE) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_idle(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_IDLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 206 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_idle " "IDLE (0x%.8x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6914 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 206 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_idle " "IDLE (0x%.8x)" "\n", val);
#line 6918 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_idle(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_idle(val);
    }
}

#define TRACE_ESP_PCI_DMA_BLAST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_BLAST) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_blast(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_BLAST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 207 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_blast " "BLAST (0x%.8x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6945 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 207 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_blast " "BLAST (0x%.8x)" "\n", val);
#line 6949 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_blast(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_blast(val);
    }
}

#define TRACE_ESP_PCI_DMA_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_ABORT) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_abort(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 208 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_abort " "ABORT (0x%.8x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 6976 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 208 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_abort " "ABORT (0x%.8x)" "\n", val);
#line 6980 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_abort(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_abort(val);
    }
}

#define TRACE_ESP_PCI_DMA_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_DMA_START) || \
    false)

static inline void _nocheck__trace_esp_pci_dma_start(uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_DMA_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 209 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_dma_start " "START (0x%.8x)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , val);
#line 7007 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 209 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_dma_start " "START (0x%.8x)" "\n", val);
#line 7011 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_dma_start(uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_dma_start(val);
    }
}

#define TRACE_ESP_PCI_SBAC_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_SBAC_READ) || \
    false)

static inline void _nocheck__trace_esp_pci_sbac_read(uint32_t reg)
{
    if (trace_event_get_state(TRACE_ESP_PCI_SBAC_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 210 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_sbac_read " "sbac: 0x%8.8x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg);
#line 7038 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 210 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_sbac_read " "sbac: 0x%8.8x" "\n", reg);
#line 7042 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_sbac_read(uint32_t reg)
{
    if (true) {
        _nocheck__trace_esp_pci_sbac_read(reg);
    }
}

#define TRACE_ESP_PCI_SBAC_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_ESP_PCI_SBAC_WRITE) || \
    false)

static inline void _nocheck__trace_esp_pci_sbac_write(uint32_t reg, uint32_t val)
{
    if (trace_event_get_state(TRACE_ESP_PCI_SBAC_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 211 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:esp_pci_sbac_write " "sbac: 0x%8.8x -> 0x%8.8x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, val);
#line 7069 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 211 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("esp_pci_sbac_write " "sbac: 0x%8.8x -> 0x%8.8x" "\n", reg, val);
#line 7073 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_esp_pci_sbac_write(uint32_t reg, uint32_t val)
{
    if (true) {
        _nocheck__trace_esp_pci_sbac_write(reg, val);
    }
}

#define TRACE_SPAPR_VSCSI_SEND_RSP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SEND_RSP) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_send_rsp(uint8_t status, int32_t res_in, int32_t res_out)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SEND_RSP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 214 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_send_rsp " "status: 0x%x, res_in: %"PRId32", res_out: %"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status, res_in, res_out);
#line 7100 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 214 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_send_rsp " "status: 0x%x, res_in: %"PRId32", res_out: %"PRId32 "\n", status, res_in, res_out);
#line 7104 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_send_rsp(uint8_t status, int32_t res_in, int32_t res_out)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_send_rsp(status, res_in, res_out);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_no_data(void)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_NO_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 215 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_no_data " "no data descriptor" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7131 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 215 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_no_data " "no data descriptor" "\n");
#line 7135 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_no_data(void)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_no_data();
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_direct(void)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 216 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_direct " "direct segment" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7162 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 216 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_direct " "direct segment" "\n");
#line 7166 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_direct(void)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_direct();
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_indirect(uint32_t qtag, unsigned desc, unsigned local_desc)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 217 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_indirect " "indirect segment local tag=0x%"PRIx32" desc#%u/%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qtag, desc, local_desc);
#line 7193 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 217 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_indirect " "indirect segment local tag=0x%"PRIx32" desc#%u/%u" "\n", qtag, desc, local_desc);
#line 7197 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_indirect(uint32_t qtag, unsigned desc, unsigned local_desc)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_indirect(qtag, desc, local_desc);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_out_of_range(unsigned desc, unsigned desc_offset)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_RANGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 218 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_out_of_range " "#%u is ouf of range (%u bytes)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc, desc_offset);
#line 7224 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 218 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_out_of_range " "#%u is ouf of range (%u bytes)" "\n", desc, desc_offset);
#line 7228 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_range(unsigned desc, unsigned desc_offset)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_out_of_range(desc, desc_offset);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_dma_read_error(int rc)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DMA_READ_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 219 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_dma_read_error " "spapr_vio_dma_read -> %d reading ext_desc" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , rc);
#line 7255 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 219 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_dma_read_error " "spapr_vio_dma_read -> %d reading ext_desc" "\n", rc);
#line 7259 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_dma_read_error(int rc)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_dma_read_error(rc);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_indirect_seg_ext(uint32_t qtag, unsigned n, unsigned desc, uint64_t va, uint32_t len)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_INDIRECT_SEG_EXT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 220 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_indirect_seg_ext " "indirect segment ext. tag=0x%"PRIx32" desc#%u/%u { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qtag, n, desc, va, len);
#line 7286 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 220 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_indirect_seg_ext " "indirect segment ext. tag=0x%"PRIx32" desc#%u/%u { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n", qtag, n, desc, va, len);
#line 7290 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_indirect_seg_ext(uint32_t qtag, unsigned n, unsigned desc, uint64_t va, uint32_t len)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_indirect_seg_ext(qtag, n, desc, va, len);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_out_of_desc(void)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 221 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_out_of_desc " "Out of descriptors !" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7317 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 221 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_out_of_desc " "Out of descriptors !" "\n");
#line 7321 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_desc(void)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_out_of_desc();
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_out_of_desc_boundary(unsigned offset, unsigned desc, uint32_t len)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_OUT_OF_DESC_BOUNDARY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 222 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_out_of_desc_boundary " "   offset=0x%x is out of a descriptor #%u boundary=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , offset, desc, len);
#line 7348 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 222 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_out_of_desc_boundary " "   offset=0x%x is out of a descriptor #%u boundary=0x%"PRIx32 "\n", offset, desc, len);
#line 7352 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_out_of_desc_boundary(unsigned offset, unsigned desc, uint32_t len)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_out_of_desc_boundary(offset, desc, len);
    }
}

#define TRACE_SPAPR_VSCSI_FETCH_DESC_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_FETCH_DESC_DONE) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_fetch_desc_done(unsigned desc_num, unsigned desc_offset, uint64_t va, uint32_t len)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_FETCH_DESC_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 223 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_fetch_desc_done " "   cur=%u offs=0x%x ret { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , desc_num, desc_offset, va, len);
#line 7379 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 223 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_fetch_desc_done " "   cur=%u offs=0x%x ret { va=0x%"PRIx64" len=0x%"PRIx32" }" "\n", desc_num, desc_offset, va, len);
#line 7383 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_fetch_desc_done(unsigned desc_num, unsigned desc_offset, uint64_t va, uint32_t len)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_fetch_desc_done(desc_num, desc_offset, va, len);
    }
}

#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_srp_indirect_data(uint32_t len)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 224 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_srp_indirect_data " "indirect segment 0x%"PRIx32" bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len);
#line 7410 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 224 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_srp_indirect_data " "indirect segment 0x%"PRIx32" bytes" "\n", len);
#line 7414 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data(uint32_t len)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_srp_indirect_data(len);
    }
}

#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_srp_indirect_data_rw(int writing, int rc)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_RW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 225 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_srp_indirect_data_rw " "spapr_vio_dma_r/w(%d) -> %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , writing, rc);
#line 7441 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 225 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_srp_indirect_data_rw " "spapr_vio_dma_r/w(%d) -> %d" "\n", writing, rc);
#line 7445 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data_rw(int writing, int rc)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_srp_indirect_data_rw(writing, rc);
    }
}

#define TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_srp_indirect_data_buf(unsigned a, unsigned b, unsigned c, unsigned d)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_INDIRECT_DATA_BUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 226 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_srp_indirect_data_buf " "     data: %02x %02x %02x %02x..." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , a, b, c, d);
#line 7472 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 226 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_srp_indirect_data_buf " "     data: %02x %02x %02x %02x..." "\n", a, b, c, d);
#line 7476 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_srp_indirect_data_buf(unsigned a, unsigned b, unsigned c, unsigned d)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_srp_indirect_data_buf(a, b, c, d);
    }
}

#define TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_srp_transfer_data(uint32_t len)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SRP_TRANSFER_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 227 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_srp_transfer_data " "no data desc transfer, skipping 0x%"PRIx32" bytes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len);
#line 7503 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 227 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_srp_transfer_data " "no data desc transfer, skipping 0x%"PRIx32" bytes" "\n", len);
#line 7507 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_srp_transfer_data(uint32_t len)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_srp_transfer_data(len);
    }
}

#define TRACE_SPAPR_VSCSI_TRANSFER_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_TRANSFER_DATA) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_transfer_data(uint32_t tag, uint32_t len, void * req)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_TRANSFER_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 228 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_transfer_data " "SCSI xfer complete tag=0x%"PRIx32" len=0x%"PRIx32", req=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, len, req);
#line 7534 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 228 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_transfer_data " "SCSI xfer complete tag=0x%"PRIx32" len=0x%"PRIx32", req=%p" "\n", tag, len, req);
#line 7538 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_transfer_data(uint32_t tag, uint32_t len, void * req)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_transfer_data(tag, len, req);
    }
}

#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_command_complete(uint32_t tag, uint32_t status, void * req)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 229 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_command_complete " "SCSI cmd complete, tag=0x%"PRIx32" status=0x%"PRIx32", req=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, status, req);
#line 7565 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 229 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_command_complete " "SCSI cmd complete, tag=0x%"PRIx32" status=0x%"PRIx32", req=%p" "\n", tag, status, req);
#line 7569 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_command_complete(uint32_t tag, uint32_t status, void * req)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_command_complete(tag, status, req);
    }
}

#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_command_complete_sense_data1(uint32_t len, unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned s4, unsigned s5, unsigned s6, unsigned s7)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA1) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 230 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_command_complete_sense_data1 " "Sense data, %d bytes: %02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , len, s0, s1, s2, s3, s4, s5, s6, s7);
#line 7596 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 230 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_command_complete_sense_data1 " "Sense data, %d bytes: %02x %02x %02x %02x %02x %02x %02x %02x" "\n", len, s0, s1, s2, s3, s4, s5, s6, s7);
#line 7600 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_sense_data1(uint32_t len, unsigned s0, unsigned s1, unsigned s2, unsigned s3, unsigned s4, unsigned s5, unsigned s6, unsigned s7)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_command_complete_sense_data1(len, s0, s1, s2, s3, s4, s5, s6, s7);
    }
}

#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_command_complete_sense_data2(unsigned s8, unsigned s9, unsigned s10, unsigned s11, unsigned s12, unsigned s13, unsigned s14, unsigned s15)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_SENSE_DATA2) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 231 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_command_complete_sense_data2 " "                      %02x %02x %02x %02x %02x %02x %02x %02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , s8, s9, s10, s11, s12, s13, s14, s15);
#line 7627 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 231 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_command_complete_sense_data2 " "                      %02x %02x %02x %02x %02x %02x %02x %02x" "\n", s8, s9, s10, s11, s12, s13, s14, s15);
#line 7631 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_sense_data2(unsigned s8, unsigned s9, unsigned s10, unsigned s11, unsigned s12, unsigned s13, unsigned s14, unsigned s15)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_command_complete_sense_data2(s8, s9, s10, s11, s12, s13, s14, s15);
    }
}

#define TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_command_complete_status(uint32_t status)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_COMMAND_COMPLETE_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 232 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_command_complete_status " "Command complete err=%"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 7658 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 232 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_command_complete_status " "Command complete err=%"PRIu32 "\n", status);
#line 7662 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_command_complete_status(uint32_t status)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_command_complete_status(status);
    }
}

#define TRACE_SPAPR_VSCSI_SAVE_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_SAVE_REQUEST) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_save_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_SAVE_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 233 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_save_request " "saving tag=%"PRIu32", current desc#%u, offset=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qtag, desc, offset);
#line 7689 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 233 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_save_request " "saving tag=%"PRIu32", current desc#%u, offset=0x%x" "\n", qtag, desc, offset);
#line 7693 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_save_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_save_request(qtag, desc, offset);
    }
}

#define TRACE_SPAPR_VSCSI_LOAD_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_LOAD_REQUEST) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_load_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_LOAD_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 234 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_load_request " "restoring tag=%"PRIu32", current desc#%u, offset=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qtag, desc, offset);
#line 7720 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 234 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_load_request " "restoring tag=%"PRIu32", current desc#%u, offset=0x%x" "\n", qtag, desc, offset);
#line 7724 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_load_request(uint32_t qtag, unsigned desc, unsigned offset)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_load_request(qtag, desc, offset);
    }
}

#define TRACE_SPAPR_VSCSI_PROCESS_LOGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_PROCESS_LOGIN) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_process_login(void)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_PROCESS_LOGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 235 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_process_login " "Got login, sending response !" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7751 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 235 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_process_login " "Got login, sending response !" "\n");
#line 7755 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_process_login(void)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_process_login();
    }
}

#define TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_process_tsk_mgmt(uint8_t func)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_PROCESS_TSK_MGMT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 236 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_process_tsk_mgmt " "tsk_mgmt_func 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , func);
#line 7782 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 236 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_process_tsk_mgmt " "tsk_mgmt_func 0x%02x" "\n", func);
#line 7786 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_process_tsk_mgmt(uint8_t func)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_process_tsk_mgmt(func);
    }
}

#define TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_queue_cmd_no_drive(uint64_t lun)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_QUEUE_CMD_NO_DRIVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 237 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_queue_cmd_no_drive " "Command for lun 0x%08" PRIx64 " with no drive" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun);
#line 7813 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 237 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_queue_cmd_no_drive " "Command for lun 0x%08" PRIx64 " with no drive" "\n", lun);
#line 7817 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_queue_cmd_no_drive(uint64_t lun)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_queue_cmd_no_drive(lun);
    }
}

#define TRACE_SPAPR_VSCSI_QUEUE_CMD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_QUEUE_CMD) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_queue_cmd(uint32_t qtag, unsigned cdb, const char * cmd, int lun, int ret)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_QUEUE_CMD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 238 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_queue_cmd " "Queued command tag 0x%"PRIx32" CMD 0x%x=%s LUN %d ret: %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qtag, cdb, cmd, lun, ret);
#line 7844 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 238 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_queue_cmd " "Queued command tag 0x%"PRIx32" CMD 0x%x=%s LUN %d ret: %d" "\n", qtag, cdb, cmd, lun, ret);
#line 7848 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_queue_cmd(uint32_t qtag, unsigned cdb, const char * cmd, int lun, int ret)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_queue_cmd(qtag, cdb, cmd, lun, ret);
    }
}

#define TRACE_SPAPR_VSCSI_DO_CRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SPAPR_VSCSI_DO_CRQ) || \
    false)

static inline void _nocheck__trace_spapr_vscsi_do_crq(unsigned c0, unsigned c1)
{
    if (trace_event_get_state(TRACE_SPAPR_VSCSI_DO_CRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 239 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:spapr_vscsi_do_crq " "crq: %02x %02x ..." "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , c0, c1);
#line 7875 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 239 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("spapr_vscsi_do_crq " "crq: %02x %02x ..." "\n", c0, c1);
#line 7879 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_spapr_vscsi_do_crq(unsigned c0, unsigned c1)
{
    if (true) {
        _nocheck__trace_spapr_vscsi_do_crq(c0, c1);
    }
}

#define TRACE_LSI_RESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_RESET) || \
    false)

static inline void _nocheck__trace_lsi_reset(void)
{
    if (trace_event_get_state(TRACE_LSI_RESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 242 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_reset " "Reset" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7906 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 242 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_reset " "Reset" "\n");
#line 7910 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_reset(void)
{
    if (true) {
        _nocheck__trace_lsi_reset();
    }
}

#define TRACE_LSI_UPDATE_IRQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_UPDATE_IRQ) || \
    false)

static inline void _nocheck__trace_lsi_update_irq(int level, uint8_t dstat, uint8_t sist1, uint8_t sist0)
{
    if (trace_event_get_state(TRACE_LSI_UPDATE_IRQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 243 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_update_irq " "Update IRQ level %d dstat 0x%02x sist 0x%02x0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , level, dstat, sist1, sist0);
#line 7937 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 243 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_update_irq " "Update IRQ level %d dstat 0x%02x sist 0x%02x0x%02x" "\n", level, dstat, sist1, sist0);
#line 7941 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_update_irq(int level, uint8_t dstat, uint8_t sist1, uint8_t sist0)
{
    if (true) {
        _nocheck__trace_lsi_update_irq(level, dstat, sist1, sist0);
    }
}

#define TRACE_LSI_UPDATE_IRQ_DISCONNECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_UPDATE_IRQ_DISCONNECTED) || \
    false)

static inline void _nocheck__trace_lsi_update_irq_disconnected(void)
{
    if (trace_event_get_state(TRACE_LSI_UPDATE_IRQ_DISCONNECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 244 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_update_irq_disconnected " "Handled IRQs & disconnected, looking for pending processes" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 7968 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 244 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_update_irq_disconnected " "Handled IRQs & disconnected, looking for pending processes" "\n");
#line 7972 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_update_irq_disconnected(void)
{
    if (true) {
        _nocheck__trace_lsi_update_irq_disconnected();
    }
}

#define TRACE_LSI_SCRIPT_SCSI_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_SCRIPT_SCSI_INTERRUPT) || \
    false)

static inline void _nocheck__trace_lsi_script_scsi_interrupt(uint8_t stat1, uint8_t stat0, uint8_t sist1, uint8_t sist0)
{
    if (trace_event_get_state(TRACE_LSI_SCRIPT_SCSI_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 245 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_script_scsi_interrupt " "SCSI Interrupt 0x%02x0x%02x prev 0x%02x0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stat1, stat0, sist1, sist0);
#line 7999 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 245 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_script_scsi_interrupt " "SCSI Interrupt 0x%02x0x%02x prev 0x%02x0x%02x" "\n", stat1, stat0, sist1, sist0);
#line 8003 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_script_scsi_interrupt(uint8_t stat1, uint8_t stat0, uint8_t sist1, uint8_t sist0)
{
    if (true) {
        _nocheck__trace_lsi_script_scsi_interrupt(stat1, stat0, sist1, sist0);
    }
}

#define TRACE_LSI_SCRIPT_DMA_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_SCRIPT_DMA_INTERRUPT) || \
    false)

static inline void _nocheck__trace_lsi_script_dma_interrupt(uint8_t stat, uint8_t dstat)
{
    if (trace_event_get_state(TRACE_LSI_SCRIPT_DMA_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 246 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_script_dma_interrupt " "DMA Interrupt 0x%x prev 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , stat, dstat);
#line 8030 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 246 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_script_dma_interrupt " "DMA Interrupt 0x%x prev 0x%x" "\n", stat, dstat);
#line 8034 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_script_dma_interrupt(uint8_t stat, uint8_t dstat)
{
    if (true) {
        _nocheck__trace_lsi_script_dma_interrupt(stat, dstat);
    }
}

#define TRACE_LSI_BAD_PHASE_JUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_BAD_PHASE_JUMP) || \
    false)

static inline void _nocheck__trace_lsi_bad_phase_jump(uint32_t dsp)
{
    if (trace_event_get_state(TRACE_LSI_BAD_PHASE_JUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 247 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_bad_phase_jump " "Data phase mismatch jump to 0x%"PRIX32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dsp);
#line 8061 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 247 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_bad_phase_jump " "Data phase mismatch jump to 0x%"PRIX32 "\n", dsp);
#line 8065 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_bad_phase_jump(uint32_t dsp)
{
    if (true) {
        _nocheck__trace_lsi_bad_phase_jump(dsp);
    }
}

#define TRACE_LSI_BAD_PHASE_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_BAD_PHASE_INTERRUPT) || \
    false)

static inline void _nocheck__trace_lsi_bad_phase_interrupt(void)
{
    if (trace_event_get_state(TRACE_LSI_BAD_PHASE_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 248 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_bad_phase_interrupt " "Phase mismatch interrupt" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8092 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 248 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_bad_phase_interrupt " "Phase mismatch interrupt" "\n");
#line 8096 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_bad_phase_interrupt(void)
{
    if (true) {
        _nocheck__trace_lsi_bad_phase_interrupt();
    }
}

#define TRACE_LSI_BAD_SELECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_BAD_SELECTION) || \
    false)

static inline void _nocheck__trace_lsi_bad_selection(uint32_t id)
{
    if (trace_event_get_state(TRACE_LSI_BAD_SELECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 249 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_bad_selection " "Selected absent target %"PRIu32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 8123 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 249 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_bad_selection " "Selected absent target %"PRIu32 "\n", id);
#line 8127 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_bad_selection(uint32_t id)
{
    if (true) {
        _nocheck__trace_lsi_bad_selection(id);
    }
}

#define TRACE_LSI_DO_DMA_UNAVAILABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_DMA_UNAVAILABLE) || \
    false)

static inline void _nocheck__trace_lsi_do_dma_unavailable(void)
{
    if (trace_event_get_state(TRACE_LSI_DO_DMA_UNAVAILABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 250 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_dma_unavailable " "DMA no data available" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8154 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 250 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_dma_unavailable " "DMA no data available" "\n");
#line 8158 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_dma_unavailable(void)
{
    if (true) {
        _nocheck__trace_lsi_do_dma_unavailable();
    }
}

#define TRACE_LSI_DO_DMA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_DMA) || \
    false)

static inline void _nocheck__trace_lsi_do_dma(uint64_t addr, int len)
{
    if (trace_event_get_state(TRACE_LSI_DO_DMA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 251 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_dma " "DMA addr=0x%"PRIx64" len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr, len);
#line 8185 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 251 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_dma " "DMA addr=0x%"PRIx64" len=%d" "\n", addr, len);
#line 8189 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_dma(uint64_t addr, int len)
{
    if (true) {
        _nocheck__trace_lsi_do_dma(addr, len);
    }
}

#define TRACE_LSI_QUEUE_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_QUEUE_COMMAND) || \
    false)

static inline void _nocheck__trace_lsi_queue_command(uint32_t tag)
{
    if (trace_event_get_state(TRACE_LSI_QUEUE_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 252 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_queue_command " "Queueing tag=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 8216 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 252 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_queue_command " "Queueing tag=0x%"PRIx32 "\n", tag);
#line 8220 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_queue_command(uint32_t tag)
{
    if (true) {
        _nocheck__trace_lsi_queue_command(tag);
    }
}

#define TRACE_LSI_ADD_MSG_BYTE_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_ADD_MSG_BYTE_ERROR) || \
    false)

static inline void _nocheck__trace_lsi_add_msg_byte_error(void)
{
    if (trace_event_get_state(TRACE_LSI_ADD_MSG_BYTE_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 253 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_add_msg_byte_error " "MSG IN data too long" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8247 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 253 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_add_msg_byte_error " "MSG IN data too long" "\n");
#line 8251 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_add_msg_byte_error(void)
{
    if (true) {
        _nocheck__trace_lsi_add_msg_byte_error();
    }
}

#define TRACE_LSI_ADD_MSG_BYTE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_ADD_MSG_BYTE) || \
    false)

static inline void _nocheck__trace_lsi_add_msg_byte(uint8_t data)
{
    if (trace_event_get_state(TRACE_LSI_ADD_MSG_BYTE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 254 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_add_msg_byte " "MSG IN 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , data);
#line 8278 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 254 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_add_msg_byte " "MSG IN 0x%02x" "\n", data);
#line 8282 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_add_msg_byte(uint8_t data)
{
    if (true) {
        _nocheck__trace_lsi_add_msg_byte(data);
    }
}

#define TRACE_LSI_RESELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_RESELECT) || \
    false)

static inline void _nocheck__trace_lsi_reselect(int id)
{
    if (trace_event_get_state(TRACE_LSI_RESELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 255 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_reselect " "Reselected target %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 8309 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 255 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_reselect " "Reselected target %d" "\n", id);
#line 8313 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_reselect(int id)
{
    if (true) {
        _nocheck__trace_lsi_reselect(id);
    }
}

#define TRACE_LSI_QUEUE_REQ_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_QUEUE_REQ_ERROR) || \
    false)

static inline void _nocheck__trace_lsi_queue_req_error(void * p)
{
    if (trace_event_get_state(TRACE_LSI_QUEUE_REQ_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 256 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_queue_req_error " "Multiple IO pending for request %p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , p);
#line 8340 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 256 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_queue_req_error " "Multiple IO pending for request %p" "\n", p);
#line 8344 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_queue_req_error(void * p)
{
    if (true) {
        _nocheck__trace_lsi_queue_req_error(p);
    }
}

#define TRACE_LSI_QUEUE_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_QUEUE_REQ) || \
    false)

static inline void _nocheck__trace_lsi_queue_req(uint32_t tag)
{
    if (trace_event_get_state(TRACE_LSI_QUEUE_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 257 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_queue_req " "Queueing IO tag=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 8371 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 257 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_queue_req " "Queueing IO tag=0x%"PRIx32 "\n", tag);
#line 8375 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_queue_req(uint32_t tag)
{
    if (true) {
        _nocheck__trace_lsi_queue_req(tag);
    }
}

#define TRACE_LSI_COMMAND_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_COMMAND_COMPLETE) || \
    false)

static inline void _nocheck__trace_lsi_command_complete(uint32_t status)
{
    if (trace_event_get_state(TRACE_LSI_COMMAND_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 258 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_command_complete " "Command complete status=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , status);
#line 8402 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 258 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_command_complete " "Command complete status=%"PRId32 "\n", status);
#line 8406 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_command_complete(uint32_t status)
{
    if (true) {
        _nocheck__trace_lsi_command_complete(status);
    }
}

#define TRACE_LSI_TRANSFER_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_TRANSFER_DATA) || \
    false)

static inline void _nocheck__trace_lsi_transfer_data(uint32_t tag, uint32_t len)
{
    if (trace_event_get_state(TRACE_LSI_TRANSFER_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 259 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_transfer_data " "Data ready tag=0x%"PRIx32" len=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, len);
#line 8433 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 259 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_transfer_data " "Data ready tag=0x%"PRIx32" len=%"PRId32 "\n", tag, len);
#line 8437 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_transfer_data(uint32_t tag, uint32_t len)
{
    if (true) {
        _nocheck__trace_lsi_transfer_data(tag, len);
    }
}

#define TRACE_LSI_DO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_COMMAND) || \
    false)

static inline void _nocheck__trace_lsi_do_command(uint32_t dbc)
{
    if (trace_event_get_state(TRACE_LSI_DO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 260 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_command " "Send command len=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbc);
#line 8464 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 260 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_command " "Send command len=%"PRId32 "\n", dbc);
#line 8468 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_command(uint32_t dbc)
{
    if (true) {
        _nocheck__trace_lsi_do_command(dbc);
    }
}

#define TRACE_LSI_DO_STATUS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_STATUS) || \
    false)

static inline void _nocheck__trace_lsi_do_status(uint32_t dbc, uint8_t status)
{
    if (trace_event_get_state(TRACE_LSI_DO_STATUS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 261 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_status " "Get status len=%"PRId32" status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbc, status);
#line 8495 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 261 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_status " "Get status len=%"PRId32" status=%d" "\n", dbc, status);
#line 8499 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_status(uint32_t dbc, uint8_t status)
{
    if (true) {
        _nocheck__trace_lsi_do_status(dbc, status);
    }
}

#define TRACE_LSI_DO_STATUS_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_STATUS_ERROR) || \
    false)

static inline void _nocheck__trace_lsi_do_status_error(void)
{
    if (trace_event_get_state(TRACE_LSI_DO_STATUS_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 262 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_status_error " "Bad Status move" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8526 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 262 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_status_error " "Bad Status move" "\n");
#line 8530 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_status_error(void)
{
    if (true) {
        _nocheck__trace_lsi_do_status_error();
    }
}

#define TRACE_LSI_DO_MSGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGIN) || \
    false)

static inline void _nocheck__trace_lsi_do_msgin(uint32_t dbc, int len)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 263 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgin " "Message in len=%"PRId32" %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbc, len);
#line 8557 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 263 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgin " "Message in len=%"PRId32" %d" "\n", dbc, len);
#line 8561 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgin(uint32_t dbc, int len)
{
    if (true) {
        _nocheck__trace_lsi_do_msgin(dbc, len);
    }
}

#define TRACE_LSI_DO_MSGOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout(uint32_t dbc)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 264 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout " "MSG out len=%"PRId32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dbc);
#line 8588 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 264 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout " "MSG out len=%"PRId32 "\n", dbc);
#line 8592 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout(uint32_t dbc)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout(dbc);
    }
}

#define TRACE_LSI_DO_MSGOUT_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_DISCONNECT) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_disconnect(void)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 265 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_disconnect " "MSG: Disconnect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8619 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 265 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_disconnect " "MSG: Disconnect" "\n");
#line 8623 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_disconnect(void)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_disconnect();
    }
}

#define TRACE_LSI_DO_MSGOUT_NOOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_NOOP) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_noop(void)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_NOOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 266 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_noop " "MSG: No Operation" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8650 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 266 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_noop " "MSG: No Operation" "\n");
#line 8654 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_noop(void)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_noop();
    }
}

#define TRACE_LSI_DO_MSGOUT_EXTENDED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_EXTENDED) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_extended(uint8_t msg, uint8_t len)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_EXTENDED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 267 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_extended " "Extended message 0x%x (len %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg, len);
#line 8681 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 267 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_extended " "Extended message 0x%x (len %d)" "\n", msg, len);
#line 8685 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_extended(uint8_t msg, uint8_t len)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_extended(msg, len);
    }
}

#define TRACE_LSI_DO_MSGOUT_IGNORED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_IGNORED) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_ignored(const char * msg)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_IGNORED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 268 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_ignored " "%s (ignored)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , msg);
#line 8712 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 268 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_ignored " "%s (ignored)" "\n", msg);
#line 8716 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_ignored(const char * msg)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_ignored(msg);
    }
}

#define TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_simplequeue(uint8_t select_tag)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_SIMPLEQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 269 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_simplequeue " "SIMPLE queue tag=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , select_tag);
#line 8743 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 269 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_simplequeue " "SIMPLE queue tag=0x%x" "\n", select_tag);
#line 8747 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_simplequeue(uint8_t select_tag)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_simplequeue(select_tag);
    }
}

#define TRACE_LSI_DO_MSGOUT_ABORT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_ABORT) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_abort(uint32_t tag)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_ABORT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 270 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_abort " "MSG: ABORT TAG tag=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 8774 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 270 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_abort " "MSG: ABORT TAG tag=0x%"PRIx32 "\n", tag);
#line 8778 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_abort(uint32_t tag)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_abort(tag);
    }
}

#define TRACE_LSI_DO_MSGOUT_CLEARQUEUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_CLEARQUEUE) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_clearqueue(uint32_t tag)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_CLEARQUEUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 271 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_clearqueue " "MSG: CLEAR QUEUE tag=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 8805 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 271 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_clearqueue " "MSG: CLEAR QUEUE tag=0x%"PRIx32 "\n", tag);
#line 8809 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_clearqueue(uint32_t tag)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_clearqueue(tag);
    }
}

#define TRACE_LSI_DO_MSGOUT_BUSDEVICERESET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_BUSDEVICERESET) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_busdevicereset(uint32_t tag)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_BUSDEVICERESET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 272 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_busdevicereset " "MSG: BUS DEVICE RESET tag=0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 8836 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 272 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_busdevicereset " "MSG: BUS DEVICE RESET tag=0x%"PRIx32 "\n", tag);
#line 8840 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_busdevicereset(uint32_t tag)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_busdevicereset(tag);
    }
}

#define TRACE_LSI_DO_MSGOUT_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_DO_MSGOUT_SELECT) || \
    false)

static inline void _nocheck__trace_lsi_do_msgout_select(int id)
{
    if (trace_event_get_state(TRACE_LSI_DO_MSGOUT_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 273 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_do_msgout_select " "Select LUN %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id);
#line 8867 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 273 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_do_msgout_select " "Select LUN %d" "\n", id);
#line 8871 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_do_msgout_select(int id)
{
    if (true) {
        _nocheck__trace_lsi_do_msgout_select(id);
    }
}

#define TRACE_LSI_MEMCPY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_MEMCPY) || \
    false)

static inline void _nocheck__trace_lsi_memcpy(uint32_t dest, uint32_t src, int count)
{
    if (trace_event_get_state(TRACE_LSI_MEMCPY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 274 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_memcpy " "memcpy dest 0x%"PRIx32" src 0x%"PRIx32" count %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dest, src, count);
#line 8898 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 274 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_memcpy " "memcpy dest 0x%"PRIx32" src 0x%"PRIx32" count %d" "\n", dest, src, count);
#line 8902 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_memcpy(uint32_t dest, uint32_t src, int count)
{
    if (true) {
        _nocheck__trace_lsi_memcpy(dest, src, count);
    }
}

#define TRACE_LSI_WAIT_RESELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_WAIT_RESELECT) || \
    false)

static inline void _nocheck__trace_lsi_wait_reselect(void)
{
    if (trace_event_get_state(TRACE_LSI_WAIT_RESELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 275 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_wait_reselect " "Wait Reselect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8929 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 275 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_wait_reselect " "Wait Reselect" "\n");
#line 8933 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_wait_reselect(void)
{
    if (true) {
        _nocheck__trace_lsi_wait_reselect();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT) || \
    false)

static inline void _nocheck__trace_lsi_execute_script(uint32_t dsp, uint32_t insn, uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 276 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script " "SCRIPTS dsp=0x%"PRIx32" opcode 0x%"PRIx32" arg 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dsp, insn, addr);
#line 8960 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 276 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script " "SCRIPTS dsp=0x%"PRIx32" opcode 0x%"PRIx32" arg 0x%"PRIx32 "\n", dsp, insn, addr);
#line 8964 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script(uint32_t dsp, uint32_t insn, uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script(dsp, insn, addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_blockmove_delayed(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_DELAYED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 277 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_blockmove_delayed " "Delayed select timeout" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 8991 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 277 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_blockmove_delayed " "Delayed select timeout" "\n");
#line 8995 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_blockmove_delayed(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_blockmove_delayed();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_blockmove_badphase(const char * phase, const char * expected)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_BLOCKMOVE_BADPHASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 278 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_blockmove_badphase " "Wrong phase got %s expected %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , phase, expected);
#line 9022 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 278 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_blockmove_badphase " "Wrong phase got %s expected %s" "\n", phase, expected);
#line 9026 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_blockmove_badphase(const char * phase, const char * expected)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_blockmove_badphase(phase, expected);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_alreadyreselected(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_ALREADYRESELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 279 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_alreadyreselected " "Already reselected, jumping to alternative address" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9053 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 279 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_alreadyreselected " "Already reselected, jumping to alternative address" "\n");
#line 9057 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_alreadyreselected(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_alreadyreselected();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_selected(uint8_t id, const char * atn)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_SELECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 280 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_selected " "Selected target %d%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , id, atn);
#line 9084 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 280 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_selected " "Selected target %d%s" "\n", id, atn);
#line 9088 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_selected(uint8_t id, const char * atn)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_selected(id, atn);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_disconnect(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 281 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_disconnect " "Wait Disconnect" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9115 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 281 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_disconnect " "Wait Disconnect" "\n");
#line 9119 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_disconnect(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_disconnect();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_SET_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_SET) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_set(const char * atn, const char * ack, const char * tm, const char * cc)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_SET) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 282 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_set " "Set%s%s%s%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , atn, ack, tm, cc);
#line 9146 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 282 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_set " "Set%s%s%s%s" "\n", atn, ack, tm, cc);
#line 9150 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_set(const char * atn, const char * ack, const char * tm, const char * cc)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_set(atn, ack, tm, cc);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_clear(const char * atn, const char * ack, const char * tm, const char * cc)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_CLEAR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 283 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_clear " "Clear%s%s%s%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , atn, ack, tm, cc);
#line 9177 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 283 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_clear " "Clear%s%s%s%s" "\n", atn, ack, tm, cc);
#line 9181 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_clear(const char * atn, const char * ack, const char * tm, const char * cc)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_clear(atn, ack, tm, cc);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_io_opcode(const char * opcode, int reg, const char * opname, uint8_t data8, uint32_t sfbr, const char * ssfbr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_IO_OPCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 284 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_io_opcode " "%s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , opcode, reg, opname, data8, sfbr, ssfbr);
#line 9208 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 284 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_io_opcode " "%s reg 0x%x %s data8=0x%02x sfbr=0x%02x%s" "\n", opcode, reg, opname, data8, sfbr, ssfbr);
#line 9212 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_io_opcode(const char * opcode, int reg, const char * opname, uint8_t data8, uint32_t sfbr, const char * ssfbr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_io_opcode(opcode, reg, opname, data8, sfbr, ssfbr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_NOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_NOP) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_nop(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_NOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 285 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_nop " "NOP" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9239 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 285 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_nop " "NOP" "\n");
#line 9243 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_nop(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_nop();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_delayedselect_timeout(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_DELAYEDSELECT_TIMEOUT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 286 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_delayedselect_timeout " "Delayed select timeout" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9270 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 286 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_delayedselect_timeout " "Delayed select timeout" "\n");
#line 9274 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_delayedselect_timeout(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_delayedselect_timeout();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_compc(int result)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 287 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_compc " "Compare carry %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , result);
#line 9301 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 287 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_compc " "Compare carry %d" "\n", result);
#line 9305 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_compc(int result)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_compc(result);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_compp(const char * phase, char op, const char * insn_phase)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 288 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_compp " "Compare phase %s %c= %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , phase, op, insn_phase);
#line 9332 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 288 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_compp " "Compare phase %s %c= %s" "\n", phase, op, insn_phase);
#line 9336 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_compp(const char * phase, char op, const char * insn_phase)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_compp(phase, op, insn_phase);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_compd(uint32_t sfbr, uint8_t mask, char op, int result)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_COMPD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 289 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_compd " "Compare data 0x%"PRIx32" & 0x%x %c= 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sfbr, mask, op, result);
#line 9363 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 289 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_compd " "Compare data 0x%"PRIx32" & 0x%x %c= 0x%x" "\n", sfbr, mask, op, result);
#line 9367 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_compd(uint32_t sfbr, uint8_t mask, char op, int result)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_compd(sfbr, mask, op, result);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_jump(uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_JUMP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 290 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_jump " "Jump to 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 9394 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 290 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_jump " "Jump to 0x%"PRIx32 "\n", addr);
#line 9398 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_jump(uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_jump(addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_CALL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_CALL) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_call(uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_CALL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 291 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_call " "Call 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 9425 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 291 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_call " "Call 0x%"PRIx32 "\n", addr);
#line 9429 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_call(uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_call(addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_return(uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_RETURN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 292 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_return " "Return to 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 9456 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 292 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_return " "Return to 0x%"PRIx32 "\n", addr);
#line 9460 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_return(uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_return(addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_interrupt(uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_INTERRUPT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 293 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_interrupt " "Interrupt 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , addr);
#line 9487 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 293 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_interrupt " "Interrupt 0x%"PRIx32 "\n", addr);
#line 9491 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_interrupt(uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_interrupt(addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_illegal(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_ILLEGAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 294 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_illegal " "Illegal transfer control" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9518 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 294 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_illegal " "Illegal transfer control" "\n");
#line 9522 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_illegal(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_illegal();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_tc_cc_failed(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_TC_CC_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 295 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_tc_cc_failed " "Control condition failed" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9549 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 295 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_tc_cc_failed " "Control condition failed" "\n");
#line 9553 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_tc_cc_failed(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_tc_cc_failed();
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_mm_load(int reg, int n, uint32_t addr, int data)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_MM_LOAD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 296 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_mm_load " "Load reg 0x%x size %d addr 0x%"PRIx32" = 0x%08x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, n, addr, data);
#line 9580 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 296 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_mm_load " "Load reg 0x%x size %d addr 0x%"PRIx32" = 0x%08x" "\n", reg, n, addr, data);
#line 9584 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_mm_load(int reg, int n, uint32_t addr, int data)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_mm_load(reg, n, addr, data);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_MM_STORE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_MM_STORE) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_mm_store(int reg, int n, uint32_t addr)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_MM_STORE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 297 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_mm_store " "Store reg 0x%x size %d addr 0x%"PRIx32 "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , reg, n, addr);
#line 9611 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 297 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_mm_store " "Store reg 0x%x size %d addr 0x%"PRIx32 "\n", reg, n, addr);
#line 9615 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_mm_store(int reg, int n, uint32_t addr)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_mm_store(reg, n, addr);
    }
}

#define TRACE_LSI_EXECUTE_SCRIPT_STOP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_EXECUTE_SCRIPT_STOP) || \
    false)

static inline void _nocheck__trace_lsi_execute_script_stop(void)
{
    if (trace_event_get_state(TRACE_LSI_EXECUTE_SCRIPT_STOP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 298 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_execute_script_stop " "SCRIPTS execution stopped" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9642 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 298 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_execute_script_stop " "SCRIPTS execution stopped" "\n");
#line 9646 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_execute_script_stop(void)
{
    if (true) {
        _nocheck__trace_lsi_execute_script_stop();
    }
}

#define TRACE_LSI_AWOKEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_AWOKEN) || \
    false)

static inline void _nocheck__trace_lsi_awoken(void)
{
    if (trace_event_get_state(TRACE_LSI_AWOKEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 299 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_awoken " "Woken by SIGP" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 9673 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 299 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_awoken " "Woken by SIGP" "\n");
#line 9677 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_awoken(void)
{
    if (true) {
        _nocheck__trace_lsi_awoken();
    }
}

#define TRACE_LSI_REG_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_REG_READ) || \
    false)

static inline void _nocheck__trace_lsi_reg_read(const char * name, int offset, uint8_t ret)
{
    if (trace_event_get_state(TRACE_LSI_REG_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 300 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_reg_read " "Read reg %s 0x%x = 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, ret);
#line 9704 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 300 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_reg_read " "Read reg %s 0x%x = 0x%02x" "\n", name, offset, ret);
#line 9708 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_reg_read(const char * name, int offset, uint8_t ret)
{
    if (true) {
        _nocheck__trace_lsi_reg_read(name, offset, ret);
    }
}

#define TRACE_LSI_REG_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_LSI_REG_WRITE) || \
    false)

static inline void _nocheck__trace_lsi_reg_write(const char * name, int offset, uint8_t val)
{
    if (trace_event_get_state(TRACE_LSI_REG_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 301 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:lsi_reg_write " "Write reg %s 0x%x = 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, offset, val);
#line 9735 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 301 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("lsi_reg_write " "Write reg %s 0x%x = 0x%02x" "\n", name, offset, val);
#line 9739 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_lsi_reg_write(const char * name, int offset, uint8_t val)
{
    if (true) {
        _nocheck__trace_lsi_reg_write(name, offset, val);
    }
}

#define TRACE_VIRTIO_SCSI_CMD_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_CMD_REQ) || \
    false)

static inline void _nocheck__trace_virtio_scsi_cmd_req(int lun, uint32_t tag, uint8_t cmd)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_CMD_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 304 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_cmd_req " "virtio_scsi_cmd_req lun=%u tag=0x%x cmd=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, tag, cmd);
#line 9766 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 304 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_cmd_req " "virtio_scsi_cmd_req lun=%u tag=0x%x cmd=0x%x" "\n", lun, tag, cmd);
#line 9770 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_cmd_req(int lun, uint32_t tag, uint8_t cmd)
{
    if (true) {
        _nocheck__trace_virtio_scsi_cmd_req(lun, tag, cmd);
    }
}

#define TRACE_VIRTIO_SCSI_CMD_RESP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_CMD_RESP) || \
    false)

static inline void _nocheck__trace_virtio_scsi_cmd_resp(int lun, uint32_t tag, int response, uint8_t status)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_CMD_RESP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 305 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_cmd_resp " "virtio_scsi_cmd_resp lun=%u tag=0x%x response=%d status=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, tag, response, status);
#line 9797 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 305 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_cmd_resp " "virtio_scsi_cmd_resp lun=%u tag=0x%x response=%d status=0x%x" "\n", lun, tag, response, status);
#line 9801 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_cmd_resp(int lun, uint32_t tag, int response, uint8_t status)
{
    if (true) {
        _nocheck__trace_virtio_scsi_cmd_resp(lun, tag, response, status);
    }
}

#define TRACE_VIRTIO_SCSI_TMF_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_TMF_REQ) || \
    false)

static inline void _nocheck__trace_virtio_scsi_tmf_req(int lun, uint32_t tag, int subtype)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_TMF_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 306 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_tmf_req " "virtio_scsi_tmf_req lun=%u tag=0x%x subtype=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, tag, subtype);
#line 9828 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 306 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_tmf_req " "virtio_scsi_tmf_req lun=%u tag=0x%x subtype=%d" "\n", lun, tag, subtype);
#line 9832 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_tmf_req(int lun, uint32_t tag, int subtype)
{
    if (true) {
        _nocheck__trace_virtio_scsi_tmf_req(lun, tag, subtype);
    }
}

#define TRACE_VIRTIO_SCSI_TMF_RESP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_TMF_RESP) || \
    false)

static inline void _nocheck__trace_virtio_scsi_tmf_resp(int lun, uint32_t tag, int response)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_TMF_RESP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 307 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_tmf_resp " "virtio_scsi_tmf_resp lun=%u tag=0x%x response=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, tag, response);
#line 9859 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 307 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_tmf_resp " "virtio_scsi_tmf_resp lun=%u tag=0x%x response=%d" "\n", lun, tag, response);
#line 9863 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_tmf_resp(int lun, uint32_t tag, int response)
{
    if (true) {
        _nocheck__trace_virtio_scsi_tmf_resp(lun, tag, response);
    }
}

#define TRACE_VIRTIO_SCSI_AN_REQ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_AN_REQ) || \
    false)

static inline void _nocheck__trace_virtio_scsi_an_req(int lun, uint32_t event_requested)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_AN_REQ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 308 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_an_req " "virtio_scsi_an_req lun=%u event_requested=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, event_requested);
#line 9890 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 308 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_an_req " "virtio_scsi_an_req lun=%u event_requested=0x%x" "\n", lun, event_requested);
#line 9894 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_an_req(int lun, uint32_t event_requested)
{
    if (true) {
        _nocheck__trace_virtio_scsi_an_req(lun, event_requested);
    }
}

#define TRACE_VIRTIO_SCSI_AN_RESP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_AN_RESP) || \
    false)

static inline void _nocheck__trace_virtio_scsi_an_resp(int lun, int response)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_AN_RESP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 309 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_an_resp " "virtio_scsi_an_resp lun=%u response=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, response);
#line 9921 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 309 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_an_resp " "virtio_scsi_an_resp lun=%u response=%d" "\n", lun, response);
#line 9925 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_an_resp(int lun, int response)
{
    if (true) {
        _nocheck__trace_virtio_scsi_an_resp(lun, response);
    }
}

#define TRACE_VIRTIO_SCSI_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VIRTIO_SCSI_EVENT) || \
    false)

static inline void _nocheck__trace_virtio_scsi_event(int lun, int event, int reason)
{
    if (trace_event_get_state(TRACE_VIRTIO_SCSI_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 310 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:virtio_scsi_event " "virtio_scsi_event lun=%u event=%d reason=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, event, reason);
#line 9952 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 310 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("virtio_scsi_event " "virtio_scsi_event lun=%u event=%d reason=%d" "\n", lun, event, reason);
#line 9956 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_virtio_scsi_event(int lun, int event, int reason)
{
    if (true) {
        _nocheck__trace_virtio_scsi_event(lun, event, reason);
    }
}

#define TRACE_SCSI_DISK_CHECK_CONDITION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_CHECK_CONDITION) || \
    false)

static inline void _nocheck__trace_scsi_disk_check_condition(uint32_t tag, uint8_t key, uint8_t asc, uint8_t ascq)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_CHECK_CONDITION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 313 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_check_condition " "Command complete tag=0x%x sense=%d/%d/%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, key, asc, ascq);
#line 9983 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 313 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_check_condition " "Command complete tag=0x%x sense=%d/%d/%d" "\n", tag, key, asc, ascq);
#line 9987 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_check_condition(uint32_t tag, uint8_t key, uint8_t asc, uint8_t ascq)
{
    if (true) {
        _nocheck__trace_scsi_disk_check_condition(tag, key, asc, ascq);
    }
}

#define TRACE_SCSI_DISK_READ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_READ_COMPLETE) || \
    false)

static inline void _nocheck__trace_scsi_disk_read_complete(uint32_t tag, size_t size)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_READ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 314 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_read_complete " "Data ready tag=0x%x len=%zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, size);
#line 10014 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 314 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_read_complete " "Data ready tag=0x%x len=%zd" "\n", tag, size);
#line 10018 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_read_complete(uint32_t tag, size_t size)
{
    if (true) {
        _nocheck__trace_scsi_disk_read_complete(tag, size);
    }
}

#define TRACE_SCSI_DISK_READ_DATA_COUNT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_READ_DATA_COUNT) || \
    false)

static inline void _nocheck__trace_scsi_disk_read_data_count(uint32_t sector_count)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_READ_DATA_COUNT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 315 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_read_data_count " "Read sector_count=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sector_count);
#line 10045 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 315 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_read_data_count " "Read sector_count=%d" "\n", sector_count);
#line 10049 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_read_data_count(uint32_t sector_count)
{
    if (true) {
        _nocheck__trace_scsi_disk_read_data_count(sector_count);
    }
}

#define TRACE_SCSI_DISK_READ_DATA_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_READ_DATA_INVALID) || \
    false)

static inline void _nocheck__trace_scsi_disk_read_data_invalid(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_READ_DATA_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 316 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_read_data_invalid " "Data transfer direction invalid" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10076 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 316 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_read_data_invalid " "Data transfer direction invalid" "\n");
#line 10080 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_read_data_invalid(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_read_data_invalid();
    }
}

#define TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO) || \
    false)

static inline void _nocheck__trace_scsi_disk_write_complete_noio(uint32_t tag, size_t size)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_WRITE_COMPLETE_NOIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 317 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_write_complete_noio " "Write complete tag=0x%x more=%zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, size);
#line 10107 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 317 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_write_complete_noio " "Write complete tag=0x%x more=%zd" "\n", tag, size);
#line 10111 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_write_complete_noio(uint32_t tag, size_t size)
{
    if (true) {
        _nocheck__trace_scsi_disk_write_complete_noio(tag, size);
    }
}

#define TRACE_SCSI_DISK_WRITE_DATA_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_WRITE_DATA_INVALID) || \
    false)

static inline void _nocheck__trace_scsi_disk_write_data_invalid(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_WRITE_DATA_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 318 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_write_data_invalid " "Data transfer direction invalid" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10138 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 318 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_write_data_invalid " "Data transfer direction invalid" "\n");
#line 10142 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_write_data_invalid(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_write_data_invalid();
    }
}

#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_vpd_page_00(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_00) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 319 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_vpd_page_00 " "Inquiry EVPD[Supported pages] buffer size %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10169 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 319 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_vpd_page_00 " "Inquiry EVPD[Supported pages] buffer size %zd" "\n", xfer);
#line 10173 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_vpd_page_00(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_vpd_page_00(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_vpd_page_80_not_supported(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_NOT_SUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 320 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_vpd_page_80_not_supported " "Inquiry (EVPD[Serial number] not supported" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10200 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 320 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_vpd_page_80_not_supported " "Inquiry (EVPD[Serial number] not supported" "\n");
#line 10204 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_vpd_page_80_not_supported(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_vpd_page_80_not_supported();
    }
}

#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_vpd_page_80(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_80) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 321 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_vpd_page_80 " "Inquiry EVPD[Serial number] buffer size %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10231 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 321 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_vpd_page_80 " "Inquiry EVPD[Serial number] buffer size %zd" "\n", xfer);
#line 10235 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_vpd_page_80(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_vpd_page_80(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_vpd_page_83(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_83) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 322 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_vpd_page_83 " "Inquiry EVPD[Device identification] buffer size %zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10262 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 322 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_vpd_page_83 " "Inquiry EVPD[Device identification] buffer size %zd" "\n", xfer);
#line 10266 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_vpd_page_83(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_vpd_page_83(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_vpd_page_b0_not_supported(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_VPD_PAGE_B0_NOT_SUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 323 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_vpd_page_b0_not_supported " "Inquiry (EVPD[Block limits] not supported for CDROM" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10293 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 323 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_vpd_page_b0_not_supported " "Inquiry (EVPD[Block limits] not supported for CDROM" "\n");
#line 10297 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_vpd_page_b0_not_supported(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_vpd_page_b0_not_supported();
    }
}

#define TRACE_SCSI_DISK_EMULATE_MODE_SENSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_MODE_SENSE) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_mode_sense(int cmd, int page, size_t xfer, int control)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_MODE_SENSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 324 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_mode_sense " "Mode Sense(%d) (page %d, xfer %zd, page_control %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, page, xfer, control);
#line 10324 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 324 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_mode_sense " "Mode Sense(%d) (page %d, xfer %zd, page_control %d)" "\n", cmd, page, xfer, control);
#line 10328 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_mode_sense(int cmd, int page, size_t xfer, int control)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_mode_sense(cmd, page, xfer, control);
    }
}

#define TRACE_SCSI_DISK_EMULATE_READ_TOC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_READ_TOC) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_read_toc(int start_track, int format, int msf)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_READ_TOC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 325 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_read_toc " "Read TOC (track %d format %d msf %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , start_track, format, msf);
#line 10355 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 325 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_read_toc " "Read TOC (track %d format %d msf %d)" "\n", start_track, format, msf);
#line 10359 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_read_toc(int start_track, int format, int msf)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_read_toc(start_track, format, msf);
    }
}

#define TRACE_SCSI_DISK_EMULATE_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_READ_DATA) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_read_data(int buflen)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 326 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_read_data " "Read buf_len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buflen);
#line 10386 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 326 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_read_data " "Read buf_len=%d" "\n", buflen);
#line 10390 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_read_data(int buflen)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_read_data(buflen);
    }
}

#define TRACE_SCSI_DISK_EMULATE_WRITE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_WRITE_DATA) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_write_data(int buflen)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_WRITE_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 327 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_write_data " "Write buf_len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , buflen);
#line 10417 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 327 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_write_data " "Write buf_len=%d" "\n", buflen);
#line 10421 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_write_data(int buflen)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_write_data(buflen);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_SAI_16(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_16) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 328 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_SAI_16 " "SAI READ CAPACITY(16)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10448 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 328 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_SAI_16 " "SAI READ CAPACITY(16)" "\n");
#line 10452 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_SAI_16(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_SAI_16();
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_SAI_unsupported(void)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_SAI_UNSUPPORTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 329 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_SAI_unsupported " "Unsupported Service Action In" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 10479 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 329 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_SAI_unsupported " "Unsupported Service Action In" "\n");
#line 10483 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_SAI_unsupported(void)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_SAI_unsupported();
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_SEEK_10(uint64_t lba)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_SEEK_10) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 330 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_SEEK_10 " "Seek(10) (sector %" PRId64 ")" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lba);
#line 10510 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 330 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_SEEK_10 " "Seek(10) (sector %" PRId64 ")" "\n", lba);
#line 10514 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_SEEK_10(uint64_t lba)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_SEEK_10(lba);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_MODE_SELECT(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 331 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_MODE_SELECT " "Mode Select(6) (len %zd)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10541 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 331 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_MODE_SELECT " "Mode Select(6) (len %zd)" "\n", xfer);
#line 10545 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_MODE_SELECT(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_MODE_SELECT(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_MODE_SELECT_10(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_MODE_SELECT_10) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 332 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_MODE_SELECT_10 " "Mode Select(10) (len %zd)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10572 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 332 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_MODE_SELECT_10 " "Mode Select(10) (len %zd)" "\n", xfer);
#line 10576 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_MODE_SELECT_10(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_MODE_SELECT_10(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_UNMAP(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_UNMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 333 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_UNMAP " "Unmap (len %zd)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10603 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 333 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_UNMAP " "Unmap (len %zd)" "\n", xfer);
#line 10607 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_UNMAP(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_UNMAP(xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_VERIFY(int bytchk)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_VERIFY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 334 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_VERIFY " "Verify (bytchk %d)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bytchk);
#line 10634 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 334 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_VERIFY " "Verify (bytchk %d)" "\n", bytchk);
#line 10638 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_VERIFY(int bytchk)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_VERIFY(bytchk);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_WRITE_SAME(int cmd, size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_WRITE_SAME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 335 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_WRITE_SAME " "WRITE SAME %d (len %zd)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, xfer);
#line 10665 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 335 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_WRITE_SAME " "WRITE SAME %d (len %zd)" "\n", cmd, xfer);
#line 10669 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_WRITE_SAME(int cmd, size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_WRITE_SAME(cmd, xfer);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_UNKNOWN(int cmd, const char * name)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 336 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_UNKNOWN " "Unknown SCSI command (0x%2.2x=%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, name);
#line 10696 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 336 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_UNKNOWN " "Unknown SCSI command (0x%2.2x=%s)" "\n", cmd, name);
#line 10700 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_UNKNOWN(int cmd, const char * name)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_UNKNOWN(cmd, name);
    }
}

#define TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT) || \
    false)

static inline void _nocheck__trace_scsi_disk_emulate_command_FORMAT_UNIT(size_t xfer)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_EMULATE_COMMAND_FORMAT_UNIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 337 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_emulate_command_FORMAT_UNIT " "Format Unit (len %zu)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , xfer);
#line 10727 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 337 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_emulate_command_FORMAT_UNIT " "Format Unit (len %zu)" "\n", xfer);
#line 10731 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_emulate_command_FORMAT_UNIT(size_t xfer)
{
    if (true) {
        _nocheck__trace_scsi_disk_emulate_command_FORMAT_UNIT(xfer);
    }
}

#define TRACE_SCSI_DISK_DMA_COMMAND_READ_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_DMA_COMMAND_READ) || \
    false)

static inline void _nocheck__trace_scsi_disk_dma_command_READ(uint64_t lba, uint32_t len)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_DMA_COMMAND_READ) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 338 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_dma_command_READ " "Read (sector %" PRId64 ", count %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lba, len);
#line 10758 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 338 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_dma_command_READ " "Read (sector %" PRId64 ", count %u)" "\n", lba, len);
#line 10762 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_dma_command_READ(uint64_t lba, uint32_t len)
{
    if (true) {
        _nocheck__trace_scsi_disk_dma_command_READ(lba, len);
    }
}

#define TRACE_SCSI_DISK_DMA_COMMAND_WRITE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_DMA_COMMAND_WRITE) || \
    false)

static inline void _nocheck__trace_scsi_disk_dma_command_WRITE(const char * cmd, uint64_t lba, int len)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_DMA_COMMAND_WRITE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 339 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_dma_command_WRITE " "Write %s(sector %" PRId64 ", count %u)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, lba, len);
#line 10789 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 339 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_dma_command_WRITE " "Write %s(sector %" PRId64 ", count %u)" "\n", cmd, lba, len);
#line 10793 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_dma_command_WRITE(const char * cmd, uint64_t lba, int len)
{
    if (true) {
        _nocheck__trace_scsi_disk_dma_command_WRITE(cmd, lba, len);
    }
}

#define TRACE_SCSI_DISK_NEW_REQUEST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_NEW_REQUEST) || \
    false)

static inline void _nocheck__trace_scsi_disk_new_request(uint32_t lun, uint32_t tag, const char * line)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_NEW_REQUEST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 340 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_new_request " "Command: lun=%d tag=0x%x data=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , lun, tag, line);
#line 10820 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 340 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_new_request " "Command: lun=%d tag=0x%x data=%s" "\n", lun, tag, line);
#line 10824 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_new_request(uint32_t lun, uint32_t tag, const char * line)
{
    if (true) {
        _nocheck__trace_scsi_disk_new_request(lun, tag, line);
    }
}

#define TRACE_SCSI_DISK_AIO_SGIO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_AIO_SGIO_COMMAND) || \
    false)

static inline void _nocheck__trace_scsi_disk_aio_sgio_command(uint32_t tag, uint8_t cmd, uint64_t lba, int len, uint32_t timeout)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_AIO_SGIO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 341 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_aio_sgio_command " "disk aio sgio: tag=0x%x cmd=0x%x (sector %" PRId64 ", count %d) timeout=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, cmd, lba, len, timeout);
#line 10851 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 341 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_aio_sgio_command " "disk aio sgio: tag=0x%x cmd=0x%x (sector %" PRId64 ", count %d) timeout=%u" "\n", tag, cmd, lba, len, timeout);
#line 10855 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_aio_sgio_command(uint32_t tag, uint8_t cmd, uint64_t lba, int len, uint32_t timeout)
{
    if (true) {
        _nocheck__trace_scsi_disk_aio_sgio_command(tag, cmd, lba, len, timeout);
    }
}

#define TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED) || \
    false)

static inline void _nocheck__trace_scsi_disk_mode_select_page_truncated(int page, int len, int page_len)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_MODE_SELECT_PAGE_TRUNCATED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 342 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_mode_select_page_truncated " "page %d expected length %d but received length %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , page, len, page_len);
#line 10882 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 342 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_mode_select_page_truncated " "page %d expected length %d but received length %d" "\n", page, len, page_len);
#line 10886 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_mode_select_page_truncated(int page, int len, int page_len)
{
    if (true) {
        _nocheck__trace_scsi_disk_mode_select_page_truncated(page, len, page_len);
    }
}

#define TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE) || \
    false)

static inline void _nocheck__trace_scsi_disk_mode_select_set_blocksize(int blocksize)
{
    if (trace_event_get_state(TRACE_SCSI_DISK_MODE_SELECT_SET_BLOCKSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 343 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_disk_mode_select_set_blocksize " "set block size to %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blocksize);
#line 10913 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 343 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_disk_mode_select_set_blocksize " "set block size to %d" "\n", blocksize);
#line 10917 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_disk_mode_select_set_blocksize(int blocksize)
{
    if (true) {
        _nocheck__trace_scsi_disk_mode_select_set_blocksize(blocksize);
    }
}

#define TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO) || \
    false)

static inline void _nocheck__trace_scsi_generic_command_complete_noio(void * req, uint32_t tag, int statuc)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_COMMAND_COMPLETE_NOIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 346 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_command_complete_noio " "Command complete %p tag=0x%x status=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , req, tag, statuc);
#line 10944 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 346 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_command_complete_noio " "Command complete %p tag=0x%x status=%d" "\n", req, tag, statuc);
#line 10948 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_command_complete_noio(void * req, uint32_t tag, int statuc)
{
    if (true) {
        _nocheck__trace_scsi_generic_command_complete_noio(req, tag, statuc);
    }
}

#define TRACE_SCSI_GENERIC_READ_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_READ_COMPLETE) || \
    false)

static inline void _nocheck__trace_scsi_generic_read_complete(uint32_t tag, int len)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_READ_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 347 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_read_complete " "Data ready tag=0x%x len=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, len);
#line 10975 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 347 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_read_complete " "Data ready tag=0x%x len=%d" "\n", tag, len);
#line 10979 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_read_complete(uint32_t tag, int len)
{
    if (true) {
        _nocheck__trace_scsi_generic_read_complete(tag, len);
    }
}

#define TRACE_SCSI_GENERIC_READ_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_READ_DATA) || \
    false)

static inline void _nocheck__trace_scsi_generic_read_data(uint32_t tag)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_READ_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 348 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_read_data " "scsi_read_data tag=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 11006 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 348 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_read_data " "scsi_read_data tag=0x%x" "\n", tag);
#line 11010 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_read_data(uint32_t tag)
{
    if (true) {
        _nocheck__trace_scsi_generic_read_data(tag);
    }
}

#define TRACE_SCSI_GENERIC_WRITE_COMPLETE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_WRITE_COMPLETE) || \
    false)

static inline void _nocheck__trace_scsi_generic_write_complete(int ret)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_WRITE_COMPLETE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 349 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_write_complete " "scsi_write_complete() ret = %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ret);
#line 11037 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 349 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_write_complete " "scsi_write_complete() ret = %d" "\n", ret);
#line 11041 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_write_complete(int ret)
{
    if (true) {
        _nocheck__trace_scsi_generic_write_complete(ret);
    }
}

#define TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE) || \
    false)

static inline void _nocheck__trace_scsi_generic_write_complete_blocksize(int blocksize)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_WRITE_COMPLETE_BLOCKSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 350 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_write_complete_blocksize " "block size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blocksize);
#line 11068 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 350 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_write_complete_blocksize " "block size %d" "\n", blocksize);
#line 11072 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_write_complete_blocksize(int blocksize)
{
    if (true) {
        _nocheck__trace_scsi_generic_write_complete_blocksize(blocksize);
    }
}

#define TRACE_SCSI_GENERIC_WRITE_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_WRITE_DATA) || \
    false)

static inline void _nocheck__trace_scsi_generic_write_data(uint32_t tag)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_WRITE_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 351 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_write_data " "scsi_write_data tag=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag);
#line 11099 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 351 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_write_data " "scsi_write_data tag=0x%x" "\n", tag);
#line 11103 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_write_data(uint32_t tag)
{
    if (true) {
        _nocheck__trace_scsi_generic_write_data(tag);
    }
}

#define TRACE_SCSI_GENERIC_SEND_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_SEND_COMMAND) || \
    false)

static inline void _nocheck__trace_scsi_generic_send_command(const char * line)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_SEND_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 352 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_send_command " "Command: data=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , line);
#line 11130 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 352 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_send_command " "Command: data=%s" "\n", line);
#line 11134 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_send_command(const char * line)
{
    if (true) {
        _nocheck__trace_scsi_generic_send_command(line);
    }
}

#define TRACE_SCSI_GENERIC_REALIZE_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_REALIZE_TYPE) || \
    false)

static inline void _nocheck__trace_scsi_generic_realize_type(int type)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_REALIZE_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 353 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_realize_type " "device type %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type);
#line 11161 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 353 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_realize_type " "device type %d" "\n", type);
#line 11165 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_realize_type(int type)
{
    if (true) {
        _nocheck__trace_scsi_generic_realize_type(type);
    }
}

#define TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE) || \
    false)

static inline void _nocheck__trace_scsi_generic_realize_blocksize(int blocksize)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_REALIZE_BLOCKSIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 354 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_realize_blocksize " "block size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , blocksize);
#line 11192 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 354 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_realize_blocksize " "block size %d" "\n", blocksize);
#line 11196 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_realize_blocksize(int blocksize)
{
    if (true) {
        _nocheck__trace_scsi_generic_realize_blocksize(blocksize);
    }
}

#define TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND) || \
    false)

static inline void _nocheck__trace_scsi_generic_aio_sgio_command(uint32_t tag, uint8_t cmd, uint32_t timeout)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_AIO_SGIO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 355 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_aio_sgio_command " "generic aio sgio: tag=0x%x cmd=0x%x timeout=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tag, cmd, timeout);
#line 11223 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 355 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_aio_sgio_command " "generic aio sgio: tag=0x%x cmd=0x%x timeout=%u" "\n", tag, cmd, timeout);
#line 11227 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_aio_sgio_command(uint32_t tag, uint8_t cmd, uint32_t timeout)
{
    if (true) {
        _nocheck__trace_scsi_generic_aio_sgio_command(tag, cmd, timeout);
    }
}

#define TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND) || \
    false)

static inline void _nocheck__trace_scsi_generic_ioctl_sgio_command(uint8_t cmd, uint32_t timeout)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_IOCTL_SGIO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 356 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_ioctl_sgio_command " "generic ioctl sgio: cmd=0x%x timeout=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, timeout);
#line 11254 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 356 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_ioctl_sgio_command " "generic ioctl sgio: cmd=0x%x timeout=%u" "\n", cmd, timeout);
#line 11258 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_ioctl_sgio_command(uint8_t cmd, uint32_t timeout)
{
    if (true) {
        _nocheck__trace_scsi_generic_ioctl_sgio_command(cmd, timeout);
    }
}

#define TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE) || \
    false)

static inline void _nocheck__trace_scsi_generic_ioctl_sgio_done(uint8_t cmd, int ret, uint8_t status, uint8_t host_status)
{
    if (trace_event_get_state(TRACE_SCSI_GENERIC_IOCTL_SGIO_DONE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 357 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("%d@%zu.%06zu:scsi_generic_ioctl_sgio_done " "generic ioctl sgio: cmd=0x%x ret=%d status=0x%x host_status=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cmd, ret, status, host_status);
#line 11285 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        } else {
#line 357 "C:/Users/seski/source/repos/xemu-uwp/hw/scsi/trace-events"
            qemu_log("scsi_generic_ioctl_sgio_done " "generic ioctl sgio: cmd=0x%x ret=%d status=0x%x host_status=0x%x" "\n", cmd, ret, status, host_status);
#line 11289 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-hw_scsi.h"
        }
    }
}

static inline void trace_scsi_generic_ioctl_sgio_done(uint8_t cmd, int ret, uint8_t status, uint8_t host_status)
{
    if (true) {
        _nocheck__trace_scsi_generic_ioctl_sgio_done(cmd, ret, status, host_status);
    }
}
#endif /* TRACE_HW_SCSI_GENERATED_TRACERS_H */
