/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_GDBSTUB_GENERATED_TRACERS_H
#define TRACE_GDBSTUB_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_GDBSTUB_OP_START_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXITING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_CONTINUE_CPU_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_STEPPING_EVENT;
extern TraceEvent _TRACE_GDBSTUB_OP_EXTRA_INFO_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHPOINT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_BREAK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_PAUSED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_SHUTDOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_IO_ERROR_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_WATCHDOG_EVENT;
extern TraceEvent _TRACE_GDBSTUB_HIT_UNKNOWN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_REPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_BINARYREPLY_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_COMMAND_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_ACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GOT_NACK_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_GARBAGE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_OVERRUN_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_REPEAT_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_INVALID_RLE_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_EVENT;
extern TraceEvent _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_EVENT;
extern uint16_t _TRACE_GDBSTUB_OP_START_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXITING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_CONTINUE_CPU_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_STEPPING_DSTATE;
extern uint16_t _TRACE_GDBSTUB_OP_EXTRA_INFO_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHPOINT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_INTERNAL_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_BREAK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_PAUSED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_SHUTDOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_IO_ERROR_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_WATCHDOG_DSTATE;
extern uint16_t _TRACE_GDBSTUB_HIT_UNKNOWN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_REPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_BINARYREPLY_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_COMMAND_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_ACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_IO_GOT_UNEXPECTED_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GOT_NACK_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_GARBAGE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_OVERRUN_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_REPEAT_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_INVALID_RLE_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_DSTATE;
extern uint16_t _TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_DSTATE;
#define TRACE_GDBSTUB_OP_START_ENABLED 1
#define TRACE_GDBSTUB_OP_EXITING_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_ENABLED 1
#define TRACE_GDBSTUB_OP_CONTINUE_CPU_ENABLED 1
#define TRACE_GDBSTUB_OP_STEPPING_ENABLED 1
#define TRACE_GDBSTUB_OP_EXTRA_INFO_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHPOINT_ENABLED 1
#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_BREAK_ENABLED 1
#define TRACE_GDBSTUB_HIT_PAUSED_ENABLED 1
#define TRACE_GDBSTUB_HIT_SHUTDOWN_ENABLED 1
#define TRACE_GDBSTUB_HIT_IO_ERROR_ENABLED 1
#define TRACE_GDBSTUB_HIT_WATCHDOG_ENABLED 1
#define TRACE_GDBSTUB_HIT_UNKNOWN_ENABLED 1
#define TRACE_GDBSTUB_IO_REPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_BINARYREPLY_ENABLED 1
#define TRACE_GDBSTUB_IO_COMMAND_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_ACK_ENABLED 1
#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_ENABLED 1
#define TRACE_GDBSTUB_ERR_GOT_NACK_ENABLED 1
#define TRACE_GDBSTUB_ERR_GARBAGE_ENABLED 1
#define TRACE_GDBSTUB_ERR_OVERRUN_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_ENABLED 1
#define TRACE_GDBSTUB_ERR_INVALID_RLE_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_ENABLED 1
#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_GDBSTUB_OP_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_START) || \
    false)

static inline void _nocheck__trace_gdbstub_op_start(const char * device)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_start " "Starting gdbstub using device %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , device);
#line 106 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 4 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_start " "Starting gdbstub using device %s" "\n", device);
#line 110 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_start(const char * device)
{
    if (true) {
        _nocheck__trace_gdbstub_op_start(device);
    }
}

#define TRACE_GDBSTUB_OP_EXITING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXITING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_exiting(uint8_t code)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXITING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_exiting " "notifying exit with code=0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , code);
#line 137 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 5 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_exiting " "notifying exit with code=0x%02x" "\n", code);
#line 141 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_exiting(uint8_t code)
{
    if (true) {
        _nocheck__trace_gdbstub_op_exiting(code);
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_continue " "Continuing all CPUs" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 168 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 6 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_continue " "Continuing all CPUs" "\n");
#line 172 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_continue(void)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue();
    }
}

#define TRACE_GDBSTUB_OP_CONTINUE_CPU_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_CONTINUE_CPU) || \
    false)

static inline void _nocheck__trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_CONTINUE_CPU) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_continue_cpu " "Continuing CPU %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index);
#line 199 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 7 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_continue_cpu " "Continuing CPU %d" "\n", cpu_index);
#line 203 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_continue_cpu(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_continue_cpu(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_STEPPING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_STEPPING) || \
    false)

static inline void _nocheck__trace_gdbstub_op_stepping(int cpu_index)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_STEPPING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_stepping " "Stepping CPU %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cpu_index);
#line 230 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 8 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_stepping " "Stepping CPU %d" "\n", cpu_index);
#line 234 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_stepping(int cpu_index)
{
    if (true) {
        _nocheck__trace_gdbstub_op_stepping(cpu_index);
    }
}

#define TRACE_GDBSTUB_OP_EXTRA_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_OP_EXTRA_INFO) || \
    false)

static inline void _nocheck__trace_gdbstub_op_extra_info(const char * info)
{
    if (trace_event_get_state(TRACE_GDBSTUB_OP_EXTRA_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_op_extra_info " "Thread extra info: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , info);
#line 261 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 9 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_op_extra_info " "Thread extra info: %s" "\n", info);
#line 265 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_op_extra_info(const char * info)
{
    if (true) {
        _nocheck__trace_gdbstub_op_extra_info(info);
    }
}

#define TRACE_GDBSTUB_HIT_WATCHPOINT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHPOINT) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHPOINT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_watchpoint " "Watchpoint hit, type=\"%s\" cpu=%d, vaddr=0x%" PRIx64 "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , type, cpu_gdb_index, vaddr);
#line 292 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 10 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_watchpoint " "Watchpoint hit, type=\"%s\" cpu=%d, vaddr=0x%" PRIx64 "" "\n", type, cpu_gdb_index, vaddr);
#line 296 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_watchpoint(const char * type, int cpu_gdb_index, uint64_t vaddr)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchpoint(type, cpu_gdb_index, vaddr);
    }
}

#define TRACE_GDBSTUB_HIT_INTERNAL_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_INTERNAL_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_internal_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_INTERNAL_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_internal_error " "RUN_STATE_INTERNAL_ERROR" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 323 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 11 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_internal_error " "RUN_STATE_INTERNAL_ERROR" "\n");
#line 327 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_internal_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_internal_error();
    }
}

#define TRACE_GDBSTUB_HIT_BREAK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_BREAK) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_break(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_BREAK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_break " "RUN_STATE_DEBUG" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 354 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 12 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_break " "RUN_STATE_DEBUG" "\n");
#line 358 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_break(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_break();
    }
}

#define TRACE_GDBSTUB_HIT_PAUSED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_PAUSED) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_paused(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_PAUSED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_paused " "RUN_STATE_PAUSED" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 385 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 13 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_paused " "RUN_STATE_PAUSED" "\n");
#line 389 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_paused(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_paused();
    }
}

#define TRACE_GDBSTUB_HIT_SHUTDOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_SHUTDOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_shutdown(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_SHUTDOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_shutdown " "RUN_STATE_SHUTDOWN" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 416 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 14 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_shutdown " "RUN_STATE_SHUTDOWN" "\n");
#line 420 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_shutdown(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_shutdown();
    }
}

#define TRACE_GDBSTUB_HIT_IO_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_IO_ERROR) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_io_error(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_IO_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_io_error " "RUN_STATE_IO_ERROR" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 447 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 15 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_io_error " "RUN_STATE_IO_ERROR" "\n");
#line 451 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_io_error(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_io_error();
    }
}

#define TRACE_GDBSTUB_HIT_WATCHDOG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_WATCHDOG) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_watchdog(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_WATCHDOG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_watchdog " "RUN_STATE_WATCHDOG" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 478 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 16 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_watchdog " "RUN_STATE_WATCHDOG" "\n");
#line 482 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_watchdog(void)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_watchdog();
    }
}

#define TRACE_GDBSTUB_HIT_UNKNOWN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_HIT_UNKNOWN) || \
    false)

static inline void _nocheck__trace_gdbstub_hit_unknown(int state)
{
    if (trace_event_get_state(TRACE_GDBSTUB_HIT_UNKNOWN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_hit_unknown " "Unknown run state=0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state);
#line 509 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 17 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_hit_unknown " "Unknown run state=0x%x" "\n", state);
#line 513 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_hit_unknown(int state)
{
    if (true) {
        _nocheck__trace_gdbstub_hit_unknown(state);
    }
}

#define TRACE_GDBSTUB_IO_REPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_REPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_reply(const char * message)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_REPLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_reply " "Sent: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , message);
#line 540 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 18 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_io_reply " "Sent: %s" "\n", message);
#line 544 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_reply(const char * message)
{
    if (true) {
        _nocheck__trace_gdbstub_io_reply(message);
    }
}

#define TRACE_GDBSTUB_IO_BINARYREPLY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_BINARYREPLY) || \
    false)

static inline void _nocheck__trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_BINARYREPLY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 19 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_binaryreply " "0x%04zx: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ofs, line);
#line 571 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 19 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_io_binaryreply " "0x%04zx: %s" "\n", ofs, line);
#line 575 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_binaryreply(size_t ofs, const char * line)
{
    if (true) {
        _nocheck__trace_gdbstub_io_binaryreply(ofs, line);
    }
}

#define TRACE_GDBSTUB_IO_COMMAND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_COMMAND) || \
    false)

static inline void _nocheck__trace_gdbstub_io_command(const char * command)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_COMMAND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 20 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_command " "Received: %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , command);
#line 602 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 20 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_io_command " "Received: %s" "\n", command);
#line 606 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_command(const char * command)
{
    if (true) {
        _nocheck__trace_gdbstub_io_command(command);
    }
}

#define TRACE_GDBSTUB_IO_GOT_ACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_ACK) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_ack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_ACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 21 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_got_ack " "Got ACK" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 633 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 21 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_io_got_ack " "Got ACK" "\n");
#line 637 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_got_ack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_ack();
    }
}

#define TRACE_GDBSTUB_IO_GOT_UNEXPECTED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_IO_GOT_UNEXPECTED) || \
    false)

static inline void _nocheck__trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_IO_GOT_UNEXPECTED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 22 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_io_got_unexpected " "Got 0x%02x when expecting ACK/NACK" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 664 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 22 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_io_got_unexpected " "Got 0x%02x when expecting ACK/NACK" "\n", ch);
#line 668 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_io_got_unexpected(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_io_got_unexpected(ch);
    }
}

#define TRACE_GDBSTUB_ERR_GOT_NACK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GOT_NACK) || \
    false)

static inline void _nocheck__trace_gdbstub_err_got_nack(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GOT_NACK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_got_nack " "Got NACK, retransmitting" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 695 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 23 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_got_nack " "Got NACK, retransmitting" "\n");
#line 699 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_got_nack(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_got_nack();
    }
}

#define TRACE_GDBSTUB_ERR_GARBAGE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_GARBAGE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_garbage(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_GARBAGE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_garbage " "received garbage between packets: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 726 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 24 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_garbage " "received garbage between packets: 0x%02x" "\n", ch);
#line 730 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_garbage(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_garbage(ch);
    }
}

#define TRACE_GDBSTUB_ERR_OVERRUN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_OVERRUN) || \
    false)

static inline void _nocheck__trace_gdbstub_err_overrun(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_OVERRUN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_overrun " "command buffer overrun, dropping command" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 757 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 25 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_overrun " "command buffer overrun, dropping command" "\n");
#line 761 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_overrun(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_overrun();
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_REPEAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_REPEAT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_REPEAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_invalid_repeat " "got invalid RLE count: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 788 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 26 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_invalid_repeat " "got invalid RLE count: 0x%02x" "\n", ch);
#line 792 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_invalid_repeat(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_repeat(ch);
    }
}

#define TRACE_GDBSTUB_ERR_INVALID_RLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_INVALID_RLE) || \
    false)

static inline void _nocheck__trace_gdbstub_err_invalid_rle(void)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_INVALID_RLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_invalid_rle " "got invalid RLE sequence" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 819 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 27 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_invalid_rle " "got invalid RLE sequence" "\n");
#line 823 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_invalid_rle(void)
{
    if (true) {
        _nocheck__trace_gdbstub_err_invalid_rle();
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INVALID_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INVALID) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_checksum_invalid " "got invalid command checksum digit: 0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 850 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 28 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_checksum_invalid " "got invalid command checksum digit: 0x%02x" "\n", ch);
#line 854 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_checksum_invalid(uint8_t ch)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_invalid(ch);
    }
}

#define TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT) || \
    false)

static inline void _nocheck__trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (trace_event_get_state(TRACE_GDBSTUB_ERR_CHECKSUM_INCORRECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("%d@%zu.%06zu:gdbstub_err_checksum_incorrect " "got command packet with incorrect checksum, expected=0x%02x, received=0x%02x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , expected, got);
#line 881 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        } else {
#line 29 "C:/Users/seski/source/repos/xemu-uwp/gdbstub/trace-events"
            qemu_log("gdbstub_err_checksum_incorrect " "got command packet with incorrect checksum, expected=0x%02x, received=0x%02x" "\n", expected, got);
#line 885 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-gdbstub.h"
        }
    }
}

static inline void trace_gdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got)
{
    if (true) {
        _nocheck__trace_gdbstub_err_checksum_incorrect(expected, got);
    }
}
#endif /* TRACE_GDBSTUB_GENERATED_TRACERS_H */
