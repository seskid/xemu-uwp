/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE_UI_GENERATED_TRACERS_H
#define TRACE_UI_GENERATED_TRACERS_H

#include "trace/control.h"

extern TraceEvent _TRACE_CONSOLE_GFX_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_GFX_REUSE_EVENT;
extern TraceEvent _TRACE_CONSOLE_GFX_CLOSE_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_CSI_EVENT;
extern TraceEvent _TRACE_CONSOLE_PUTCHAR_UNHANDLED_EVENT;
extern TraceEvent _TRACE_CONSOLE_TXT_NEW_EVENT;
extern TraceEvent _TRACE_CONSOLE_SELECT_EVENT;
extern TraceEvent _TRACE_CONSOLE_REFRESH_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_FROM_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_EVENT;
extern TraceEvent _TRACE_DISPLAYSURFACE_FREE_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_REGISTER_EVENT;
extern TraceEvent _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_EVENT;
extern TraceEvent _TRACE_PPM_SAVE_EVENT;
extern TraceEvent _TRACE_GD_SWITCH_EVENT;
extern TraceEvent _TRACE_GD_UPDATE_EVENT;
extern TraceEvent _TRACE_GD_KEY_EVENT_EVENT;
extern TraceEvent _TRACE_GD_GRAB_EVENT;
extern TraceEvent _TRACE_GD_UNGRAB_EVENT;
extern TraceEvent _TRACE_GD_KEYMAP_WINDOWING_EVENT;
extern TraceEvent _TRACE_GD_GL_AREA_CREATE_CONTEXT_EVENT;
extern TraceEvent _TRACE_GD_GL_AREA_DESTROY_CONTEXT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_GUEST_LEDS_EVENT;
extern TraceEvent _TRACE_VNC_KEY_MAP_INIT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_EXT_EVENT;
extern TraceEvent _TRACE_VNC_KEY_EVENT_MAP_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_NUMLOCK_EVENT;
extern TraceEvent _TRACE_VNC_KEY_SYNC_CAPSLOCK_EVENT;
extern TraceEvent _TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_EVENT;
extern TraceEvent _TRACE_VNC_MSG_SERVER_AUDIO_END_EVENT;
extern TraceEvent _TRACE_VNC_MSG_SERVER_AUDIO_DATA_EVENT;
extern TraceEvent _TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_EVENT;
extern TraceEvent _TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_EVENT;
extern TraceEvent _TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_EVENT;
extern TraceEvent _TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_EVENT;
extern TraceEvent _TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_EVENT;
extern TraceEvent _TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_EOF_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_IO_ERROR_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_CONNECT_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_DISCONNECT_START_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_DISCONNECT_FINISH_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_IO_WRAP_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_FORCED_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_THROTTLE_AUDIO_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_EVENT;
extern TraceEvent _TRACE_VNC_CLIENT_OUTPUT_LIMIT_EVENT;
extern TraceEvent _TRACE_VNC_SERVER_DPY_PAGEFLIP_EVENT;
extern TraceEvent _TRACE_VNC_SERVER_DPY_RECREATE_EVENT;
extern TraceEvent _TRACE_VNC_JOB_ADD_RECT_EVENT;
extern TraceEvent _TRACE_VNC_JOB_DISCARD_RECT_EVENT;
extern TraceEvent _TRACE_VNC_JOB_CLAMP_RECT_EVENT;
extern TraceEvent _TRACE_VNC_JOB_CLAMPED_RECT_EVENT;
extern TraceEvent _TRACE_VNC_JOB_NRECTS_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_INIT_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_START_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_PASS_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_FAIL_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_REJECT_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_VENCRYPT_VERSION_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_MECH_LIST_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_MECH_CHOOSE_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_START_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_STEP_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_SSF_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_USERNAME_EVENT;
extern TraceEvent _TRACE_VNC_AUTH_SASL_ACL_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_NUMBER_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_KEY_QCODE_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_BTN_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_REL_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_ABS_EVENT;
extern TraceEvent _TRACE_INPUT_EVENT_SYNC_EVENT;
extern TraceEvent _TRACE_INPUT_MOUSE_MODE_EVENT;
extern TraceEvent _TRACE_SDL2_PROCESS_KEY_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_ADD_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DEL_MEMSLOT_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_WAKEUP_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_CREATE_UPDATE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_UPDATE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_DISPLAY_REFRESH_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_UI_INFO_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SURFACE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_CURSOR_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_RENDER_DMABUF_EVENT;
extern TraceEvent _TRACE_QEMU_SPICE_GL_UPDATE_EVENT;
extern TraceEvent _TRACE_KEYMAP_PARSE_EVENT;
extern TraceEvent _TRACE_KEYMAP_ADD_EVENT;
extern TraceEvent _TRACE_KEYMAP_UNMAPPED_EVENT;
extern TraceEvent _TRACE_XKEYMAP_EXTENSION_EVENT;
extern TraceEvent _TRACE_XKEYMAP_VENDOR_EVENT;
extern TraceEvent _TRACE_XKEYMAP_KEYCODES_EVENT;
extern TraceEvent _TRACE_XKEYMAP_KEYMAP_EVENT;
extern TraceEvent _TRACE_CLIPBOARD_CHECK_SERIAL_EVENT;
extern TraceEvent _TRACE_VDAGENT_OPEN_EVENT;
extern TraceEvent _TRACE_VDAGENT_CLOSE_EVENT;
extern TraceEvent _TRACE_VDAGENT_DISCONNECT_EVENT;
extern TraceEvent _TRACE_VDAGENT_SEND_EVENT;
extern TraceEvent _TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_EVENT;
extern TraceEvent _TRACE_VDAGENT_RECV_CHUNK_EVENT;
extern TraceEvent _TRACE_VDAGENT_RECV_MSG_EVENT;
extern TraceEvent _TRACE_VDAGENT_PEER_CAP_EVENT;
extern TraceEvent _TRACE_VDAGENT_CB_GRAB_SELECTION_EVENT;
extern TraceEvent _TRACE_VDAGENT_CB_GRAB_DISCARD_EVENT;
extern TraceEvent _TRACE_VDAGENT_CB_GRAB_TYPE_EVENT;
extern TraceEvent _TRACE_VDAGENT_CB_SERIAL_DISCARD_EVENT;
extern TraceEvent _TRACE_DBUS_REGISTERED_LISTENER_EVENT;
extern TraceEvent _TRACE_DBUS_LISTENER_VANISHED_EVENT;
extern TraceEvent _TRACE_DBUS_KBD_PRESS_EVENT;
extern TraceEvent _TRACE_DBUS_KBD_RELEASE_EVENT;
extern TraceEvent _TRACE_DBUS_MOUSE_PRESS_EVENT;
extern TraceEvent _TRACE_DBUS_MOUSE_RELEASE_EVENT;
extern TraceEvent _TRACE_DBUS_MOUSE_SET_POS_EVENT;
extern TraceEvent _TRACE_DBUS_MOUSE_REL_MOTION_EVENT;
extern TraceEvent _TRACE_DBUS_UPDATE_EVENT;
extern TraceEvent _TRACE_DBUS_CLIPBOARD_GRAB_FAILED_EVENT;
extern TraceEvent _TRACE_DBUS_CLIPBOARD_REGISTER_EVENT;
extern TraceEvent _TRACE_DBUS_CLIPBOARD_UNREGISTER_EVENT;
extern uint16_t _TRACE_CONSOLE_GFX_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_GFX_REUSE_DSTATE;
extern uint16_t _TRACE_CONSOLE_GFX_CLOSE_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_CSI_DSTATE;
extern uint16_t _TRACE_CONSOLE_PUTCHAR_UNHANDLED_DSTATE;
extern uint16_t _TRACE_CONSOLE_TXT_NEW_DSTATE;
extern uint16_t _TRACE_CONSOLE_SELECT_DSTATE;
extern uint16_t _TRACE_CONSOLE_REFRESH_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_FROM_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_CREATE_PIXMAN_DSTATE;
extern uint16_t _TRACE_DISPLAYSURFACE_FREE_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_REGISTER_DSTATE;
extern uint16_t _TRACE_DISPLAYCHANGELISTENER_UNREGISTER_DSTATE;
extern uint16_t _TRACE_PPM_SAVE_DSTATE;
extern uint16_t _TRACE_GD_SWITCH_DSTATE;
extern uint16_t _TRACE_GD_UPDATE_DSTATE;
extern uint16_t _TRACE_GD_KEY_EVENT_DSTATE;
extern uint16_t _TRACE_GD_GRAB_DSTATE;
extern uint16_t _TRACE_GD_UNGRAB_DSTATE;
extern uint16_t _TRACE_GD_KEYMAP_WINDOWING_DSTATE;
extern uint16_t _TRACE_GD_GL_AREA_CREATE_CONTEXT_DSTATE;
extern uint16_t _TRACE_GD_GL_AREA_DESTROY_CONTEXT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_GUEST_LEDS_DSTATE;
extern uint16_t _TRACE_VNC_KEY_MAP_INIT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_EXT_DSTATE;
extern uint16_t _TRACE_VNC_KEY_EVENT_MAP_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_NUMLOCK_DSTATE;
extern uint16_t _TRACE_VNC_KEY_SYNC_CAPSLOCK_DSTATE;
extern uint16_t _TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_DSTATE;
extern uint16_t _TRACE_VNC_MSG_SERVER_AUDIO_END_DSTATE;
extern uint16_t _TRACE_VNC_MSG_SERVER_AUDIO_DATA_DSTATE;
extern uint16_t _TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_DSTATE;
extern uint16_t _TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_DSTATE;
extern uint16_t _TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_DSTATE;
extern uint16_t _TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_DSTATE;
extern uint16_t _TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_DSTATE;
extern uint16_t _TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_EOF_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_IO_ERROR_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_CONNECT_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_DISCONNECT_START_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_DISCONNECT_FINISH_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_IO_WRAP_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_FORCED_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_THROTTLE_AUDIO_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_DSTATE;
extern uint16_t _TRACE_VNC_CLIENT_OUTPUT_LIMIT_DSTATE;
extern uint16_t _TRACE_VNC_SERVER_DPY_PAGEFLIP_DSTATE;
extern uint16_t _TRACE_VNC_SERVER_DPY_RECREATE_DSTATE;
extern uint16_t _TRACE_VNC_JOB_ADD_RECT_DSTATE;
extern uint16_t _TRACE_VNC_JOB_DISCARD_RECT_DSTATE;
extern uint16_t _TRACE_VNC_JOB_CLAMP_RECT_DSTATE;
extern uint16_t _TRACE_VNC_JOB_CLAMPED_RECT_DSTATE;
extern uint16_t _TRACE_VNC_JOB_NRECTS_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_INIT_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_START_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_PASS_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_FAIL_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_REJECT_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_VENCRYPT_VERSION_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_MECH_LIST_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_MECH_CHOOSE_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_START_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_STEP_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_SSF_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_USERNAME_DSTATE;
extern uint16_t _TRACE_VNC_AUTH_SASL_ACL_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_NUMBER_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_KEY_QCODE_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_BTN_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_REL_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_ABS_DSTATE;
extern uint16_t _TRACE_INPUT_EVENT_SYNC_DSTATE;
extern uint16_t _TRACE_INPUT_MOUSE_MODE_DSTATE;
extern uint16_t _TRACE_SDL2_PROCESS_KEY_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_ADD_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DEL_MEMSLOT_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_WAKEUP_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_CREATE_UPDATE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_UPDATE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_DISPLAY_REFRESH_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_UI_INFO_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SURFACE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_CURSOR_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_RENDER_DMABUF_DSTATE;
extern uint16_t _TRACE_QEMU_SPICE_GL_UPDATE_DSTATE;
extern uint16_t _TRACE_KEYMAP_PARSE_DSTATE;
extern uint16_t _TRACE_KEYMAP_ADD_DSTATE;
extern uint16_t _TRACE_KEYMAP_UNMAPPED_DSTATE;
extern uint16_t _TRACE_XKEYMAP_EXTENSION_DSTATE;
extern uint16_t _TRACE_XKEYMAP_VENDOR_DSTATE;
extern uint16_t _TRACE_XKEYMAP_KEYCODES_DSTATE;
extern uint16_t _TRACE_XKEYMAP_KEYMAP_DSTATE;
extern uint16_t _TRACE_CLIPBOARD_CHECK_SERIAL_DSTATE;
extern uint16_t _TRACE_VDAGENT_OPEN_DSTATE;
extern uint16_t _TRACE_VDAGENT_CLOSE_DSTATE;
extern uint16_t _TRACE_VDAGENT_DISCONNECT_DSTATE;
extern uint16_t _TRACE_VDAGENT_SEND_DSTATE;
extern uint16_t _TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_DSTATE;
extern uint16_t _TRACE_VDAGENT_RECV_CHUNK_DSTATE;
extern uint16_t _TRACE_VDAGENT_RECV_MSG_DSTATE;
extern uint16_t _TRACE_VDAGENT_PEER_CAP_DSTATE;
extern uint16_t _TRACE_VDAGENT_CB_GRAB_SELECTION_DSTATE;
extern uint16_t _TRACE_VDAGENT_CB_GRAB_DISCARD_DSTATE;
extern uint16_t _TRACE_VDAGENT_CB_GRAB_TYPE_DSTATE;
extern uint16_t _TRACE_VDAGENT_CB_SERIAL_DISCARD_DSTATE;
extern uint16_t _TRACE_DBUS_REGISTERED_LISTENER_DSTATE;
extern uint16_t _TRACE_DBUS_LISTENER_VANISHED_DSTATE;
extern uint16_t _TRACE_DBUS_KBD_PRESS_DSTATE;
extern uint16_t _TRACE_DBUS_KBD_RELEASE_DSTATE;
extern uint16_t _TRACE_DBUS_MOUSE_PRESS_DSTATE;
extern uint16_t _TRACE_DBUS_MOUSE_RELEASE_DSTATE;
extern uint16_t _TRACE_DBUS_MOUSE_SET_POS_DSTATE;
extern uint16_t _TRACE_DBUS_MOUSE_REL_MOTION_DSTATE;
extern uint16_t _TRACE_DBUS_UPDATE_DSTATE;
extern uint16_t _TRACE_DBUS_CLIPBOARD_GRAB_FAILED_DSTATE;
extern uint16_t _TRACE_DBUS_CLIPBOARD_REGISTER_DSTATE;
extern uint16_t _TRACE_DBUS_CLIPBOARD_UNREGISTER_DSTATE;
#define TRACE_CONSOLE_GFX_NEW_ENABLED 1
#define TRACE_CONSOLE_GFX_REUSE_ENABLED 1
#define TRACE_CONSOLE_GFX_CLOSE_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_CSI_ENABLED 1
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_ENABLED 1
#define TRACE_CONSOLE_TXT_NEW_ENABLED 1
#define TRACE_CONSOLE_SELECT_ENABLED 1
#define TRACE_CONSOLE_REFRESH_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_FROM_ENABLED 1
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_ENABLED 1
#define TRACE_DISPLAYSURFACE_FREE_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_REGISTER_ENABLED 1
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_ENABLED 1
#define TRACE_PPM_SAVE_ENABLED 1
#define TRACE_GD_SWITCH_ENABLED 1
#define TRACE_GD_UPDATE_ENABLED 1
#define TRACE_GD_KEY_EVENT_ENABLED 1
#define TRACE_GD_GRAB_ENABLED 1
#define TRACE_GD_UNGRAB_ENABLED 1
#define TRACE_GD_KEYMAP_WINDOWING_ENABLED 1
#define TRACE_GD_GL_AREA_CREATE_CONTEXT_ENABLED 1
#define TRACE_GD_GL_AREA_DESTROY_CONTEXT_ENABLED 1
#define TRACE_VNC_KEY_GUEST_LEDS_ENABLED 1
#define TRACE_VNC_KEY_MAP_INIT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_EXT_ENABLED 1
#define TRACE_VNC_KEY_EVENT_MAP_ENABLED 1
#define TRACE_VNC_KEY_SYNC_NUMLOCK_ENABLED 1
#define TRACE_VNC_KEY_SYNC_CAPSLOCK_ENABLED 1
#define TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_ENABLED 1
#define TRACE_VNC_MSG_SERVER_AUDIO_END_ENABLED 1
#define TRACE_VNC_MSG_SERVER_AUDIO_DATA_ENABLED 1
#define TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_ENABLED 1
#define TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_ENABLED 1
#define TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_ENABLED 1
#define TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_ENABLED 1
#define TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_ENABLED 1
#define TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_ENABLED 1
#define TRACE_VNC_CLIENT_EOF_ENABLED 1
#define TRACE_VNC_CLIENT_IO_ERROR_ENABLED 1
#define TRACE_VNC_CLIENT_CONNECT_ENABLED 1
#define TRACE_VNC_CLIENT_DISCONNECT_START_ENABLED 1
#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_ENABLED 1
#define TRACE_VNC_CLIENT_IO_WRAP_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_FORCED_ENABLED 1
#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_ENABLED 1
#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_ENABLED 1
#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_ENABLED 1
#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_ENABLED 1
#define TRACE_VNC_SERVER_DPY_PAGEFLIP_ENABLED 1
#define TRACE_VNC_SERVER_DPY_RECREATE_ENABLED 1
#define TRACE_VNC_JOB_ADD_RECT_ENABLED 1
#define TRACE_VNC_JOB_DISCARD_RECT_ENABLED 1
#define TRACE_VNC_JOB_CLAMP_RECT_ENABLED 1
#define TRACE_VNC_JOB_CLAMPED_RECT_ENABLED 1
#define TRACE_VNC_JOB_NRECTS_ENABLED 1
#define TRACE_VNC_AUTH_INIT_ENABLED 1
#define TRACE_VNC_AUTH_START_ENABLED 1
#define TRACE_VNC_AUTH_PASS_ENABLED 1
#define TRACE_VNC_AUTH_FAIL_ENABLED 1
#define TRACE_VNC_AUTH_REJECT_ENABLED 1
#define TRACE_VNC_AUTH_VENCRYPT_VERSION_ENABLED 1
#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_ENABLED 1
#define TRACE_VNC_AUTH_SASL_MECH_LIST_ENABLED 1
#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_ENABLED 1
#define TRACE_VNC_AUTH_SASL_START_ENABLED 1
#define TRACE_VNC_AUTH_SASL_STEP_ENABLED 1
#define TRACE_VNC_AUTH_SASL_SSF_ENABLED 1
#define TRACE_VNC_AUTH_SASL_USERNAME_ENABLED 1
#define TRACE_VNC_AUTH_SASL_ACL_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_NUMBER_ENABLED 1
#define TRACE_INPUT_EVENT_KEY_QCODE_ENABLED 1
#define TRACE_INPUT_EVENT_BTN_ENABLED 1
#define TRACE_INPUT_EVENT_REL_ENABLED 1
#define TRACE_INPUT_EVENT_ABS_ENABLED 1
#define TRACE_INPUT_EVENT_SYNC_ENABLED 1
#define TRACE_INPUT_MOUSE_MODE_ENABLED 1
#define TRACE_SDL2_PROCESS_KEY_ENABLED 1
#define TRACE_QEMU_SPICE_ADD_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_DEL_MEMSLOT_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_WAKEUP_ENABLED 1
#define TRACE_QEMU_SPICE_CREATE_UPDATE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_ENABLED 1
#define TRACE_QEMU_SPICE_UI_INFO_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SURFACE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_ENABLED 1
#define TRACE_QEMU_SPICE_GL_CURSOR_ENABLED 1
#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_ENABLED 1
#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_ENABLED 1
#define TRACE_QEMU_SPICE_GL_UPDATE_ENABLED 1
#define TRACE_KEYMAP_PARSE_ENABLED 1
#define TRACE_KEYMAP_ADD_ENABLED 1
#define TRACE_KEYMAP_UNMAPPED_ENABLED 1
#define TRACE_XKEYMAP_EXTENSION_ENABLED 1
#define TRACE_XKEYMAP_VENDOR_ENABLED 1
#define TRACE_XKEYMAP_KEYCODES_ENABLED 1
#define TRACE_XKEYMAP_KEYMAP_ENABLED 1
#define TRACE_CLIPBOARD_CHECK_SERIAL_ENABLED 1
#define TRACE_VDAGENT_OPEN_ENABLED 1
#define TRACE_VDAGENT_CLOSE_ENABLED 1
#define TRACE_VDAGENT_DISCONNECT_ENABLED 1
#define TRACE_VDAGENT_SEND_ENABLED 1
#define TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_ENABLED 1
#define TRACE_VDAGENT_RECV_CHUNK_ENABLED 1
#define TRACE_VDAGENT_RECV_MSG_ENABLED 1
#define TRACE_VDAGENT_PEER_CAP_ENABLED 1
#define TRACE_VDAGENT_CB_GRAB_SELECTION_ENABLED 1
#define TRACE_VDAGENT_CB_GRAB_DISCARD_ENABLED 1
#define TRACE_VDAGENT_CB_GRAB_TYPE_ENABLED 1
#define TRACE_VDAGENT_CB_SERIAL_DISCARD_ENABLED 1
#define TRACE_DBUS_REGISTERED_LISTENER_ENABLED 1
#define TRACE_DBUS_LISTENER_VANISHED_ENABLED 1
#define TRACE_DBUS_KBD_PRESS_ENABLED 1
#define TRACE_DBUS_KBD_RELEASE_ENABLED 1
#define TRACE_DBUS_MOUSE_PRESS_ENABLED 1
#define TRACE_DBUS_MOUSE_RELEASE_ENABLED 1
#define TRACE_DBUS_MOUSE_SET_POS_ENABLED 1
#define TRACE_DBUS_MOUSE_REL_MOTION_ENABLED 1
#define TRACE_DBUS_UPDATE_ENABLED 1
#define TRACE_DBUS_CLIPBOARD_GRAB_FAILED_ENABLED 1
#define TRACE_DBUS_CLIPBOARD_REGISTER_ENABLED 1
#define TRACE_DBUS_CLIPBOARD_UNREGISTER_ENABLED 1
#include "qemu/log-for-trace.h"
#include "qemu/error-report.h"


#define TRACE_CONSOLE_GFX_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_GFX_NEW) || \
    false)

static inline void _nocheck__trace_console_gfx_new(void)
{
    if (trace_event_get_state(TRACE_CONSOLE_GFX_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 4 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_gfx_new " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 415 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 4 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_gfx_new " "" "\n");
#line 419 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_gfx_new(void)
{
    if (true) {
        _nocheck__trace_console_gfx_new();
    }
}

#define TRACE_CONSOLE_GFX_REUSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_GFX_REUSE) || \
    false)

static inline void _nocheck__trace_console_gfx_reuse(int index)
{
    if (trace_event_get_state(TRACE_CONSOLE_GFX_REUSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 5 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_gfx_reuse " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 446 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 5 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_gfx_reuse " "%d" "\n", index);
#line 450 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_gfx_reuse(int index)
{
    if (true) {
        _nocheck__trace_console_gfx_reuse(index);
    }
}

#define TRACE_CONSOLE_GFX_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_GFX_CLOSE) || \
    false)

static inline void _nocheck__trace_console_gfx_close(int index)
{
    if (trace_event_get_state(TRACE_CONSOLE_GFX_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 6 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_gfx_close " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , index);
#line 477 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 6 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_gfx_close " "%d" "\n", index);
#line 481 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_gfx_close(int index)
{
    if (true) {
        _nocheck__trace_console_gfx_close(index);
    }
}

#define TRACE_CONSOLE_PUTCHAR_CSI_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_PUTCHAR_CSI) || \
    false)

static inline void _nocheck__trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params)
{
    if (trace_event_get_state(TRACE_CONSOLE_PUTCHAR_CSI) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 7 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_putchar_csi " "escape sequence CSI%d;%d%c, %d parameters" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , esc_param0, esc_param1, ch, nb_esc_params);
#line 508 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 7 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_putchar_csi " "escape sequence CSI%d;%d%c, %d parameters" "\n", esc_param0, esc_param1, ch, nb_esc_params);
#line 512 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params)
{
    if (true) {
        _nocheck__trace_console_putchar_csi(esc_param0, esc_param1, ch, nb_esc_params);
    }
}

#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_PUTCHAR_UNHANDLED) || \
    false)

static inline void _nocheck__trace_console_putchar_unhandled(int ch)
{
    if (trace_event_get_state(TRACE_CONSOLE_PUTCHAR_UNHANDLED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 8 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_putchar_unhandled " "unhandled escape character '%c'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ch);
#line 539 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 8 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_putchar_unhandled " "unhandled escape character '%c'" "\n", ch);
#line 543 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_putchar_unhandled(int ch)
{
    if (true) {
        _nocheck__trace_console_putchar_unhandled(ch);
    }
}

#define TRACE_CONSOLE_TXT_NEW_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_TXT_NEW) || \
    false)

static inline void _nocheck__trace_console_txt_new(int w, int h)
{
    if (trace_event_get_state(TRACE_CONSOLE_TXT_NEW) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 9 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_txt_new " "%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , w, h);
#line 570 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 9 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_txt_new " "%dx%d" "\n", w, h);
#line 574 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_txt_new(int w, int h)
{
    if (true) {
        _nocheck__trace_console_txt_new(w, h);
    }
}

#define TRACE_CONSOLE_SELECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_SELECT) || \
    false)

static inline void _nocheck__trace_console_select(int nr)
{
    if (trace_event_get_state(TRACE_CONSOLE_SELECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 10 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_select " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , nr);
#line 601 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 10 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_select " "%d" "\n", nr);
#line 605 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_select(int nr)
{
    if (true) {
        _nocheck__trace_console_select(nr);
    }
}

#define TRACE_CONSOLE_REFRESH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CONSOLE_REFRESH) || \
    false)

static inline void _nocheck__trace_console_refresh(int interval)
{
    if (trace_event_get_state(TRACE_CONSOLE_REFRESH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 11 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:console_refresh " "interval %d ms" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , interval);
#line 632 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 11 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("console_refresh " "interval %d ms" "\n", interval);
#line 636 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_console_refresh(int interval)
{
    if (true) {
        _nocheck__trace_console_refresh(interval);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYSURFACE_CREATE) || \
    false)

static inline void _nocheck__trace_displaysurface_create(void * display_surface, int w, int h)
{
    if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 12 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaysurface_create " "surface=%p, %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , display_surface, w, h);
#line 663 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 12 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaysurface_create " "surface=%p, %dx%d" "\n", display_surface, w, h);
#line 667 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaysurface_create(void * display_surface, int w, int h)
{
    if (true) {
        _nocheck__trace_displaysurface_create(display_surface, w, h);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_FROM_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYSURFACE_CREATE_FROM) || \
    false)

static inline void _nocheck__trace_displaysurface_create_from(void * display_surface, int w, int h, uint32_t format)
{
    if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE_FROM) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 13 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaysurface_create_from " "surface=%p, %dx%d, format 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , display_surface, w, h, format);
#line 694 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 13 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaysurface_create_from " "surface=%p, %dx%d, format 0x%x" "\n", display_surface, w, h, format);
#line 698 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaysurface_create_from(void * display_surface, int w, int h, uint32_t format)
{
    if (true) {
        _nocheck__trace_displaysurface_create_from(display_surface, w, h, format);
    }
}

#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYSURFACE_CREATE_PIXMAN) || \
    false)

static inline void _nocheck__trace_displaysurface_create_pixman(void * display_surface)
{
    if (trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE_PIXMAN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 14 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaysurface_create_pixman " "surface=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , display_surface);
#line 725 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 14 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaysurface_create_pixman " "surface=%p" "\n", display_surface);
#line 729 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaysurface_create_pixman(void * display_surface)
{
    if (true) {
        _nocheck__trace_displaysurface_create_pixman(display_surface);
    }
}

#define TRACE_DISPLAYSURFACE_FREE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYSURFACE_FREE) || \
    false)

static inline void _nocheck__trace_displaysurface_free(void * display_surface)
{
    if (trace_event_get_state(TRACE_DISPLAYSURFACE_FREE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 15 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaysurface_free " "surface=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , display_surface);
#line 756 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 15 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaysurface_free " "surface=%p" "\n", display_surface);
#line 760 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaysurface_free(void * display_surface)
{
    if (true) {
        _nocheck__trace_displaysurface_free(display_surface);
    }
}

#define TRACE_DISPLAYCHANGELISTENER_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYCHANGELISTENER_REGISTER) || \
    false)

static inline void _nocheck__trace_displaychangelistener_register(void * dcl, const char * name)
{
    if (trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 16 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaychangelistener_register " "%p [ %s ]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dcl, name);
#line 787 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 16 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaychangelistener_register " "%p [ %s ]" "\n", dcl, name);
#line 791 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaychangelistener_register(void * dcl, const char * name)
{
    if (true) {
        _nocheck__trace_displaychangelistener_register(dcl, name);
    }
}

#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DISPLAYCHANGELISTENER_UNREGISTER) || \
    false)

static inline void _nocheck__trace_displaychangelistener_unregister(void * dcl, const char * name)
{
    if (trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_UNREGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 17 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:displaychangelistener_unregister " "%p [ %s ]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dcl, name);
#line 818 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 17 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("displaychangelistener_unregister " "%p [ %s ]" "\n", dcl, name);
#line 822 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_displaychangelistener_unregister(void * dcl, const char * name)
{
    if (true) {
        _nocheck__trace_displaychangelistener_unregister(dcl, name);
    }
}

#define TRACE_PPM_SAVE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_PPM_SAVE) || \
    false)

static inline void _nocheck__trace_ppm_save(int fd, void * image)
{
    if (trace_event_get_state(TRACE_PPM_SAVE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 18 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:ppm_save " "fd=%d image=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , fd, image);
#line 849 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 18 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("ppm_save " "fd=%d image=%p" "\n", fd, image);
#line 853 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_ppm_save(int fd, void * image)
{
    if (true) {
        _nocheck__trace_ppm_save(fd, image);
    }
}

#define TRACE_GD_SWITCH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_SWITCH) || \
    false)

static inline void _nocheck__trace_gd_switch(const char * tab, int width, int height)
{
    if (trace_event_get_state(TRACE_GD_SWITCH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 23 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_switch " "tab=%s, width=%d, height=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tab, width, height);
#line 880 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 23 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_switch " "tab=%s, width=%d, height=%d" "\n", tab, width, height);
#line 884 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_switch(const char * tab, int width, int height)
{
    if (true) {
        _nocheck__trace_gd_switch(tab, width, height);
    }
}

#define TRACE_GD_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_UPDATE) || \
    false)

static inline void _nocheck__trace_gd_update(const char * tab, int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_GD_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 24 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_update " "tab=%s, x=%d, y=%d, w=%d, h=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tab, x, y, w, h);
#line 911 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 24 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_update " "tab=%s, x=%d, y=%d, w=%d, h=%d" "\n", tab, x, y, w, h);
#line 915 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_update(const char * tab, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_gd_update(tab, x, y, w, h);
    }
}

#define TRACE_GD_KEY_EVENT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_KEY_EVENT) || \
    false)

static inline void _nocheck__trace_gd_key_event(const char * tab, int gdk_keycode, int qkeycode, const char * action)
{
    if (trace_event_get_state(TRACE_GD_KEY_EVENT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 25 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_key_event " "tab=%s, translated GDK keycode %d to QKeyCode %d (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tab, gdk_keycode, qkeycode, action);
#line 942 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 25 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_key_event " "tab=%s, translated GDK keycode %d to QKeyCode %d (%s)" "\n", tab, gdk_keycode, qkeycode, action);
#line 946 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_key_event(const char * tab, int gdk_keycode, int qkeycode, const char * action)
{
    if (true) {
        _nocheck__trace_gd_key_event(tab, gdk_keycode, qkeycode, action);
    }
}

#define TRACE_GD_GRAB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_GRAB) || \
    false)

static inline void _nocheck__trace_gd_grab(const char * tab, const char * device, const char * reason)
{
    if (trace_event_get_state(TRACE_GD_GRAB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 26 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_grab " "tab=%s, dev=%s, reason=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tab, device, reason);
#line 973 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 26 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_grab " "tab=%s, dev=%s, reason=%s" "\n", tab, device, reason);
#line 977 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_grab(const char * tab, const char * device, const char * reason)
{
    if (true) {
        _nocheck__trace_gd_grab(tab, device, reason);
    }
}

#define TRACE_GD_UNGRAB_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_UNGRAB) || \
    false)

static inline void _nocheck__trace_gd_ungrab(const char * tab, const char * device)
{
    if (trace_event_get_state(TRACE_GD_UNGRAB) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 27 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_ungrab " "tab=%s, dev=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , tab, device);
#line 1004 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 27 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_ungrab " "tab=%s, dev=%s" "\n", tab, device);
#line 1008 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_ungrab(const char * tab, const char * device)
{
    if (true) {
        _nocheck__trace_gd_ungrab(tab, device);
    }
}

#define TRACE_GD_KEYMAP_WINDOWING_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_KEYMAP_WINDOWING) || \
    false)

static inline void _nocheck__trace_gd_keymap_windowing(const char * name)
{
    if (trace_event_get_state(TRACE_GD_KEYMAP_WINDOWING) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 28 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_keymap_windowing " "backend=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 1035 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 28 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_keymap_windowing " "backend=%s" "\n", name);
#line 1039 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_keymap_windowing(const char * name)
{
    if (true) {
        _nocheck__trace_gd_keymap_windowing(name);
    }
}

#define TRACE_GD_GL_AREA_CREATE_CONTEXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_GL_AREA_CREATE_CONTEXT) || \
    false)

static inline void _nocheck__trace_gd_gl_area_create_context(void * ctx, int major, int minor)
{
    if (trace_event_get_state(TRACE_GD_GL_AREA_CREATE_CONTEXT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 29 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_gl_area_create_context " "ctx=%p, major=%d, minor=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, major, minor);
#line 1066 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 29 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_gl_area_create_context " "ctx=%p, major=%d, minor=%d" "\n", ctx, major, minor);
#line 1070 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_gl_area_create_context(void * ctx, int major, int minor)
{
    if (true) {
        _nocheck__trace_gd_gl_area_create_context(ctx, major, minor);
    }
}

#define TRACE_GD_GL_AREA_DESTROY_CONTEXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_GD_GL_AREA_DESTROY_CONTEXT) || \
    false)

static inline void _nocheck__trace_gd_gl_area_destroy_context(void * ctx, void * current_ctx)
{
    if (trace_event_get_state(TRACE_GD_GL_AREA_DESTROY_CONTEXT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 30 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:gd_gl_area_destroy_context " "ctx=%p, current_ctx=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , ctx, current_ctx);
#line 1097 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 30 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("gd_gl_area_destroy_context " "ctx=%p, current_ctx=%p" "\n", ctx, current_ctx);
#line 1101 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_gd_gl_area_destroy_context(void * ctx, void * current_ctx)
{
    if (true) {
        _nocheck__trace_gd_gl_area_destroy_context(ctx, current_ctx);
    }
}

#define TRACE_VNC_KEY_GUEST_LEDS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_GUEST_LEDS) || \
    false)

static inline void _nocheck__trace_vnc_key_guest_leds(bool caps, bool num, bool scroll)
{
    if (trace_event_get_state(TRACE_VNC_KEY_GUEST_LEDS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 36 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_guest_leds " "caps %d, num %d, scroll %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , caps, num, scroll);
#line 1128 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 36 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_guest_leds " "caps %d, num %d, scroll %d" "\n", caps, num, scroll);
#line 1132 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_guest_leds(bool caps, bool num, bool scroll)
{
    if (true) {
        _nocheck__trace_vnc_key_guest_leds(caps, num, scroll);
    }
}

#define TRACE_VNC_KEY_MAP_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_MAP_INIT) || \
    false)

static inline void _nocheck__trace_vnc_key_map_init(const char * layout)
{
    if (trace_event_get_state(TRACE_VNC_KEY_MAP_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 37 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_map_init " "%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , layout);
#line 1159 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 37 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_map_init " "%s" "\n", layout);
#line 1163 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_map_init(const char * layout)
{
    if (true) {
        _nocheck__trace_vnc_key_map_init(layout);
    }
}

#define TRACE_VNC_KEY_EVENT_EXT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_EVENT_EXT) || \
    false)

static inline void _nocheck__trace_vnc_key_event_ext(bool down, int sym, int keycode, const char * name)
{
    if (trace_event_get_state(TRACE_VNC_KEY_EVENT_EXT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 38 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_event_ext " "down %d, sym 0x%x, keycode 0x%x [%s]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , down, sym, keycode, name);
#line 1190 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 38 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_event_ext " "down %d, sym 0x%x, keycode 0x%x [%s]" "\n", down, sym, keycode, name);
#line 1194 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_event_ext(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_key_event_ext(down, sym, keycode, name);
    }
}

#define TRACE_VNC_KEY_EVENT_MAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_EVENT_MAP) || \
    false)

static inline void _nocheck__trace_vnc_key_event_map(bool down, int sym, int keycode, const char * name)
{
    if (trace_event_get_state(TRACE_VNC_KEY_EVENT_MAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 39 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_event_map " "down %d, sym 0x%x -> keycode 0x%x [%s]" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , down, sym, keycode, name);
#line 1221 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 39 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_event_map " "down %d, sym 0x%x -> keycode 0x%x [%s]" "\n", down, sym, keycode, name);
#line 1225 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_event_map(bool down, int sym, int keycode, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_key_event_map(down, sym, keycode, name);
    }
}

#define TRACE_VNC_KEY_SYNC_NUMLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_SYNC_NUMLOCK) || \
    false)

static inline void _nocheck__trace_vnc_key_sync_numlock(bool on)
{
    if (trace_event_get_state(TRACE_VNC_KEY_SYNC_NUMLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 40 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_sync_numlock " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , on);
#line 1252 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 40 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_sync_numlock " "%d" "\n", on);
#line 1256 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_sync_numlock(bool on)
{
    if (true) {
        _nocheck__trace_vnc_key_sync_numlock(on);
    }
}

#define TRACE_VNC_KEY_SYNC_CAPSLOCK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_KEY_SYNC_CAPSLOCK) || \
    false)

static inline void _nocheck__trace_vnc_key_sync_capslock(bool on)
{
    if (trace_event_get_state(TRACE_VNC_KEY_SYNC_CAPSLOCK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 41 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_key_sync_capslock " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , on);
#line 1283 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 41 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_key_sync_capslock " "%d" "\n", on);
#line 1287 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_key_sync_capslock(bool on)
{
    if (true) {
        _nocheck__trace_vnc_key_sync_capslock(on);
    }
}

#define TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_SERVER_AUDIO_BEGIN) || \
    false)

static inline void _nocheck__trace_vnc_msg_server_audio_begin(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_MSG_SERVER_AUDIO_BEGIN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 42 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_server_audio_begin " "VNC server msg audio begin state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1314 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 42 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_server_audio_begin " "VNC server msg audio begin state=%p ioc=%p" "\n", state, ioc);
#line 1318 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_server_audio_begin(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_msg_server_audio_begin(state, ioc);
    }
}

#define TRACE_VNC_MSG_SERVER_AUDIO_END_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_SERVER_AUDIO_END) || \
    false)

static inline void _nocheck__trace_vnc_msg_server_audio_end(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_MSG_SERVER_AUDIO_END) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 43 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_server_audio_end " "VNC server msg audio end state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1345 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 43 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_server_audio_end " "VNC server msg audio end state=%p ioc=%p" "\n", state, ioc);
#line 1349 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_server_audio_end(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_msg_server_audio_end(state, ioc);
    }
}

#define TRACE_VNC_MSG_SERVER_AUDIO_DATA_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_SERVER_AUDIO_DATA) || \
    false)

static inline void _nocheck__trace_vnc_msg_server_audio_data(void * state, void * ioc, const void * buf, size_t len)
{
    if (trace_event_get_state(TRACE_VNC_MSG_SERVER_AUDIO_DATA) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 44 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_server_audio_data " "VNC server msg audio data state=%p ioc=%p buf=%p len=%zd" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, buf, len);
#line 1376 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 44 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_server_audio_data " "VNC server msg audio data state=%p ioc=%p buf=%p len=%zd" "\n", state, ioc, buf, len);
#line 1380 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_server_audio_data(void * state, void * ioc, const void * buf, size_t len)
{
    if (true) {
        _nocheck__trace_vnc_msg_server_audio_data(state, ioc, buf, len);
    }
}

#define TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE) || \
    false)

static inline void _nocheck__trace_vnc_msg_server_desktop_resize(void * state, void * ioc, int width, int height)
{
    if (trace_event_get_state(TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 45 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_server_desktop_resize " "VNC server msg ext resize state=%p ioc=%p size=%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, width, height);
#line 1407 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 45 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_server_desktop_resize " "VNC server msg ext resize state=%p ioc=%p size=%dx%d" "\n", state, ioc, width, height);
#line 1411 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_server_desktop_resize(void * state, void * ioc, int width, int height)
{
    if (true) {
        _nocheck__trace_vnc_msg_server_desktop_resize(state, ioc, width, height);
    }
}

#define TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE) || \
    false)

static inline void _nocheck__trace_vnc_msg_server_ext_desktop_resize(void * state, void * ioc, int width, int height, int reason)
{
    if (trace_event_get_state(TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 46 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_server_ext_desktop_resize " "VNC server msg ext resize state=%p ioc=%p size=%dx%d reason=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, width, height, reason);
#line 1438 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 46 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_server_ext_desktop_resize " "VNC server msg ext resize state=%p ioc=%p size=%dx%d reason=%d" "\n", state, ioc, width, height, reason);
#line 1442 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_server_ext_desktop_resize(void * state, void * ioc, int width, int height, int reason)
{
    if (true) {
        _nocheck__trace_vnc_msg_server_ext_desktop_resize(state, ioc, width, height, reason);
    }
}

#define TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE) || \
    false)

static inline void _nocheck__trace_vnc_msg_client_audio_enable(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 47 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_client_audio_enable " "VNC client msg audio enable state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1469 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 47 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_client_audio_enable " "VNC client msg audio enable state=%p ioc=%p" "\n", state, ioc);
#line 1473 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_client_audio_enable(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_msg_client_audio_enable(state, ioc);
    }
}

#define TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE) || \
    false)

static inline void _nocheck__trace_vnc_msg_client_audio_disable(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 48 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_client_audio_disable " "VNC client msg audio disable state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1500 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 48 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_client_audio_disable " "VNC client msg audio disable state=%p ioc=%p" "\n", state, ioc);
#line 1504 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_client_audio_disable(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_msg_client_audio_disable(state, ioc);
    }
}

#define TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT) || \
    false)

static inline void _nocheck__trace_vnc_msg_client_audio_format(void * state, void * ioc, int fmt, int channels, int freq)
{
    if (trace_event_get_state(TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 49 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_client_audio_format " "VNC client msg audio format state=%p ioc=%p fmt=%d channels=%d freq=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, fmt, channels, freq);
#line 1531 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 49 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_client_audio_format " "VNC client msg audio format state=%p ioc=%p fmt=%d channels=%d freq=%d" "\n", state, ioc, fmt, channels, freq);
#line 1535 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_client_audio_format(void * state, void * ioc, int fmt, int channels, int freq)
{
    if (true) {
        _nocheck__trace_vnc_msg_client_audio_format(state, ioc, fmt, channels, freq);
    }
}

#define TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE) || \
    false)

static inline void _nocheck__trace_vnc_msg_client_set_desktop_size(void * state, void * ioc, int width, int height, int screens)
{
    if (trace_event_get_state(TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 50 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_msg_client_set_desktop_size " "VNC client msg set desktop size  state=%p ioc=%p size=%dx%d screens=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, width, height, screens);
#line 1562 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 50 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_msg_client_set_desktop_size " "VNC client msg set desktop size  state=%p ioc=%p size=%dx%d screens=%d" "\n", state, ioc, width, height, screens);
#line 1566 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_msg_client_set_desktop_size(void * state, void * ioc, int width, int height, int screens)
{
    if (true) {
        _nocheck__trace_vnc_msg_client_set_desktop_size(state, ioc, width, height, screens);
    }
}

#define TRACE_VNC_CLIENT_EOF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_EOF) || \
    false)

static inline void _nocheck__trace_vnc_client_eof(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_EOF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 51 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_eof " "VNC client EOF state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1593 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 51 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_eof " "VNC client EOF state=%p ioc=%p" "\n", state, ioc);
#line 1597 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_eof(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_eof(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_IO_ERROR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_IO_ERROR) || \
    false)

static inline void _nocheck__trace_vnc_client_io_error(void * state, void * ioc, const char * msg)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_IO_ERROR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 52 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_io_error " "VNC client I/O error state=%p ioc=%p errmsg=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, msg);
#line 1624 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 52 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_io_error " "VNC client I/O error state=%p ioc=%p errmsg=%s" "\n", state, ioc, msg);
#line 1628 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_io_error(void * state, void * ioc, const char * msg)
{
    if (true) {
        _nocheck__trace_vnc_client_io_error(state, ioc, msg);
    }
}

#define TRACE_VNC_CLIENT_CONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_CONNECT) || \
    false)

static inline void _nocheck__trace_vnc_client_connect(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_CONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 53 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_connect " "VNC client connect state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1655 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 53 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_connect " "VNC client connect state=%p ioc=%p" "\n", state, ioc);
#line 1659 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_connect(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_connect(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_DISCONNECT_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_DISCONNECT_START) || \
    false)

static inline void _nocheck__trace_vnc_client_disconnect_start(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_DISCONNECT_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 54 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_disconnect_start " "VNC client disconnect start state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1686 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 54 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_disconnect_start " "VNC client disconnect start state=%p ioc=%p" "\n", state, ioc);
#line 1690 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_disconnect_start(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_disconnect_start(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_DISCONNECT_FINISH) || \
    false)

static inline void _nocheck__trace_vnc_client_disconnect_finish(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_DISCONNECT_FINISH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 55 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_disconnect_finish " "VNC client disconnect finish state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1717 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 55 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_disconnect_finish " "VNC client disconnect finish state=%p ioc=%p" "\n", state, ioc);
#line 1721 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_disconnect_finish(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_disconnect_finish(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_IO_WRAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_IO_WRAP) || \
    false)

static inline void _nocheck__trace_vnc_client_io_wrap(void * state, void * ioc, const char * type)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_IO_WRAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 56 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_io_wrap " "VNC client I/O wrap state=%p ioc=%p type=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, type);
#line 1748 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 56 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_io_wrap " "VNC client I/O wrap state=%p ioc=%p type=%s" "\n", state, ioc, type);
#line 1752 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_io_wrap(void * state, void * ioc, const char * type)
{
    if (true) {
        _nocheck__trace_vnc_client_io_wrap(state, ioc, type);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_THROTTLE_THRESHOLD) || \
    false)

static inline void _nocheck__trace_vnc_client_throttle_threshold(void * state, void * ioc, size_t oldoffset, size_t offset, int client_width, int client_height, int bytes_per_pixel, void * audio_cap)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_THROTTLE_THRESHOLD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 57 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_throttle_threshold " "VNC client throttle threshold state=%p ioc=%p oldoffset=%zu newoffset=%zu width=%d height=%d bpp=%d audio=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, oldoffset, offset, client_width, client_height, bytes_per_pixel, audio_cap);
#line 1779 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 57 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_throttle_threshold " "VNC client throttle threshold state=%p ioc=%p oldoffset=%zu newoffset=%zu width=%d height=%d bpp=%d audio=%p" "\n", state, ioc, oldoffset, offset, client_width, client_height, bytes_per_pixel, audio_cap);
#line 1783 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_throttle_threshold(void * state, void * ioc, size_t oldoffset, size_t offset, int client_width, int client_height, int bytes_per_pixel, void * audio_cap)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_threshold(state, ioc, oldoffset, offset, client_width, client_height, bytes_per_pixel, audio_cap);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL) || \
    false)

static inline void _nocheck__trace_vnc_client_throttle_incremental(void * state, void * ioc, int job_update, size_t offset)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 58 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_throttle_incremental " "VNC client throttle incremental state=%p ioc=%p job-update=%d offset=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, job_update, offset);
#line 1810 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 58 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_throttle_incremental " "VNC client throttle incremental state=%p ioc=%p job-update=%d offset=%zu" "\n", state, ioc, job_update, offset);
#line 1814 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_throttle_incremental(void * state, void * ioc, int job_update, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_incremental(state, ioc, job_update, offset);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_FORCED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_THROTTLE_FORCED) || \
    false)

static inline void _nocheck__trace_vnc_client_throttle_forced(void * state, void * ioc, int job_update, size_t offset)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_THROTTLE_FORCED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 59 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_throttle_forced " "VNC client throttle forced state=%p ioc=%p job-update=%d offset=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, job_update, offset);
#line 1841 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 59 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_throttle_forced " "VNC client throttle forced state=%p ioc=%p job-update=%d offset=%zu" "\n", state, ioc, job_update, offset);
#line 1845 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_throttle_forced(void * state, void * ioc, int job_update, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_forced(state, ioc, job_update, offset);
    }
}

#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_THROTTLE_AUDIO) || \
    false)

static inline void _nocheck__trace_vnc_client_throttle_audio(void * state, void * ioc, size_t offset)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_THROTTLE_AUDIO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 60 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_throttle_audio " "VNC client throttle audio state=%p ioc=%p offset=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, offset);
#line 1872 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 60 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_throttle_audio " "VNC client throttle audio state=%p ioc=%p offset=%zu" "\n", state, ioc, offset);
#line 1876 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_throttle_audio(void * state, void * ioc, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_throttle_audio(state, ioc, offset);
    }
}

#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_UNTHROTTLE_FORCED) || \
    false)

static inline void _nocheck__trace_vnc_client_unthrottle_forced(void * state, void * ioc)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_UNTHROTTLE_FORCED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 61 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_unthrottle_forced " "VNC client unthrottle forced offset state=%p ioc=%p" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc);
#line 1903 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 61 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_unthrottle_forced " "VNC client unthrottle forced offset state=%p ioc=%p" "\n", state, ioc);
#line 1907 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_unthrottle_forced(void * state, void * ioc)
{
    if (true) {
        _nocheck__trace_vnc_client_unthrottle_forced(state, ioc);
    }
}

#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL) || \
    false)

static inline void _nocheck__trace_vnc_client_unthrottle_incremental(void * state, void * ioc, size_t offset)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 62 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_unthrottle_incremental " "VNC client unthrottle incremental state=%p ioc=%p offset=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, offset);
#line 1934 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 62 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_unthrottle_incremental " "VNC client unthrottle incremental state=%p ioc=%p offset=%zu" "\n", state, ioc, offset);
#line 1938 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_unthrottle_incremental(void * state, void * ioc, size_t offset)
{
    if (true) {
        _nocheck__trace_vnc_client_unthrottle_incremental(state, ioc, offset);
    }
}

#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_CLIENT_OUTPUT_LIMIT) || \
    false)

static inline void _nocheck__trace_vnc_client_output_limit(void * state, void * ioc, size_t offset, size_t threshold)
{
    if (trace_event_get_state(TRACE_VNC_CLIENT_OUTPUT_LIMIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 63 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_client_output_limit " "VNC client output limit state=%p ioc=%p offset=%zu threshold=%zu" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ioc, offset, threshold);
#line 1965 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 63 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_client_output_limit " "VNC client output limit state=%p ioc=%p offset=%zu threshold=%zu" "\n", state, ioc, offset, threshold);
#line 1969 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_client_output_limit(void * state, void * ioc, size_t offset, size_t threshold)
{
    if (true) {
        _nocheck__trace_vnc_client_output_limit(state, ioc, offset, threshold);
    }
}

#define TRACE_VNC_SERVER_DPY_PAGEFLIP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_SERVER_DPY_PAGEFLIP) || \
    false)

static inline void _nocheck__trace_vnc_server_dpy_pageflip(void * dpy, int w, int h, int fmt)
{
    if (trace_event_get_state(TRACE_VNC_SERVER_DPY_PAGEFLIP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 64 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_server_dpy_pageflip " "VNC server dpy pageflip dpy=%p size=%dx%d fmt=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dpy, w, h, fmt);
#line 1996 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 64 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_server_dpy_pageflip " "VNC server dpy pageflip dpy=%p size=%dx%d fmt=%d" "\n", dpy, w, h, fmt);
#line 2000 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_server_dpy_pageflip(void * dpy, int w, int h, int fmt)
{
    if (true) {
        _nocheck__trace_vnc_server_dpy_pageflip(dpy, w, h, fmt);
    }
}

#define TRACE_VNC_SERVER_DPY_RECREATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_SERVER_DPY_RECREATE) || \
    false)

static inline void _nocheck__trace_vnc_server_dpy_recreate(void * dpy, int w, int h, int fmt)
{
    if (trace_event_get_state(TRACE_VNC_SERVER_DPY_RECREATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 65 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_server_dpy_recreate " "VNC server dpy recreate dpy=%p size=%dx%d fmt=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dpy, w, h, fmt);
#line 2027 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 65 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_server_dpy_recreate " "VNC server dpy recreate dpy=%p size=%dx%d fmt=%d" "\n", dpy, w, h, fmt);
#line 2031 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_server_dpy_recreate(void * dpy, int w, int h, int fmt)
{
    if (true) {
        _nocheck__trace_vnc_server_dpy_recreate(dpy, w, h, fmt);
    }
}

#define TRACE_VNC_JOB_ADD_RECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_JOB_ADD_RECT) || \
    false)

static inline void _nocheck__trace_vnc_job_add_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_VNC_JOB_ADD_RECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 66 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_job_add_rect " "VNC add rect state=%p job=%p offset=%d,%d size=%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, job, x, y, w, h);
#line 2058 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 66 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_job_add_rect " "VNC add rect state=%p job=%p offset=%d,%d size=%dx%d" "\n", state, job, x, y, w, h);
#line 2062 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_job_add_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_vnc_job_add_rect(state, job, x, y, w, h);
    }
}

#define TRACE_VNC_JOB_DISCARD_RECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_JOB_DISCARD_RECT) || \
    false)

static inline void _nocheck__trace_vnc_job_discard_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_VNC_JOB_DISCARD_RECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 67 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_job_discard_rect " "VNC job discard rect state=%p job=%p offset=%d,%d size=%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, job, x, y, w, h);
#line 2089 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 67 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_job_discard_rect " "VNC job discard rect state=%p job=%p offset=%d,%d size=%dx%d" "\n", state, job, x, y, w, h);
#line 2093 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_job_discard_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_vnc_job_discard_rect(state, job, x, y, w, h);
    }
}

#define TRACE_VNC_JOB_CLAMP_RECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_JOB_CLAMP_RECT) || \
    false)

static inline void _nocheck__trace_vnc_job_clamp_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_VNC_JOB_CLAMP_RECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 68 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_job_clamp_rect " "VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, job, x, y, w, h);
#line 2120 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 68 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_job_clamp_rect " "VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d" "\n", state, job, x, y, w, h);
#line 2124 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_job_clamp_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_vnc_job_clamp_rect(state, job, x, y, w, h);
    }
}

#define TRACE_VNC_JOB_CLAMPED_RECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_JOB_CLAMPED_RECT) || \
    false)

static inline void _nocheck__trace_vnc_job_clamped_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_VNC_JOB_CLAMPED_RECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 69 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_job_clamped_rect " "VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, job, x, y, w, h);
#line 2151 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 69 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_job_clamped_rect " "VNC job clamp rect state=%p job=%p offset=%d,%d size=%dx%d" "\n", state, job, x, y, w, h);
#line 2155 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_job_clamped_rect(void * state, void * job, int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_vnc_job_clamped_rect(state, job, x, y, w, h);
    }
}

#define TRACE_VNC_JOB_NRECTS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_JOB_NRECTS) || \
    false)

static inline void _nocheck__trace_vnc_job_nrects(void * state, void * job, int nrects)
{
    if (trace_event_get_state(TRACE_VNC_JOB_NRECTS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 70 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_job_nrects " "VNC job state=%p job=%p nrects=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, job, nrects);
#line 2182 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 70 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_job_nrects " "VNC job state=%p job=%p nrects=%d" "\n", state, job, nrects);
#line 2186 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_job_nrects(void * state, void * job, int nrects)
{
    if (true) {
        _nocheck__trace_vnc_job_nrects(state, job, nrects);
    }
}

#define TRACE_VNC_AUTH_INIT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_INIT) || \
    false)

static inline void _nocheck__trace_vnc_auth_init(void * display, int websock, int auth, int subauth)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_INIT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 71 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_init " "VNC auth init state=%p websock=%d auth=%d subauth=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , display, websock, auth, subauth);
#line 2213 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 71 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_init " "VNC auth init state=%p websock=%d auth=%d subauth=%d" "\n", display, websock, auth, subauth);
#line 2217 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_init(void * display, int websock, int auth, int subauth)
{
    if (true) {
        _nocheck__trace_vnc_auth_init(display, websock, auth, subauth);
    }
}

#define TRACE_VNC_AUTH_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_START) || \
    false)

static inline void _nocheck__trace_vnc_auth_start(void * state, int method)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 72 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_start " "VNC client auth start state=%p method=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, method);
#line 2244 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 72 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_start " "VNC client auth start state=%p method=%d" "\n", state, method);
#line 2248 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_start(void * state, int method)
{
    if (true) {
        _nocheck__trace_vnc_auth_start(state, method);
    }
}

#define TRACE_VNC_AUTH_PASS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_PASS) || \
    false)

static inline void _nocheck__trace_vnc_auth_pass(void * state, int method)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_PASS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 73 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_pass " "VNC client auth passed state=%p method=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, method);
#line 2275 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 73 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_pass " "VNC client auth passed state=%p method=%d" "\n", state, method);
#line 2279 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_pass(void * state, int method)
{
    if (true) {
        _nocheck__trace_vnc_auth_pass(state, method);
    }
}

#define TRACE_VNC_AUTH_FAIL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_FAIL) || \
    false)

static inline void _nocheck__trace_vnc_auth_fail(void * state, int method, const char * message, const char * reason)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_FAIL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 74 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_fail " "VNC client auth failed state=%p method=%d message=%s reason=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, method, message, reason);
#line 2306 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 74 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_fail " "VNC client auth failed state=%p method=%d message=%s reason=%s" "\n", state, method, message, reason);
#line 2310 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_fail(void * state, int method, const char * message, const char * reason)
{
    if (true) {
        _nocheck__trace_vnc_auth_fail(state, method, message, reason);
    }
}

#define TRACE_VNC_AUTH_REJECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_REJECT) || \
    false)

static inline void _nocheck__trace_vnc_auth_reject(void * state, int expect, int got)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_REJECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 75 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_reject " "VNC client auth rejected state=%p method expected=%d got=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, expect, got);
#line 2337 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 75 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_reject " "VNC client auth rejected state=%p method expected=%d got=%d" "\n", state, expect, got);
#line 2341 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_reject(void * state, int expect, int got)
{
    if (true) {
        _nocheck__trace_vnc_auth_reject(state, expect, got);
    }
}

#define TRACE_VNC_AUTH_VENCRYPT_VERSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_VENCRYPT_VERSION) || \
    false)

static inline void _nocheck__trace_vnc_auth_vencrypt_version(void * state, int major, int minor)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_VENCRYPT_VERSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 76 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_vencrypt_version " "VNC client auth vencrypt version state=%p major=%d minor=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, major, minor);
#line 2368 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 76 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_vencrypt_version " "VNC client auth vencrypt version state=%p major=%d minor=%d" "\n", state, major, minor);
#line 2372 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_vencrypt_version(void * state, int major, int minor)
{
    if (true) {
        _nocheck__trace_vnc_auth_vencrypt_version(state, major, minor);
    }
}

#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_VENCRYPT_SUBAUTH) || \
    false)

static inline void _nocheck__trace_vnc_auth_vencrypt_subauth(void * state, int auth)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_VENCRYPT_SUBAUTH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 77 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_vencrypt_subauth " "VNC client auth vencrypt subauth state=%p auth=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, auth);
#line 2399 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 77 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_vencrypt_subauth " "VNC client auth vencrypt subauth state=%p auth=%d" "\n", state, auth);
#line 2403 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_vencrypt_subauth(void * state, int auth)
{
    if (true) {
        _nocheck__trace_vnc_auth_vencrypt_subauth(state, auth);
    }
}

#define TRACE_VNC_AUTH_SASL_MECH_LIST_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_MECH_LIST) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_mech_list(void * state, const char * mechs)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_MECH_LIST) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 78 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_mech_list " "VNC client auth SASL state=%p mechlist=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, mechs);
#line 2430 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 78 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_mech_list " "VNC client auth SASL state=%p mechlist=%s" "\n", state, mechs);
#line 2434 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_mech_list(void * state, const char * mechs)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_mech_list(state, mechs);
    }
}

#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_MECH_CHOOSE) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_mech_choose(void * state, const char * mech)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_MECH_CHOOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 79 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_mech_choose " "VNC client auth SASL state=%p mech=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, mech);
#line 2461 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 79 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_mech_choose " "VNC client auth SASL state=%p mech=%s" "\n", state, mech);
#line 2465 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_mech_choose(void * state, const char * mech)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_mech_choose(state, mech);
    }
}

#define TRACE_VNC_AUTH_SASL_START_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_START) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_start(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_START) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 80 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_start " "VNC client auth SASL start state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, clientdata, clientlen, serverdata, severlen, ret);
#line 2492 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 80 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_start " "VNC client auth SASL start state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d" "\n", state, clientdata, clientlen, serverdata, severlen, ret);
#line 2496 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_start(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_start(state, clientdata, clientlen, serverdata, severlen, ret);
    }
}

#define TRACE_VNC_AUTH_SASL_STEP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_STEP) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_step(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_STEP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 81 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_step " "VNC client auth SASL step state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, clientdata, clientlen, serverdata, severlen, ret);
#line 2523 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 81 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_step " "VNC client auth SASL step state=%p clientdata=%p clientlen=%zu serverdata=%p serverlen=%zu ret=%d" "\n", state, clientdata, clientlen, serverdata, severlen, ret);
#line 2527 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_step(void * state, const void * clientdata, size_t clientlen, const void * serverdata, size_t severlen, int ret)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_step(state, clientdata, clientlen, serverdata, severlen, ret);
    }
}

#define TRACE_VNC_AUTH_SASL_SSF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_SSF) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_ssf(void * state, int ssf)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_SSF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 82 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_ssf " "VNC client auth SASL SSF state=%p size=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, ssf);
#line 2554 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 82 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_ssf " "VNC client auth SASL SSF state=%p size=%d" "\n", state, ssf);
#line 2558 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_ssf(void * state, int ssf)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_ssf(state, ssf);
    }
}

#define TRACE_VNC_AUTH_SASL_USERNAME_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_USERNAME) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_username(void * state, const char * name)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_USERNAME) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 83 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_username " "VNC client auth SASL user state=%p name=%s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, name);
#line 2585 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 83 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_username " "VNC client auth SASL user state=%p name=%s" "\n", state, name);
#line 2589 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_username(void * state, const char * name)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_username(state, name);
    }
}

#define TRACE_VNC_AUTH_SASL_ACL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VNC_AUTH_SASL_ACL) || \
    false)

static inline void _nocheck__trace_vnc_auth_sasl_acl(void * state, int allow)
{
    if (trace_event_get_state(TRACE_VNC_AUTH_SASL_ACL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 84 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vnc_auth_sasl_acl " "VNC client auth SASL ACL state=%p allow=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , state, allow);
#line 2616 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 84 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vnc_auth_sasl_acl " "VNC client auth SASL ACL state=%p allow=%d" "\n", state, allow);
#line 2620 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vnc_auth_sasl_acl(void * state, int allow)
{
    if (true) {
        _nocheck__trace_vnc_auth_sasl_acl(state, allow);
    }
}

#define TRACE_INPUT_EVENT_KEY_NUMBER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_KEY_NUMBER) || \
    false)

static inline void _nocheck__trace_input_event_key_number(int conidx, int number, const char * qcode, bool down)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_KEY_NUMBER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 88 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_key_number " "con %d, key number 0x%x [%s], down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , conidx, number, qcode, down);
#line 2647 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 88 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_key_number " "con %d, key number 0x%x [%s], down %d" "\n", conidx, number, qcode, down);
#line 2651 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_key_number(int conidx, int number, const char * qcode, bool down)
{
    if (true) {
        _nocheck__trace_input_event_key_number(conidx, number, qcode, down);
    }
}

#define TRACE_INPUT_EVENT_KEY_QCODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_KEY_QCODE) || \
    false)

static inline void _nocheck__trace_input_event_key_qcode(int conidx, const char * qcode, bool down)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_KEY_QCODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 89 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_key_qcode " "con %d, key qcode %s, down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , conidx, qcode, down);
#line 2678 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 89 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_key_qcode " "con %d, key qcode %s, down %d" "\n", conidx, qcode, down);
#line 2682 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_key_qcode(int conidx, const char * qcode, bool down)
{
    if (true) {
        _nocheck__trace_input_event_key_qcode(conidx, qcode, down);
    }
}

#define TRACE_INPUT_EVENT_BTN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_BTN) || \
    false)

static inline void _nocheck__trace_input_event_btn(int conidx, const char * btn, bool down)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_BTN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 90 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_btn " "con %d, button %s, down %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , conidx, btn, down);
#line 2709 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 90 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_btn " "con %d, button %s, down %d" "\n", conidx, btn, down);
#line 2713 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_btn(int conidx, const char * btn, bool down)
{
    if (true) {
        _nocheck__trace_input_event_btn(conidx, btn, down);
    }
}

#define TRACE_INPUT_EVENT_REL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_REL) || \
    false)

static inline void _nocheck__trace_input_event_rel(int conidx, const char * axis, int value)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_REL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 91 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_rel " "con %d, axis %s, value %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , conidx, axis, value);
#line 2740 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 91 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_rel " "con %d, axis %s, value %d" "\n", conidx, axis, value);
#line 2744 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_rel(int conidx, const char * axis, int value)
{
    if (true) {
        _nocheck__trace_input_event_rel(conidx, axis, value);
    }
}

#define TRACE_INPUT_EVENT_ABS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_ABS) || \
    false)

static inline void _nocheck__trace_input_event_abs(int conidx, const char * axis, int value)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_ABS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 92 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_abs " "con %d, axis %s, value 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , conidx, axis, value);
#line 2771 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 92 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_abs " "con %d, axis %s, value 0x%x" "\n", conidx, axis, value);
#line 2775 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_abs(int conidx, const char * axis, int value)
{
    if (true) {
        _nocheck__trace_input_event_abs(conidx, axis, value);
    }
}

#define TRACE_INPUT_EVENT_SYNC_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_EVENT_SYNC) || \
    false)

static inline void _nocheck__trace_input_event_sync(void)
{
    if (trace_event_get_state(TRACE_INPUT_EVENT_SYNC) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 93 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_event_sync " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 2802 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 93 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_event_sync " "" "\n");
#line 2806 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_event_sync(void)
{
    if (true) {
        _nocheck__trace_input_event_sync();
    }
}

#define TRACE_INPUT_MOUSE_MODE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_INPUT_MOUSE_MODE) || \
    false)

static inline void _nocheck__trace_input_mouse_mode(int absolute)
{
    if (trace_event_get_state(TRACE_INPUT_MOUSE_MODE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 94 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:input_mouse_mode " "absolute %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , absolute);
#line 2833 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 94 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("input_mouse_mode " "absolute %d" "\n", absolute);
#line 2837 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_input_mouse_mode(int absolute)
{
    if (true) {
        _nocheck__trace_input_mouse_mode(absolute);
    }
}

#define TRACE_SDL2_PROCESS_KEY_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_SDL2_PROCESS_KEY) || \
    false)

static inline void _nocheck__trace_sdl2_process_key(int sdl_scancode, int qcode, const char * action)
{
    if (trace_event_get_state(TRACE_SDL2_PROCESS_KEY) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 97 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:sdl2_process_key " "translated SDL scancode %d to QKeyCode %d (%s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sdl_scancode, qcode, action);
#line 2864 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 97 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("sdl2_process_key " "translated SDL scancode %d to QKeyCode %d (%s)" "\n", sdl_scancode, qcode, action);
#line 2868 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_sdl2_process_key(int sdl_scancode, int qcode, const char * action)
{
    if (true) {
        _nocheck__trace_sdl2_process_key(sdl_scancode, qcode, action);
    }
}

#define TRACE_QEMU_SPICE_ADD_MEMSLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_ADD_MEMSLOT) || \
    false)

static inline void _nocheck__trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_ADD_MEMSLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 100 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_add_memslot " "%d %u: host virt 0x%lx - 0x%lx async=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, slot_id, virt_start, virt_end, async);
#line 2895 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 100 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_add_memslot " "%d %u: host virt 0x%lx - 0x%lx async=%d" "\n", qid, slot_id, virt_start, virt_end, async);
#line 2899 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_add_memslot(qid, slot_id, virt_start, virt_end, async);
    }
}

#define TRACE_QEMU_SPICE_DEL_MEMSLOT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_DEL_MEMSLOT) || \
    false)

static inline void _nocheck__trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_DEL_MEMSLOT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 101 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_del_memslot " "%d gid=%u sid=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, gid, slot_id);
#line 2926 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 101 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_del_memslot " "%d gid=%u sid=%u" "\n", qid, gid, slot_id);
#line 2930 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
    if (true) {
        _nocheck__trace_qemu_spice_del_memslot(qid, gid, slot_id);
    }
}

#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE) || \
    false)

static inline void _nocheck__trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 102 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_create_primary_surface " "%d sid=%u surface=%p async=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, sid, surface, async);
#line 2957 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 102 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_create_primary_surface " "%d sid=%u surface=%p async=%d" "\n", qid, sid, surface, async);
#line 2961 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_create_primary_surface(qid, sid, surface, async);
    }
}

#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE) || \
    false)

static inline void _nocheck__trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 103 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_destroy_primary_surface " "%d sid=%u async=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, sid, async);
#line 2988 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 103 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_destroy_primary_surface " "%d sid=%u async=%d" "\n", qid, sid, async);
#line 2992 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
    if (true) {
        _nocheck__trace_qemu_spice_destroy_primary_surface(qid, sid, async);
    }
}

#define TRACE_QEMU_SPICE_WAKEUP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_WAKEUP) || \
    false)

static inline void _nocheck__trace_qemu_spice_wakeup(uint32_t qid)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_WAKEUP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 104 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_wakeup " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 3019 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 104 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_wakeup " "%d" "\n", qid);
#line 3023 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_wakeup(uint32_t qid)
{
    if (true) {
        _nocheck__trace_qemu_spice_wakeup(qid);
    }
}

#define TRACE_QEMU_SPICE_CREATE_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_CREATE_UPDATE) || \
    false)

static inline void _nocheck__trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_CREATE_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 105 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_create_update " "lr %d -> %d,  tb -> %d -> %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , left, right, top, bottom);
#line 3050 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 105 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_create_update " "lr %d -> %d,  tb -> %d -> %d" "\n", left, right, top, bottom);
#line 3054 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    if (true) {
        _nocheck__trace_qemu_spice_create_update(left, right, top, bottom);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_DISPLAY_UPDATE) || \
    false)

static inline void _nocheck__trace_qemu_spice_display_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_DISPLAY_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 106 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_display_update " "%d +%d+%d %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, x, y, w, h);
#line 3081 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 106 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_display_update " "%d +%d+%d %dx%d" "\n", qid, x, y, w, h);
#line 3085 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_display_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_update(qid, x, y, w, h);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_DISPLAY_SURFACE) || \
    false)

static inline void _nocheck__trace_qemu_spice_display_surface(int qid, uint32_t w, uint32_t h, int fast)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_DISPLAY_SURFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 107 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_display_surface " "%d %dx%d, fast %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, w, h, fast);
#line 3112 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 107 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_display_surface " "%d %dx%d, fast %d" "\n", qid, w, h, fast);
#line 3116 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_display_surface(int qid, uint32_t w, uint32_t h, int fast)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_surface(qid, w, h, fast);
    }
}

#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_DISPLAY_REFRESH) || \
    false)

static inline void _nocheck__trace_qemu_spice_display_refresh(int qid, int notify)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_DISPLAY_REFRESH) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 108 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_display_refresh " "%d notify %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, notify);
#line 3143 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 108 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_display_refresh " "%d notify %d" "\n", qid, notify);
#line 3147 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_display_refresh(int qid, int notify)
{
    if (true) {
        _nocheck__trace_qemu_spice_display_refresh(qid, notify);
    }
}

#define TRACE_QEMU_SPICE_UI_INFO_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_UI_INFO) || \
    false)

static inline void _nocheck__trace_qemu_spice_ui_info(int qid, uint32_t width, uint32_t height)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_UI_INFO) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 109 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_ui_info " "%d %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, width, height);
#line 3174 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 109 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_ui_info " "%d %dx%d" "\n", qid, width, height);
#line 3178 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_ui_info(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_ui_info(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_SURFACE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_SURFACE) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_surface(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_SURFACE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 111 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_surface " "%d %dx%d, fourcc 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, w, h, fourcc);
#line 3205 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 111 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_surface " "%d %dx%d, fourcc 0x%x" "\n", qid, w, h, fourcc);
#line 3209 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_surface(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_surface(qid, w, h, fourcc);
    }
}

#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_scanout_disable(int qid)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 112 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_scanout_disable " "%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid);
#line 3236 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 112 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_scanout_disable " "%d" "\n", qid);
#line 3240 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_scanout_disable(int qid)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_scanout_disable(qid);
    }
}

#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_scanout_texture(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 113 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_scanout_texture " "%d %dx%d, fourcc 0x%x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, w, h, fourcc);
#line 3267 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 113 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_scanout_texture " "%d %dx%d, fourcc 0x%x" "\n", qid, w, h, fourcc);
#line 3271 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_scanout_texture(int qid, uint32_t w, uint32_t h, uint32_t fourcc)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_scanout_texture(qid, w, h, fourcc);
    }
}

#define TRACE_QEMU_SPICE_GL_CURSOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_CURSOR) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_cursor(int qid, bool enabled, bool hotspot)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_CURSOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 114 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_cursor " "%d enabled %d, hotspot %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, enabled, hotspot);
#line 3298 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 114 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_cursor " "%d enabled %d, hotspot %d" "\n", qid, enabled, hotspot);
#line 3302 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_cursor(int qid, bool enabled, bool hotspot)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_cursor(qid, enabled, hotspot);
    }
}

#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_FORWARD_DMABUF) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_forward_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_FORWARD_DMABUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 115 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_forward_dmabuf " "%d %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, width, height);
#line 3329 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 115 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_forward_dmabuf " "%d %dx%d" "\n", qid, width, height);
#line 3333 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_forward_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_forward_dmabuf(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_RENDER_DMABUF) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_render_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_RENDER_DMABUF) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 116 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_render_dmabuf " "%d %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, width, height);
#line 3360 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 116 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_render_dmabuf " "%d %dx%d" "\n", qid, width, height);
#line 3364 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_render_dmabuf(int qid, uint32_t width, uint32_t height)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_render_dmabuf(qid, width, height);
    }
}

#define TRACE_QEMU_SPICE_GL_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_QEMU_SPICE_GL_UPDATE) || \
    false)

static inline void _nocheck__trace_qemu_spice_gl_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (trace_event_get_state(TRACE_QEMU_SPICE_GL_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 117 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:qemu_spice_gl_update " "%d +%d+%d %dx%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , qid, x, y, w, h);
#line 3391 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 117 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("qemu_spice_gl_update " "%d +%d+%d %dx%d" "\n", qid, x, y, w, h);
#line 3395 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_qemu_spice_gl_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h)
{
    if (true) {
        _nocheck__trace_qemu_spice_gl_update(qid, x, y, w, h);
    }
}

#define TRACE_KEYMAP_PARSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KEYMAP_PARSE) || \
    false)

static inline void _nocheck__trace_keymap_parse(const char * file)
{
    if (trace_event_get_state(TRACE_KEYMAP_PARSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 120 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:keymap_parse " "file %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , file);
#line 3422 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 120 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("keymap_parse " "file %s" "\n", file);
#line 3426 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_keymap_parse(const char * file)
{
    if (true) {
        _nocheck__trace_keymap_parse(file);
    }
}

#define TRACE_KEYMAP_ADD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KEYMAP_ADD) || \
    false)

static inline void _nocheck__trace_keymap_add(int sym, int code, const char * line)
{
    if (trace_event_get_state(TRACE_KEYMAP_ADD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 121 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:keymap_add " "sym=0x%04x code=0x%04x (line: %s)" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sym, code, line);
#line 3453 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 121 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("keymap_add " "sym=0x%04x code=0x%04x (line: %s)" "\n", sym, code, line);
#line 3457 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_keymap_add(int sym, int code, const char * line)
{
    if (true) {
        _nocheck__trace_keymap_add(sym, code, line);
    }
}

#define TRACE_KEYMAP_UNMAPPED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_KEYMAP_UNMAPPED) || \
    false)

static inline void _nocheck__trace_keymap_unmapped(int sym)
{
    if (trace_event_get_state(TRACE_KEYMAP_UNMAPPED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 122 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:keymap_unmapped " "sym=0x%04x" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , sym);
#line 3484 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 122 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("keymap_unmapped " "sym=0x%04x" "\n", sym);
#line 3488 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_keymap_unmapped(int sym)
{
    if (true) {
        _nocheck__trace_keymap_unmapped(sym);
    }
}

#define TRACE_XKEYMAP_EXTENSION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XKEYMAP_EXTENSION) || \
    false)

static inline void _nocheck__trace_xkeymap_extension(const char * name)
{
    if (trace_event_get_state(TRACE_XKEYMAP_EXTENSION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 125 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:xkeymap_extension " "extension '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3515 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 125 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("xkeymap_extension " "extension '%s'" "\n", name);
#line 3519 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_xkeymap_extension(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_extension(name);
    }
}

#define TRACE_XKEYMAP_VENDOR_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XKEYMAP_VENDOR) || \
    false)

static inline void _nocheck__trace_xkeymap_vendor(const char * name)
{
    if (trace_event_get_state(TRACE_XKEYMAP_VENDOR) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 126 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:xkeymap_vendor " "vendor '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3546 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 126 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("xkeymap_vendor " "vendor '%s'" "\n", name);
#line 3550 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_xkeymap_vendor(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_vendor(name);
    }
}

#define TRACE_XKEYMAP_KEYCODES_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XKEYMAP_KEYCODES) || \
    false)

static inline void _nocheck__trace_xkeymap_keycodes(const char * name)
{
    if (trace_event_get_state(TRACE_XKEYMAP_KEYCODES) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 127 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:xkeymap_keycodes " "keycodes '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3577 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 127 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("xkeymap_keycodes " "keycodes '%s'" "\n", name);
#line 3581 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_xkeymap_keycodes(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_keycodes(name);
    }
}

#define TRACE_XKEYMAP_KEYMAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_XKEYMAP_KEYMAP) || \
    false)

static inline void _nocheck__trace_xkeymap_keymap(const char * name)
{
    if (trace_event_get_state(TRACE_XKEYMAP_KEYMAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 128 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:xkeymap_keymap " "keymap '%s'" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3608 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 128 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("xkeymap_keymap " "keymap '%s'" "\n", name);
#line 3612 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_xkeymap_keymap(const char * name)
{
    if (true) {
        _nocheck__trace_xkeymap_keymap(name);
    }
}

#define TRACE_CLIPBOARD_CHECK_SERIAL_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_CLIPBOARD_CHECK_SERIAL) || \
    false)

static inline void _nocheck__trace_clipboard_check_serial(int cur, int recv, bool ok)
{
    if (trace_event_get_state(TRACE_CLIPBOARD_CHECK_SERIAL) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 131 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:clipboard_check_serial " "cur:%d recv:%d %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , cur, recv, ok);
#line 3639 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 131 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("clipboard_check_serial " "cur:%d recv:%d %d" "\n", cur, recv, ok);
#line 3643 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_clipboard_check_serial(int cur, int recv, bool ok)
{
    if (true) {
        _nocheck__trace_clipboard_check_serial(cur, recv, ok);
    }
}

#define TRACE_VDAGENT_OPEN_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_OPEN) || \
    false)

static inline void _nocheck__trace_vdagent_open(void)
{
    if (trace_event_get_state(TRACE_VDAGENT_OPEN) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 134 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_open " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3670 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 134 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_open " "" "\n");
#line 3674 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_open(void)
{
    if (true) {
        _nocheck__trace_vdagent_open();
    }
}

#define TRACE_VDAGENT_CLOSE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_CLOSE) || \
    false)

static inline void _nocheck__trace_vdagent_close(void)
{
    if (trace_event_get_state(TRACE_VDAGENT_CLOSE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 135 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_close " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3701 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 135 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_close " "" "\n");
#line 3705 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_close(void)
{
    if (true) {
        _nocheck__trace_vdagent_close();
    }
}

#define TRACE_VDAGENT_DISCONNECT_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_DISCONNECT) || \
    false)

static inline void _nocheck__trace_vdagent_disconnect(void)
{
    if (trace_event_get_state(TRACE_VDAGENT_DISCONNECT) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 136 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_disconnect " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3732 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 136 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_disconnect " "" "\n");
#line 3736 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_disconnect(void)
{
    if (true) {
        _nocheck__trace_vdagent_disconnect();
    }
}

#define TRACE_VDAGENT_SEND_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_SEND) || \
    false)

static inline void _nocheck__trace_vdagent_send(const char * name)
{
    if (trace_event_get_state(TRACE_VDAGENT_SEND) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 137 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_send " "msg %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3763 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 137 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_send " "msg %s" "\n", name);
#line 3767 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_send(const char * name)
{
    if (true) {
        _nocheck__trace_vdagent_send(name);
    }
}

#define TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD) || \
    false)

static inline void _nocheck__trace_vdagent_send_empty_clipboard(void)
{
    if (trace_event_get_state(TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 138 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_send_empty_clipboard " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 3794 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 138 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_send_empty_clipboard " "" "\n");
#line 3798 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_send_empty_clipboard(void)
{
    if (true) {
        _nocheck__trace_vdagent_send_empty_clipboard();
    }
}

#define TRACE_VDAGENT_RECV_CHUNK_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_RECV_CHUNK) || \
    false)

static inline void _nocheck__trace_vdagent_recv_chunk(uint32_t size)
{
    if (trace_event_get_state(TRACE_VDAGENT_RECV_CHUNK) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 139 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_recv_chunk " "size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , size);
#line 3825 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 139 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_recv_chunk " "size %d" "\n", size);
#line 3829 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_recv_chunk(uint32_t size)
{
    if (true) {
        _nocheck__trace_vdagent_recv_chunk(size);
    }
}

#define TRACE_VDAGENT_RECV_MSG_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_RECV_MSG) || \
    false)

static inline void _nocheck__trace_vdagent_recv_msg(const char * name, uint32_t size)
{
    if (trace_event_get_state(TRACE_VDAGENT_RECV_MSG) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 140 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_recv_msg " "msg %s, size %d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, size);
#line 3856 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 140 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_recv_msg " "msg %s, size %d" "\n", name, size);
#line 3860 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_recv_msg(const char * name, uint32_t size)
{
    if (true) {
        _nocheck__trace_vdagent_recv_msg(name, size);
    }
}

#define TRACE_VDAGENT_PEER_CAP_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_PEER_CAP) || \
    false)

static inline void _nocheck__trace_vdagent_peer_cap(const char * name)
{
    if (trace_event_get_state(TRACE_VDAGENT_PEER_CAP) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 141 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_peer_cap " "cap %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3887 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 141 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_peer_cap " "cap %s" "\n", name);
#line 3891 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_peer_cap(const char * name)
{
    if (true) {
        _nocheck__trace_vdagent_peer_cap(name);
    }
}

#define TRACE_VDAGENT_CB_GRAB_SELECTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_CB_GRAB_SELECTION) || \
    false)

static inline void _nocheck__trace_vdagent_cb_grab_selection(const char * name)
{
    if (trace_event_get_state(TRACE_VDAGENT_CB_GRAB_SELECTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 142 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_cb_grab_selection " "selection %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3918 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 142 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_cb_grab_selection " "selection %s" "\n", name);
#line 3922 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_cb_grab_selection(const char * name)
{
    if (true) {
        _nocheck__trace_vdagent_cb_grab_selection(name);
    }
}

#define TRACE_VDAGENT_CB_GRAB_DISCARD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_CB_GRAB_DISCARD) || \
    false)

static inline void _nocheck__trace_vdagent_cb_grab_discard(const char * name, int cur, int recv)
{
    if (trace_event_get_state(TRACE_VDAGENT_CB_GRAB_DISCARD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 143 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_cb_grab_discard " "selection %s, cur:%d recv:%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name, cur, recv);
#line 3949 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 143 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_cb_grab_discard " "selection %s, cur:%d recv:%d" "\n", name, cur, recv);
#line 3953 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_cb_grab_discard(const char * name, int cur, int recv)
{
    if (true) {
        _nocheck__trace_vdagent_cb_grab_discard(name, cur, recv);
    }
}

#define TRACE_VDAGENT_CB_GRAB_TYPE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_CB_GRAB_TYPE) || \
    false)

static inline void _nocheck__trace_vdagent_cb_grab_type(const char * name)
{
    if (trace_event_get_state(TRACE_VDAGENT_CB_GRAB_TYPE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 144 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_cb_grab_type " "type %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , name);
#line 3980 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 144 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_cb_grab_type " "type %s" "\n", name);
#line 3984 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_cb_grab_type(const char * name)
{
    if (true) {
        _nocheck__trace_vdagent_cb_grab_type(name);
    }
}

#define TRACE_VDAGENT_CB_SERIAL_DISCARD_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_VDAGENT_CB_SERIAL_DISCARD) || \
    false)

static inline void _nocheck__trace_vdagent_cb_serial_discard(uint32_t current, uint32_t received)
{
    if (trace_event_get_state(TRACE_VDAGENT_CB_SERIAL_DISCARD) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 145 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:vdagent_cb_serial_discard " "current=%u, received=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , current, received);
#line 4011 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 145 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("vdagent_cb_serial_discard " "current=%u, received=%u" "\n", current, received);
#line 4015 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_vdagent_cb_serial_discard(uint32_t current, uint32_t received)
{
    if (true) {
        _nocheck__trace_vdagent_cb_serial_discard(current, received);
    }
}

#define TRACE_DBUS_REGISTERED_LISTENER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_REGISTERED_LISTENER) || \
    false)

static inline void _nocheck__trace_dbus_registered_listener(const char * bus_name)
{
    if (trace_event_get_state(TRACE_DBUS_REGISTERED_LISTENER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 148 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_registered_listener " "peer %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus_name);
#line 4042 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 148 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_registered_listener " "peer %s" "\n", bus_name);
#line 4046 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_registered_listener(const char * bus_name)
{
    if (true) {
        _nocheck__trace_dbus_registered_listener(bus_name);
    }
}

#define TRACE_DBUS_LISTENER_VANISHED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_LISTENER_VANISHED) || \
    false)

static inline void _nocheck__trace_dbus_listener_vanished(const char * bus_name)
{
    if (trace_event_get_state(TRACE_DBUS_LISTENER_VANISHED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 149 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_listener_vanished " "peer %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus_name);
#line 4073 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 149 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_listener_vanished " "peer %s" "\n", bus_name);
#line 4077 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_listener_vanished(const char * bus_name)
{
    if (true) {
        _nocheck__trace_dbus_listener_vanished(bus_name);
    }
}

#define TRACE_DBUS_KBD_PRESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_KBD_PRESS) || \
    false)

static inline void _nocheck__trace_dbus_kbd_press(unsigned int keycode)
{
    if (trace_event_get_state(TRACE_DBUS_KBD_PRESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 150 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_kbd_press " "keycode %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , keycode);
#line 4104 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 150 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_kbd_press " "keycode %u" "\n", keycode);
#line 4108 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_kbd_press(unsigned int keycode)
{
    if (true) {
        _nocheck__trace_dbus_kbd_press(keycode);
    }
}

#define TRACE_DBUS_KBD_RELEASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_KBD_RELEASE) || \
    false)

static inline void _nocheck__trace_dbus_kbd_release(unsigned int keycode)
{
    if (trace_event_get_state(TRACE_DBUS_KBD_RELEASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 151 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_kbd_release " "keycode %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , keycode);
#line 4135 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 151 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_kbd_release " "keycode %u" "\n", keycode);
#line 4139 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_kbd_release(unsigned int keycode)
{
    if (true) {
        _nocheck__trace_dbus_kbd_release(keycode);
    }
}

#define TRACE_DBUS_MOUSE_PRESS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_MOUSE_PRESS) || \
    false)

static inline void _nocheck__trace_dbus_mouse_press(unsigned int button)
{
    if (trace_event_get_state(TRACE_DBUS_MOUSE_PRESS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 152 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_mouse_press " "button %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , button);
#line 4166 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 152 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_mouse_press " "button %u" "\n", button);
#line 4170 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_mouse_press(unsigned int button)
{
    if (true) {
        _nocheck__trace_dbus_mouse_press(button);
    }
}

#define TRACE_DBUS_MOUSE_RELEASE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_MOUSE_RELEASE) || \
    false)

static inline void _nocheck__trace_dbus_mouse_release(unsigned int button)
{
    if (trace_event_get_state(TRACE_DBUS_MOUSE_RELEASE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 153 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_mouse_release " "button %u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , button);
#line 4197 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 153 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_mouse_release " "button %u" "\n", button);
#line 4201 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_mouse_release(unsigned int button)
{
    if (true) {
        _nocheck__trace_dbus_mouse_release(button);
    }
}

#define TRACE_DBUS_MOUSE_SET_POS_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_MOUSE_SET_POS) || \
    false)

static inline void _nocheck__trace_dbus_mouse_set_pos(unsigned int x, unsigned int y)
{
    if (trace_event_get_state(TRACE_DBUS_MOUSE_SET_POS) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 154 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_mouse_set_pos " "x=%u, y=%u" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , x, y);
#line 4228 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 154 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_mouse_set_pos " "x=%u, y=%u" "\n", x, y);
#line 4232 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_mouse_set_pos(unsigned int x, unsigned int y)
{
    if (true) {
        _nocheck__trace_dbus_mouse_set_pos(x, y);
    }
}

#define TRACE_DBUS_MOUSE_REL_MOTION_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_MOUSE_REL_MOTION) || \
    false)

static inline void _nocheck__trace_dbus_mouse_rel_motion(int dx, int dy)
{
    if (trace_event_get_state(TRACE_DBUS_MOUSE_REL_MOTION) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 155 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_mouse_rel_motion " "dx=%d, dy=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , dx, dy);
#line 4259 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 155 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_mouse_rel_motion " "dx=%d, dy=%d" "\n", dx, dy);
#line 4263 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_mouse_rel_motion(int dx, int dy)
{
    if (true) {
        _nocheck__trace_dbus_mouse_rel_motion(dx, dy);
    }
}

#define TRACE_DBUS_UPDATE_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_UPDATE) || \
    false)

static inline void _nocheck__trace_dbus_update(int x, int y, int w, int h)
{
    if (trace_event_get_state(TRACE_DBUS_UPDATE) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 156 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_update " "x=%d, y=%d, w=%d, h=%d" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , x, y, w, h);
#line 4290 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 156 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_update " "x=%d, y=%d, w=%d, h=%d" "\n", x, y, w, h);
#line 4294 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_update(int x, int y, int w, int h)
{
    if (true) {
        _nocheck__trace_dbus_update(x, y, w, h);
    }
}

#define TRACE_DBUS_CLIPBOARD_GRAB_FAILED_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_CLIPBOARD_GRAB_FAILED) || \
    false)

static inline void _nocheck__trace_dbus_clipboard_grab_failed(void)
{
    if (trace_event_get_state(TRACE_DBUS_CLIPBOARD_GRAB_FAILED) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 157 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_clipboard_grab_failed " "" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     );
#line 4321 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 157 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_clipboard_grab_failed " "" "\n");
#line 4325 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_clipboard_grab_failed(void)
{
    if (true) {
        _nocheck__trace_dbus_clipboard_grab_failed();
    }
}

#define TRACE_DBUS_CLIPBOARD_REGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_CLIPBOARD_REGISTER) || \
    false)

static inline void _nocheck__trace_dbus_clipboard_register(const char * bus_name)
{
    if (trace_event_get_state(TRACE_DBUS_CLIPBOARD_REGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 158 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_clipboard_register " "peer %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus_name);
#line 4352 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 158 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_clipboard_register " "peer %s" "\n", bus_name);
#line 4356 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_clipboard_register(const char * bus_name)
{
    if (true) {
        _nocheck__trace_dbus_clipboard_register(bus_name);
    }
}

#define TRACE_DBUS_CLIPBOARD_UNREGISTER_BACKEND_DSTATE() ( \
    trace_event_get_state_dynamic_by_id(TRACE_DBUS_CLIPBOARD_UNREGISTER) || \
    false)

static inline void _nocheck__trace_dbus_clipboard_unregister(const char * bus_name)
{
    if (trace_event_get_state(TRACE_DBUS_CLIPBOARD_UNREGISTER) && qemu_loglevel_mask(LOG_TRACE)) {
        if (message_with_timestamp) {
            struct timeval _now;
            gettimeofday(&_now, NULL);
#line 159 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("%d@%zu.%06zu:dbus_clipboard_unregister " "peer %s" "\n",
                     qemu_get_thread_id(),
                     (size_t)_now.tv_sec, (size_t)_now.tv_usec
                     , bus_name);
#line 4383 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        } else {
#line 159 "C:/Users/seski/source/repos/xemu-uwp/ui/trace-events"
            qemu_log("dbus_clipboard_unregister " "peer %s" "\n", bus_name);
#line 4387 "C:/Users/seski/source/repos/xemu-uwp/build/trace/trace-ui.h"
        }
    }
}

static inline void trace_dbus_clipboard_unregister(const char * bus_name)
{
    if (true) {
        _nocheck__trace_dbus_clipboard_unregister(bus_name);
    }
}
#endif /* TRACE_UI_GENERATED_TRACERS_H */
